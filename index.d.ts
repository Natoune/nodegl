/**
 * @file OpenGL 1.1 TypeScript definitions.
 * @version 1.0.0
 * @author Natoune <contact@natoune.fr>
 * @license MIT
 * @see https://github.com/Natoune/nodegl
 * @see https://www.khronos.org/opengl
 * @see https://docs.gl/
 *
 * @summary TypeScript definitions for OpenGL 1.1.
 */

/**
 * Pointer to a value or an array of values.
 */
type Ptr<T> = number | T;

/**
 * A boolean value, either {@link GL_TRUE} or {@link GL_FALSE}
 */
type GLboolean = boolean;

/**
 * Signed, 2's complement binary integer
 *
 * @see {@link GL_BYTE}
 */
type GLbyte = number;

/**
 * Unsigned binary integer
 *
 * @see {@link GL_UNSIGNED_BYTE}
 */
type GLubyte = number;

/**
 * Signed, 2's complement binary short
 *
 * @see {@link GL_SHORT}
 */
type GLshort = number;

/**
 * Unsigned binary integer
 *
 * @see {@link GL_UNSIGNED_SHORT}
 */
type GLushort = number;

/**
 * Signed, 2's complement binary integer
 *
 * @see {@link GL_INT}
 */
type GLint = number;

/**
 * Unsigned binary integer
 *
 * @see {@link GL_UNSIGNED_INT}
 */
type GLuint = number;

/**
 * Signed, 2's complement 16.16 integer
 */
type GLfixed = number;

/**
 * Signed, 2's complement binary integer
 */
type GLint64 = number;

/**
 * Unsigned binary integer
 */
type GLuint64 = number;

/**
 * A non-negative binary integer, for sizes.
 */
type GLsizei = number;

/**
 * An OpenGL enumerator value
 */
type GLenum = number;

/**
 * Signed, 2's complement binary integer
 */
type GLintptr = number;

/**
 * Non-negative binary integer size, for memory offsets and ranges
 */
type GLsizeiptr = number;

/**
 * [Sync Object](https://www.khronos.org/opengl/wiki/Sync_Object) handle
 */
type GLsync = number;

/**
 * A bitfield value
 */
type GLbitfield = number;

/**
 * [An IEEE-754 floating-point value](https://www.khronos.org/opengl/wiki/Small_Float_Formats)
 */
type GLhalf = number;

/**
 * [An IEEE-754 floating-point value](https://www.khronos.org/opengl/wiki/Small_Float_Formats)
 *
 * @see {@link GL_FLOAT}
 */
type GLfloat = number;

/**
 * [An IEEE-754 floating-point value](https://www.khronos.org/opengl/wiki/Small_Float_Formats) clamped to the range [0, 1]
 */
type GLclampf = number;

/**
 * [An IEEE-754 floating-point value](https://www.khronos.org/opengl/wiki/Small_Float_Formats)
 *
 * @see {@link GL_DOUBLE}
 */
type GLdouble = number;

/**
 * [An IEEE-754 floating-point value](https://www.khronos.org/opengl/wiki/Small_Float_Formats) clamped to the range [0, 1]
 */
type GLclampd = number;

/**
 * A pointer to a null-terminated ASCII string
 */
type GLvoid = void;

/**
 * The accumulation buffer is an extended-range color buffer. Images are not rendered into it. Rather, images rendered into one of the color buffers are added to the contents of the accumulation buffer after rendering. Effects such as antialiasing (of points, lines, and polygons), motion blur, and depth of field can be created by accumulating images generated with different transformation matrices.
 *
 * Each pixel in the accumulation buffer consists of red, green, blue, and alpha values. The number of bits per component in the accumulation buffer depends on the implementation. You can examine this number by calling {@link glGetIntegerv} four times, with arguments {@link GL_ACCUM_RED_BITS}, {@link GL_ACCUM_GREEN_BITS}, {@link GL_ACCUM_BLUE_BITS}, and {@link GL_ACCUM_ALPHA_BITS}. Regardless of the number of bits per component, the range of values stored by each component is [−1,1]. The accumulation buffer pixels are mapped one-to-one with frame buffer pixels.
 *
 * `glAccum` operates on the accumulation buffer. The first argument, **op**, is a symbolic constant that selects an accumulation buffer operation. The second argument, **value**, is a floating-point value to be used in that operation. Five operations are specified: {@link GL_ACCUM}, {@link GL_LOAD}, {@link GL_ADD}, {@link GL_MULT}, and {@link GL_RETURN}.
 *
 * All accumulation buffer operations are limited to the area of the current scissor box and applied identically to the red, green, blue, and alpha components of each pixel. If a `glAccum` operation results in a value outside the range [−1,1], the contents of an accumulation buffer pixel component are undefined.
 *
 * The operations are as follows:
 *
 * - {@link GL_ACCUM}
 * Obtains R, G, B, and A values from the buffer currently selected for reading (see {@link glReadBuffer}). Each component value is divided by 2ⁿ−1, where n is the number of bits allocated to each color component in the currently selected buffer. The result is a floating-point value in the range [0,1], which is multiplied by **value** and added to the corresponding pixel component in the accumulation buffer, thereby updating the accumulation buffer.
 *
 * - {@link GL_LOAD}
 * Similar to {@link GL_ACCUM}, except that the current value in the accumulation buffer is not used in the calculation of the new value. That is, the R, G, B, and A values from the currently selected buffer are divided by 2ⁿ−1, multiplied by **value**, and then stored in the corresponding accumulation buffer cell, overwriting the current value.
 *
 * - {@link GL_ADD}
 * Adds **value** to each R, G, B, and A in the accumulation buffer.
 *
 * - {@link GL_MULT}
 * Multiplies each R, G, B, and A in the accumulation buffer by **value** and returns the scaled component to its corresponding accumulation buffer location.
 *
 * - {@link GL_RETURN}
 * Transfers accumulation buffer values to the color buffer or buffers currently selected for writing. Each R, G, B, and A component is multiplied by **value**, then multiplied by 2ⁿ−1, clamped to the range [0,2ⁿ−1], and stored in the corresponding display buffer cell. The only fragment operations that are applied to this transfer are pixel ownership, scissor, dithering, and color writemasks.
 *
 * To clear the accumulation buffer, call {@link glClearAccum} with R, G, B, and A values to set it to, then call {@link glClear} with the accumulation buffer enabled.
 *
 * @summary operate on the accumulation buffer
 * @param op Specifies the accumulation buffer operation. Symbolic constants {@link GL_ACCUM}, {@link GL_LOAD}, {@link GL_ADD}, {@link GL_MULT}, and {@link GL_RETURN} are accepted.
 * @param value Specifies a floating-point value used in the accumulation buffer operation. **op** determines how **value** is used.
 * @see [glAccum](https://docs.gl/gl3/glAccum)
 */
export function glAccum(op: GLenum, value: GLfloat): void;

/**
 * The alpha test discards fragments depending on the outcome of a comparison between an incoming fragment's alpha value and a constant reference value. `glAlphaFunc` specifies the reference value and the comparison function. The comparison is performed only if alpha testing is enabled. By default, it is not enabled. (See {@link glEnable} and {@link glDisable} of {@link GL_ALPHA_TEST}.)
 *
 * **func** and **ref** specify the conditions under which the pixel is drawn. The incoming alpha value is compared to **ref** using the function specified by **func**. If the value passes the comparison, the incoming fragment is drawn if it also passes subsequent stencil and depth buffer tests. If the value fails the comparison, no change is made to the frame buffer at that pixel location. The comparison functions are as follows:
 *
 * - {@link GL_NEVER}
 * Never passes.
 *
 * - {@link GL_LESS}
 * Passes if the incoming alpha value is less than the reference value.
 *
 * - {@link GL_EQUAL}
 * Passes if the incoming alpha value is equal to the reference value.
 *
 * - {@link GL_LEQUAL}
 * Passes if the incoming alpha value is less than or equal to the reference value.
 *
 * - {@link GL_GREATER}
 * Passes if the incoming alpha value is greater than the reference value.
 *
 * - {@link GL_NOTEQUAL}
 * Passes if the incoming alpha value is not equal to the reference value.
 *
 * - {@link GL_GEQUAL}
 * Passes if the incoming alpha value is greater than or equal to the reference value.
 *
 * - {@link GL_ALWAYS}
 * Always passes.
 *
 * `glAlphaFunc` operates on all pixel write operations, including those resulting from the scan conversion of points, lines, polygons, and bitmaps, and from pixel draw and copy operations. `glAlphaFunc` does not affect screen clear operations.
 *
 * @summary specify the alpha test function
 * @param func Specifies the alpha comparison function. Symbolic constants {@link GL_NEVER}, {@link GL_LESS}, {@link GL_EQUAL}, {@link GL_LEQUAL}, {@link GL_GREATER}, {@link GL_NOTEQUAL}, {@link GL_GEQUAL}, and {@link GL_ALWAYS} are accepted. The initial value is {@link GL_ALWAYS}.
 * @param ref Specifies the reference value that incoming alpha values are compared to. This value is clamped to the range [0,1], where 0 represents the lowest possible alpha value and 1 the highest possible value. The initial reference value is 0.
 * @see [glAlphaFunc](https://docs.gl/gl3/glAlphaFunc)
 */
export function glAlphaFunc(func: GLenum, ref: GLclampf): void;

/**
 * GL establishes a "working set" of textures that are resident in texture memory. These textures can be bound to a texture target much more efficiently than textures that are not resident.
 *
 * `glAreTexturesResident` queries the texture residence status of the **n** textures named by the elements of **textures**. If all the named textures are resident, `glAreTexturesResident` returns {@link GL_TRUE}, and the contents of **residences** are undisturbed. If not all the named textures are resident, `glAreTexturesResident` returns {@link GL_FALSE}, and detailed status is returned in the **n** elements of **residences**. If an element of **residences** is {@link GL_TRUE}, then the texture named by the corresponding element of **textures** is resident.
 *
 * The residence status of a single bound texture may also be queried by calling {@link glGetTexParameter} with the **target** argument set to the target to which the texture is bound, and the **pname** argument set to {@link GL_TEXTURE_RESIDENT}. This is the only way that the residence status of a default texture can be queried.
 *
 * @summary determine if textures are loaded in texture memory
 * @param n Specifies the number of textures to be queried.
 * @param textures Specifies an array containing the names of the textures to be queried.
 * @param residences Specifies an array in which the texture residence status is returned. The residence status of a texture named by an element of **textures** is returned in the corresponding element of **residences**.
 * @see [glAreTexturesResident](https://docs.gl/gl3/glAreTexturesResident)
 */
export function glAreTexturesResident(
	n: GLsizei,
	textures: Ptr<GLuint>,
	residences: Ptr<GLboolean>
): GLboolean;

/**
 * `glArrayElement` commands are used within {@link glBegin}/{@link glEnd} pairs to specify vertex and attribute data for point, line, and polygon primitives. If {@link GL_VERTEX_ARRAY} is enabled when `glArrayElement` is called, a single vertex is drawn, using vertex and attribute data taken from location **i** of the enabled arrays. If {@link GL_VERTEX_ARRAY} is not enabled, no drawing occurs but the attributes corresponding to the enabled arrays are modified.
 *
 * Use `glArrayElement` to construct primitives by indexing vertex data, rather than by streaming through arrays of data in first-to-last order. Because each call specifies only a single vertex, it is possible to explicitly specify per-primitive attributes such as a single normal for each triangle.
 *
 * Changes made to array data between the execution of {@link glBegin} and the corresponding execution of {@link glEnd} may affect calls to `glArrayElement` that are made within the same {@link glBegin}/{@link glEnd} period in nonsequential ways. That is, a call to `glArrayElement` that precedes a change to array data may access the changed data, and a call that follows a change to array data may access original data.
 *
 * @summary render a vertex using the specified vertex array element
 * @param i Specifies an index into the enabled vertex data arrays.
 * @see [glArrayElement](https://docs.gl/gl3/glArrayElement)
 */
export function glArrayElement(i: GLint): void;

/**
 * `glBegin` and {@link glEnd} delimit the vertices that define a primitive or a group of like primitives. `glBegin` accepts a single argument that specifies in which of ten ways the vertices are interpreted. Taking n as an integer count starting at one, and N as the total number of vertices specified, the interpretations are as follows:
 *
 * - {@link GL_POINTS}
 * Treats each vertex as a single point. Vertex n defines point n. N points are drawn.
 *
 * - {@link GL_LINES}
 * Treats each pair of vertices as an independent line segment. Vertices 2ⁿ − 1 and 2ⁿ define line n. 𝐍/2 lines are drawn.
 *
 * - {@link GL_LINE_STRIP}
 * Draws a connected group of line segments from the first vertex to the last. Vertices 𝐧 and 𝐧 + 1 define line 𝐧. 𝐍 − 1 lines are drawn.
 *
 * - {@link GL_LINE_LOOP}
 * Draws a connected group of line segments from the first vertex to the last, then back to the first. Vertices 𝐧 and 𝐧 + 1 define line 𝐧. The last line, however, is defined by vertices 𝐍 and 1. 𝐍 lines are drawn.
 *
 * - {@link GL_TRIANGLES}
 * Treats each triplet of vertices as an independent triangle. Vertices 3𝐧 − 2, 3𝐧 − 1, and 3𝐧 define triangle 𝐧. 𝐍3 triangles are drawn.
 *
 * - {@link GL_TRIANGLE_STRIP}
 * Draws a connected group of triangles. One triangle is defined for each vertex presented after the first two vertices. For odd 𝐧, vertices 𝐧, 𝐧 + 1, and 𝐧 + 2 define triangle 𝐧. For even 𝐧, vertices 𝐧 + 1, 𝐧, and 𝐧 + 2 define triangle 𝐧. 𝐍 − 2 triangles are drawn.
 *
 * - {@link GL_TRIANGLE_FAN}
 * Draws a connected group of triangles. One triangle is defined for each vertex presented after the first two vertices. Vertices 1, 𝐧 + 1, and 𝐧 + 2 define triangle 𝐧. 𝐍 − 2 triangles are drawn.
 *
 * - {@link GL_QUADS}
 * Treats each group of four vertices as an independent quadrilateral. Vertices 4𝐧 − 3, 4𝐧 − 2, 4𝐧 − 1, and 4𝐧 define quadrilateral 𝐧. 𝐍/4 quadrilaterals are drawn.
 *
 * - {@link GL_QUAD_STRIP}
 * Draws a connected group of quadrilaterals. One quadrilateral is defined for each pair of vertices presented after the first pair. Vertices 2𝐧 − 1, 2𝐧, 2𝐧 + 2, and 2𝐧 + 1 define quadrilateral 𝐧. 𝐍/2 − 1 quadrilaterals are drawn. Note that the order in which vertices are used to construct a quadrilateral from strip data is different from that used with independent data.
 *
 * - {@link GL_POLYGON}
 * Draws a single, convex polygon. Vertices 1 through 𝐍 define this polygon.
 *
 * Only a subset of GL commands can be used between `glBegin` and {@link glEnd}. The commands are {@link glVertex}, {@link glColor}, {@link glSecondaryColor}, {@link glIndex}, {@link glNormal}, {@link glFogCoord}, {@link glTexCoord}, {@link glMultiTexCoord}, {@link glVertexAttrib}, {@link glEvalCoord}, {@link glEvalPoint}, {@link glArrayElement}, {@link glMaterial}, and {@link glEdgeFlag}. Also, it is acceptable to use {@link glCallList} or {@link glCallLists} to execute display lists that include only the preceding commands. If any other GL command is executed between `glBegin` and {@link glEnd}, the error flag is set and the command is ignored.
 *
 * Regardless of the value chosen for **mode**, there is no limit to the number of vertices that can be defined between `glBegin` and {@link glEnd}. Lines, triangles, quadrilaterals, and polygons that are incompletely specified are not drawn. Incomplete specification results when either too few vertices are provided to specify even a single primitive or when an incorrect multiple of vertices is specified. The incomplete primitive is ignored; the rest are drawn.
 *
 * The minimum specification of vertices for each primitive is as follows: 1 for a point, 2 for a line, 3 for a triangle, 4 for a quadrilateral, and 3 for a polygon. Modes that require a certain multiple of vertices are {@link GL_LINES} (2), {@link GL_TRIANGLES} (3), {@link GL_QUADS} (4), and {@link GL_QUAD_STRIP} (2).
 *
 * @summary delimit the vertices of a primitive or a group of like primitives
 * @param mode Specifies the primitive or primitives that will be created from vertices presented between `glBegin` and the subsequent {@link glEnd}. Ten symbolic constants are accepted: {@link GL_POINTS}, {@link GL_LINES}, {@link GL_LINE_STRIP}, {@link GL_LINE_LOOP}, {@link GL_TRIANGLES}, {@link GL_TRIANGLE_STRIP}, {@link GL_TRIANGLE_FAN}, {@link GL_QUADS}, {@link GL_QUAD_STRIP}, and {@link GL_POLYGON}.
 * @tutorial [Songho - OpenGL Overview](https://www.songho.ca/opengl/gl_overview.html)
 * @tutorial [Songho - OpenGL Vertex Array](https://www.songho.ca/opengl/gl_vertexarray.html)
 * @see [glBegin](https://docs.gl/gl3/glBegin)
 */
export function glBegin(mode: GLenum): void;

/**
 * `glBegin` and {@link glEnd} delimit the vertices that define a primitive or a group of like primitives.
 *
 * Only a subset of GL commands can be used between `glBegin` and {@link glEnd}. The commands are {@link glVertex}, {@link glColor}, {@link glSecondaryColor}, {@link glIndex}, {@link glNormal}, {@link glFogCoord}, {@link glTexCoord}, {@link glMultiTexCoord}, {@link glVertexAttrib}, {@link glEvalCoord}, {@link glEvalPoint}, {@link glArrayElement}, {@link glMaterial}, and {@link glEdgeFlag}. Also, it is acceptable to use {@link glCallList} or {@link glCallLists} to execute display lists that include only the preceding commands. If any other GL command is executed between `glBegin` and {@link glEnd}, the error flag is set and the command is ignored.
 *
 * Regardless of the value chosen for **mode**, there is no limit to the number of vertices that can be defined between `glBegin` and {@link glEnd}. Lines, triangles, quadrilaterals, and polygons that are incompletely specified are not drawn. Incomplete specification results when either too few vertices are provided to specify even a single primitive or when an incorrect multiple of vertices is specified. The incomplete primitive is ignored; the rest are drawn.
 *
 * The minimum specification of vertices for each primitive is as follows: 1 for a point, 2 for a line, 3 for a triangle, 4 for a quadrilateral, and 3 for a polygon. Modes that require a certain multiple of vertices are {@link GL_LINES} (2), {@link GL_TRIANGLES} (3), {@link GL_QUADS} (4), and {@link GL_QUAD_STRIP} (2).
 *
 * @summary delimit the vertices of a primitive or a group of like primitives
 * @tutorial [Songho - OpenGL Overview](https://www.songho.ca/opengl/gl_overview.html)
 * @tutorial [Songho - OpenGL Vertex Array](https://www.songho.ca/opengl/gl_vertexarray.html)
 * @see [glEnd](https://docs.gl/gl3/glEnd)
 */
export function glEnd(): void;

/**
 * `glBindTexture` lets you create or use a named texture. Calling `glBindTexture` with **target** set to {@link GL_TEXTURE_1D}, {@link GL_TEXTURE_2D}, {@link GL_TEXTURE_3D}, or {@link GL_TEXTURE_1D_ARRAY}, {@link GL_TEXTURE_2D_ARRAY}, {@link GL_TEXTURE_RECTANGLE}, {@link GL_TEXTURE_CUBE_MAP}, {@link GL_TEXTURE_BUFFER}, {@link GL_TEXTURE_2D_MULTISAMPLE} or {@link GL_TEXTURE_2D_MULTISAMPLE_ARRAY} and **texture** set to the name of the new texture binds the texture name to the target. When a texture is bound to a target, the previous binding for that target is automatically broken.
 *
 * Texture names are unsigned integers. The value zero is reserved to represent the default texture for each texture target. Texture names and the corresponding texture contents are local to the shared object space of the current GL rendering context; two rendering contexts share texture names only if they explicitly enable sharing between contexts through the appropriate GL windows interfaces functions.
 *
 * You must use {@link glGenTextures} to generate a set of new texture names.
 *
 * When a texture is first bound, it assumes the specified target: A texture first bound to {@link GL_TEXTURE_1D} becomes one-dimensional texture, a texture first bound to {@link GL_TEXTURE_2D} becomes two-dimensional texture, a texture first bound to {@link GL_TEXTURE_3D} becomes three-dimensional texture, a texture first bound to {@link GL_TEXTURE_1D_ARRAY} becomes one-dimensional array texture, a texture first bound to {@link GL_TEXTURE_2D_ARRAY} becomes two-dimensional arary texture, a texture first bound to {@link GL_TEXTURE_RECTANGLE} becomes rectangle texture, a, texture first bound to {@link GL_TEXTURE_CUBE_MAP} becomes a cube-mapped texture, a texture first bound to {@link GL_TEXTURE_BUFFER} becomes a buffer texture, a texture first bound to {@link GL_TEXTURE_2D_MULTISAMPLE} becomes a two-dimensional multisampled texture, and a texture first bound to {@link GL_TEXTURE_2D_MULTISAMPLE_ARRAY} becomes a two-dimensional multisampled array texture. The state of a one-dimensional texture immediately after it is first bound is equivalent to the state of the default {@link GL_TEXTURE_1D} at GL initialization, and similarly for the other texture types.
 *
 * While a texture is bound, GL operations on the target to which it is bound affect the bound texture, and queries of the target to which it is bound return state from the bound texture. In effect, the texture targets become aliases for the textures currently bound to them, and the texture name zero refers to the default textures that were bound to them at initialization.
 *
 * A texture binding created with `glBindTexture` remains active until a different texture is bound to the same target, or until the bound texture is deleted with {@link glDeleteTextures}.
 *
 * Once created, a named texture may be re-bound to its same original target as often as needed. It is usually much faster to use `glBindTexture` to bind an existing named texture to one of the texture targets than it is to reload the texture image using {@link glTexImage1D}, {@link glTexImage2D}, {@link glTexImage3D} or another similar function.
 *
 * @summary bind a named texture to a texturing target
 * @param target Specifies the target to which the texture is bound. Must be either {@link GL_TEXTURE_1D}, {@link GL_TEXTURE_2D}, {@link GL_TEXTURE_3D}, or {@link GL_TEXTURE_1D_ARRAY}, {@link GL_TEXTURE_2D_ARRAY}, {@link GL_TEXTURE_RECTANGLE}, {@link GL_TEXTURE_CUBE_MAP}, {@link GL_TEXTURE_BUFFER}, {@link GL_TEXTURE_2D_MULTISAMPLE} or {@link GL_TEXTURE_2D_MULTISAMPLE_ARRAY}.
 * @param texture Specifies the name of a texture.
 * @example Create a framebuffer object with a texture-based color attachment and a texture-based depth attachment. Using texture-based attachments allows sampling of those textures in shaders.
 * ```
 * // fbo_width and fbo_height are the desired width and height of the FBO.
 * // For Opengl <= 4.4 or if the {@link GL_ARB_}texture_non_power_of_two extension
 * // is present, fbo_width and fbo_height can be values other than 2^n for
 * // some integer n.
 *
 * // Build the texture that will serve as the color attachment for the framebuffer.
 * let texture_map: GLuint;
 * glGenTextures(1, texture_map);
 * glBindTexture(GL_TEXTURE_2D, texture_map);
 *
 * glTexparameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
 * glTexparameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
 * glTexparameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
 * glTexparameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);
 *
 * glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, fbo_width, fbo_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, null);
 *
 * glBindTexture(GL_TEXTURE_2D, 0);
 *
 * // Build the texture that will serve as the depth attachment for the framebuffer.
 * let depth_texture: GLuint;
 * glGenTextures(1, depth_texture);
 * glBindTexture(GL_TEXTURE_2D, depth_texture);
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
 * glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, fbo_width, fbo_height, 0, GL_DEPTH_COMPONENT, GL_UNSIGNED_BYTE, NULL);
 * glBindTexture(GL_TEXTURE_2D, 0);
 *
 * // Build the framebuffer.
 * let framebuffer: GLuint;
 * glGenFramebuffers(1, framebuffer);
 * glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);
 * glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture_map, 0);
 * glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depth_texture, 0);
 *
 * status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
 * if (status != GL_FRAMEBUFFER_COMPLETE)
 *     // Error
 *
 * glBindFramebuffer(GL_FRAMEBUFFER, 0);
 * ```
 *
 * @example Create a texture object with linear mipmaps and edge clamping.
 * ```
 * let texture_id: GLuint;
 * glGenTextures(1, texture_id);
 * glBindTexture(GL_TEXTURE_2D, texture_id);
 *
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
 *
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
 *
 * // texture_data is the source data of your texture, in this case
 * // its size is sizeof(unsigned char) * texture_width * texture_height * 4
 * glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, texture_width, texture_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, texture_data);
 * glGenerateMipmap(GL_TEXTURE_2D); // Unavailable in OpenGL 2.1, use gluBuild2DMipmaps() instead
 *
 * glBindTexture(GL_TEXTURE_2D, 0);
 * ```
 *
 * @tutorial [Sébastien Dominé - Using Texture Compression in OpenGL](https://www.oldunreal.com/editing/s3tc/ARB_texture_compression.pdf)
 * @tutorial [Songho - OpenGL Pixel Buffer Object (PBO)](https://www.songho.ca/opengl/gl_pbo.html)
 * @tutorial [open.gl - Framebuffers](https://open.gl/framebuffers)
 * @tutorial [open.gl - Geometry Shaders](https://open.gl/geometry)
 * @tutorial [open.gl - Textures Objects and Parameters](https://open.gl/textures)
 * @tutorial [opengl-tutorial.org - Tutorial 13 : Normal Mapping](https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-13-normal-mapping/)
 * @tutorial [opengl-tutorial.org - Tutorial 14 : Render To Texture](https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-14-render-to-texture/)
 * @tutorial [opengl-tutorial.org - Tutorial 16 : Shadow mapping](https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/)
 * @tutorial [opengl-tutorial.org - Tutorial 5 : A Textured Cube](https://www.opengl-tutorial.org/beginners-tutorials/tutorial-5-a-textured-cube/)
 *
 * @see [glBindTexture](https://docs.gl/gl3/glBindTexture)
 */
export function glBindTexture(target: GLenum, texture: GLuint): void;

/**
 * A bitmap is a binary image. When drawn, the bitmap is positioned relative to the current raster position, and frame buffer pixels corresponding to 1's in the bitmap are written using the current raster color or index. Frame buffer pixels corresponding to 0's in the bitmap are not modified.
 *
 * `glBitmap` takes seven arguments. The first pair specifies the width and height of the bitmap image. The second pair specifies the location of the bitmap origin relative to the lower left corner of the bitmap image. The third pair of arguments specifies **x** and **y** offsets to be added to the current raster position after the bitmap has been drawn. The final argument is a pointer to the bitmap image itself.
 *
 * If a non-zero named buffer object is bound to the {@link GL_PIXEL_UNPACK_BUFFER} target (see {@link glBindBuffer}) while a bitmap image is specified, bitmap is treated as a byte offset into the buffer object's data store.
 *
 * The bitmap image is interpreted like image data for the {@link glDrawPixels} command, with width and height corresponding to the width and height arguments of that command, and with **type** set to {@link GL_BITMAP} and **format** set to {@link GL_COLOR_INDEX}. Modes specified using {@link glPixelStore} affect the interpretation of bitmap image data; modes specified using {@link glPixelTransfer} do not.
 *
 * If the current raster position is invalid, `glBitmap` is ignored. Otherwise, the lower left corner of the bitmap image is positioned at the window coordinates
 *
 * 𝐱𝑤 = ⌊𝐱𝑟 - x𝑜⌋
 *
 * 𝐲𝑤 = ⌊𝐲𝑟 - 𝐲𝑜⌋
 *
 * where (𝐱𝑟, 𝐲𝑟) is the raster position and (x𝑜, 𝐲𝑜) is the bitmap origin. Fragments are then generated for each pixel corresponding to a 1 (one) in the bitmap image. These fragments are generated using the current raster **z** coordinate, color or color index, and current raster texture coordinates. They are then treated just as if they had been generated by a point, line, or polygon, including texture mapping, fogging, and all per-fragment operations such as alpha and depth testing.
 *
 * After the bitmap has been drawn, the *x* and *y* coordinates of the current raster position are offset by xmove and ymove. No change is made to the **z** coordinate of the current raster position, or to the current raster color, texture coordinates, or index.
 *
 * @summary draw a bitmap
 * @param width Specifies the pixel width of the bitmap image.
 * @param height Specifies the pixel height of the bitmap image.
 * @param xorig Specifies the location of the origin in the bitmap image. The origin is measured from the lower left corner of the bitmap, with right and up being the positive axes.
 * @param yorig Specifies the location of the origin in the bitmap image. The origin is measured from the lower left corner of the bitmap, with right and up being the positive axes.
 * @param xmove Specifies the **x** offset to be added to the current raster position after the bitmap is drawn.
 * @param ymove Specifies the **y** offset to be added to the current raster position after the bitmap is drawn.
 * @param bitmap Specifies the address of the bitmap image.
 * @see [glBitmap](https://docs.gl/gl3/glBitmap)
 */
export function glBitmap(
	width: GLsizei,
	height: GLsizei,
	xorig: GLfloat,
	yorig: GLfloat,
	xmove: GLfloat,
	ymove: GLfloat,
	bitmap: GLubyte
): void;

/**
 * Pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already in the frame buffer (the destination values). Blending is initially disabled. Use {@link glEnable} and {@link glDisable} with argument {@link GL_BLEND} to enable and disable blending.
 *
 * `glBlendFunc` defines the operation of blending when it is enabled. sfactor specifies which method is used to scale the source color components. dfactor specifies which method is used to scale the destination color components. Both parameters must be one of the following symbolic constants: {@link GL_ZERO}, {@link GL_ONE}, {@link GL_SRC_COLOR}, {@link GL_ONE_MINUS_SRC_COLOR}, {@link GL_DST_COLOR}, {@link GL_ONE_MINUS_DST_COLOR}, {@link GL_SRC_ALPHA}, {@link GL_ONE_MINUS_SRC_ALPHA}, {@link GL_DST_ALPHA}, {@link GL_ONE_MINUS_DST_ALPHA}, {@link GL_CONSTANT_COLOR}, {@link GL_ONE_MINUS_CONSTANT_COLOR}, {@link GL_CONSTANT_ALPHA}, {@link GL_ONE_MINUS_CONSTANT_ALPHA}, {@link GL_SRC_ALPHA_SATURATE}, {@link GL_SRC1_COLOR}, {@link GL_ONE_MINUS_SRC1_COLOR}, {@link GL_SRC1_ALPHA}, and {@link GL_ONE_MINUS_SRC1_ALPHA}. The possible methods are described in the following table. Each method defines four scale factors, one each for red, green, blue, and alpha. In the table and in subsequent equations, first source, second source and destination color components are referred to as (𝐑s0,𝐆s0,𝐁s0,𝐀s0), (𝐑s1,𝐆s1,𝐁s1,𝐀s1) and (𝐑d,𝐆d,𝐁d,𝐀d), respectively. The color specified by {@link glBlendColor} is referred to as (𝐑c,𝐆c,𝐁c,𝐀c). They are understood to have integer values between 0 and (k𝐑,k𝐆,k𝐁,k𝐀), where
 *
 * 𝐊𝑐 = 2ᵐᶜ − 1
 *
 * and (𝐦𝑅, 𝐦𝐺, 𝐦𝐵, 𝐦𝐴) is the number of red, green, blue, and alpha bitplanes.
 *
 * Source and destination scale factors are referred to as (𝑠𝐑,𝑠𝐆,𝑠𝐁,𝑠𝐀) and (d𝐑,d𝐆,d𝐁,d𝐀). The scale factors described in the table, denoted (f𝐑,f𝐆,f𝐁,f𝐀), represent either source or destination factors. All scale factors have range [0,1].
 *
 * | **Parameter**                       | **(ƒ𝐑, ƒ𝐆, ƒ𝐁, ƒ𝐀)**                             |
 * | :---------------------------------- | :----------------                                |
 * | {@link GL_ZERO}					 | (0, 0, 0, 0)                                     |
 * | {@link GL_ONE}                      | (1, 1, 1, 1)                                     |
 * | {@link GL_SRC_COLOR}                | (𝐑s0/𝐊𝐑, 𝐆s0/𝐊𝐆, 𝐁s0/𝐊𝐁, 𝐀s0/𝐊𝐀)                 |
 * | {@link GL_ONE_MINUS_SRC_COLOR}      | (1, 1, 1, 1) − (𝐑s0/𝐊𝐑, 𝐆s0/𝐊𝐆, 𝐁s0/𝐊𝐁, 𝐀s0/𝐊𝐀)  |
 * | {@link GL_DST_COLOR}                | (𝐑d/𝐊𝐑, 𝐆d/𝐊𝐆, 𝐁d/𝐊𝐁, 𝐀d/𝐊𝐀)                     |
 * | {@link GL_ONE_MINUS_DST_COLOR}      | (1, 1, 1, 1) − (𝐑d/𝐊𝐑, 𝐆d/𝐊𝐆, 𝐁d/𝐊𝐁, 𝐀d/𝐊𝐀)      |
 * | {@link GL_SRC_ALPHA}                | (𝐀s0/𝐊𝐀, 𝐀s0/𝐊𝐀, 𝐀s0/𝐊𝐀, 𝐀s0/𝐊𝐀)                 |
 * | {@link GL_ONE_MINUS_SRC_ALPHA}      | (1, 1, 1, 1) − (𝐀s0/𝐊𝐀, 𝐀s0/𝐊𝐀, 𝐀s0/𝐊𝐀, 𝐀s0/𝐊𝐀)  |
 * | {@link GL_DST_ALPHA}                | (𝐀d/𝐊𝐀, 𝐀d/𝐊𝐀, 𝐀d/𝐊𝐀, 𝐀d/𝐊𝐀)                     |
 * | {@link GL_ONE_MINUS_DST_ALPHA}      | (1, 1, 1, 1) − (𝐀d/𝐊𝐀, 𝐀d/𝐊𝐀, 𝐀d/𝐊𝐀, 𝐀d/𝐊𝐀)      |
 * | {@link GL_CONSTANT_COLOR}           | (𝐑𝑐, 𝐆𝑐, 𝐁𝑐, 𝐀𝑐)                                 |
 * | {@link GL_ONE_MINUS_CONSTANT_COLOR} | (1, 1, 1, 1) − (𝐑𝑐, 𝐆𝑐, 𝐁𝑐, 𝐀𝑐)                  |
 * | {@link GL_CONSTANT_ALPHA}           | (𝐀𝑐, 𝐀𝑐, 𝐀𝑐, 𝐀𝑐)                                 |
 * | {@link GL_ONE_MINUS_CONSTANT_ALPHA} | (1, 1, 1, 1) − (𝐀𝑐, 𝐀𝑐, 𝐀𝑐, 𝐀𝑐)                  |
 * | {@link GL_SRC_ALPHA_SATURATE}       | (𝐢, 𝐢, 𝐢, 1)                                     |
 * | {@link GL_SRC1_COLOR}               | (𝐑s1/𝐊𝐑, 𝐆s1/𝐊𝐆, 𝐁s1/𝐊𝐁, 𝐀s1/𝐊𝐀)                 |
 * | {@link GL_ONE_MINUS_SRC1_COLOR}     | (1, 1, 1, 1) − (𝐑s1/𝐊𝐑, 𝐆s1/𝐊𝐆, 𝐁s1/𝐊𝐁, 𝐀s1/𝐊𝐀)  |
 * | {@link GL_SRC1_ALPHA}               | (𝐀s1/𝐊𝐀, 𝐀s1/𝐊𝐀, 𝐀s1/𝐊𝐀, 𝐀s1/𝐊𝐀)                 |
 * | {@link GL_ONE_MINUS_SRC1_ALPHA}     | (1, 1, 1, 1) − (𝐀s1/𝐊𝐀, 𝐀s1/𝐊𝐀, 𝐀s1/𝐊𝐀, 𝐀s1/𝐊𝐀)  |
 *
 * In the table,
 *
 * 𝐢 = min(𝐀𝑠, 𝐊𝐀 − 𝐀d) / 𝐊𝐀
 *
 * To determine the blended RGBA values of a pixel, the system uses the following equations:
 *
 * 𝐑𝑑 = min(𝐊𝑅, 𝐑ₛs𝑅 + 𝐑𝑑d𝑅) 𝐆d = min(𝐊𝐺, 𝐆ₛs𝐺 + 𝐆𝑑d𝐺)
 * 𝐁𝑑 = min(𝐊𝐵, 𝐁ₛs𝐵 + 𝐁𝑑d𝐵) 𝐀d = min(𝐊𝐴, 𝐀ₛs𝐴 + 𝐀𝑑d𝐴)
 *
 * Despite the apparent precision of the above equations, blending arithmetic is not exactly specified, because blending operates with imprecise integer color values. However, a blend factor that should be equal to 1 is guaranteed not to modify its multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0. For example, when sfactor is {@link GL_SRC_ALPHA}, dfactor is {@link GL_ONE_MINUS_SRC_ALPHA}, and 𝐀ₛ is equal to 𝐊𝐴, the equations reduce to simple replacement:
 *
 * 𝐑𝑑 = 𝐑ₛ  𝐆d = 𝐆ₛ  𝐁𝑑 = 𝐁ₛ  𝐀d = 𝐀ₛ
 *
 * @summary specify pixel arithmetic
 * @param sfactor Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is {@link GL_ONE}.
 * @param dfactor Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: {@link GL_ZERO}, {@link GL_ONE}, {@link GL_SRC_COLOR}, {@link GL_ONE_MINUS_SRC_COLOR}, {@link GL_DST_COLOR}, {@link GL_ONE_MINUS_DST_COLOR}, {@link GL_SRC_ALPHA}, {@link GL_ONE_MINUS_SRC_ALPHA}, {@link GL_DST_ALPHA}, {@link GL_ONE_MINUS_DST_ALPHA}. {@link GL_CONSTANT_COLOR}, {@link GL_ONE_MINUS_CONSTANT_COLOR}, {@link GL_CONSTANT_ALPHA}, and {@link GL_ONE_MINUS_CONSTANT_ALPHA}. The initial value is {@link GL_ZERO}.
 * @see [glBlendFunc](https://docs.gl/gl3/glBlendFunc)
 */
export function glBlendFunc(sfactor: GLenum, dfactor: GLenum): void;

/**
 * `glCallList` causes the named display list to be executed. The commands saved in the display list are executed in order, just as if they were called without using a display list. If list has not been defined as a display list, `glCallList` is ignored.
 *
 * `glCallList` can appear inside a display list. To avoid the possibility of infinite recursion resulting from display lists calling one another, a limit is placed on the nesting level of display lists during display-list execution. This limit is at least 64, and it depends on the implementation.
 *
 * GL state is not saved and restored across a call to `glCallList`. Thus, changes made to GL state during the execution of a display list remain after execution of the display list is completed. Use {@link glPushAttrib}, {@link glPopAttrib}, {@link glPushMatrix}, and {@link glPopMatrix} to preserve GL state across `glCallList` calls.
 *
 * @summary execute a display list
 * @param list Specifies the integer name of the display list to be executed.
 * @see [glCallList](https://docs.gl/gl3/glCallList)
 */
export function glCallList(list: GLuint): void;

/**
 * `glClear` sets the bitplane area of the window to values previously selected by `glClearColor`, `glClearDepth`, and `glClearStencil`. Multiple color buffers can be cleared simultaneously by selecting more than one buffer at a time using {@link glDrawBuffer}.
 *
 * The pixel ownership test, the scissor test, dithering, and the buffer writemasks affect the operation of `glClear`. The scissor box bounds the cleared region. Alpha function, blend function, logical operation, stenciling, texture mapping, and depth-buffering are ignored by `glClear`.
 *
 * `glClear` takes a single argument that is the bitwise OR of several values indicating which buffer is to be cleared.
 *
 * The values are as follows:
 *
 * - {@link GL_COLOR_BUFFER_BIT}
 * Indicates the buffers currently enabled for color writing.
 *
 * - {@link GL_DEPTH_BUFFER_BIT}
 * Indicates the depth buffer.
 *
 * - {@link GL_STENCIL_BUFFER_BIT}
 * Indicates the stencil buffer.
 *
 * The value to which each buffer is cleared depends on the setting of the clear value for that buffer.
 *
 * @summary clear buffers to preset values
 * @param mask Bitwise OR of masks that indicate the buffers to be cleared. The three masks are {@link GL_COLOR_BUFFER_BIT}, {@link GL_DEPTH_BUFFER_BIT}, and {@link GL_STENCIL_BUFFER_BIT}.
 * @tutorial [open.gl - Depth and Stencil Buffers](https://open.gl/depthstencils)
 * @tutorial [open.gl - Geometry Shaders](https://open.gl/geometry)
 * @tutorial [opengl-tutorial.org - Tutorial 4 : A Colored Cube](https://www.opengl-tutorial.org/beginners-tutorials/tutorial-4-a-colored-cube/)
 * @see [glClear](https://docs.gl/gl3/glClear)
 */
export function glClear(mask: GLbitfield): void;

/**
 * `glClearAccum` specifies the red, green, blue, and alpha values used by {@link glClear} to clear the accumulation buffer.
 *
 * Values specified by `glClearAccum` are clamped to the range [−1,1].
 *
 * @summary specify clear values for the accumulation buffer
 * @param red Specifies the red value used when the accumulation buffer is cleared. The initial value is 0.
 * @param green Specifies the green value used when the accumulation buffer is cleared. The initial value is 0.
 * @param blue Specifies the blue value used when the accumulation buffer is cleared. The initial value is 0.
 * @param alpha Specifies the alpha value used when the accumulation buffer is cleared. The initial value is 0.
 * @see [glClearAccum](https://docs.gl/gl3/glClearAccum)
 */
export function glClearAccum(
	red: GLfloat,
	green: GLfloat,
	blue: GLfloat,
	alpha: GLfloat
): void;

/**
 * `glClearColor` specifies the red, green, blue, and alpha values used by {@link glClear} to clear the color buffers. Values specified by `glClearColor` are clamped to the range [0,1].
 *
 * @summary specify clear values for the color buffers
 * @param red Specifies the red value used when the color buffers are cleared. The initial value is 0.
 * @param green Specifies the green value used when the color buffers are cleared. The initial value is 0.
 * @param blue Specifies the blue value used when the color buffers are cleared. The initial value is 0.
 * @param alpha Specifies the alpha value used when the color buffers are cleared. The initial value is 0.
 * @see [glClearColor](https://docs.gl/gl3/glClearColor)
 */
export function glClearColor(
	red: GLclampf,
	green: GLclampf,
	blue: GLclampf,
	alpha: GLclampf
): void;

/**
 * `glClearDepth` specifies the depth value used by {@link glClear} to clear the depth buffer. Values specified by `glClearDepth` are clamped to the range [0,1].
 *
 * @summary specify the clear value for the depth buffer
 * @param depth Specifies the depth value used when the depth buffer is cleared. The initial value is 1.
 * @see [glClearDepth](https://docs.gl/gl3/glClearDepth)
 */
export function glClearDepth(depth: GLclampd): void;

/**
 * `glClearIndex` specifies the index used by {@link glClear} to clear the color index buffers. ***c*** is not clamped. Rather, ***c*** is converted to a fixed-point value with unspecified precision to the right of the binary point. The integer part of this value is then masked with 2ᵐ −1, where 𝐦 is the number of bits in a color index stored in the frame buffer.
 *
 * @summary specify the clear value for the color index buffers
 * @param c Specifies the index used when the color index buffers are cleared. The initial value is 0.
 * @see [glClearIndex](https://docs.gl/gl3/glClearIndex)
 */
export function glClearIndex(c: GLfloat): void;

/**
 * `glClearStencil` specifies the index used by {@link glClear} to clear the stencil buffer. **s** is masked with 2ᵐ − 1, where 𝐦 is the number of bits in the stencil buffer.
 *
 * @summary specify the clear value for the stencil buffer
 * @param s Specifies the index used when the stencil buffer is cleared. The initial value is 0.
 * @see [glClearStencil](https://docs.gl/gl3/glClearStencil)
 */
export function glClearStencil(s: GLint): void;

/**
 * Geometry is always clipped against the boundaries of a six-plane frustum in **x*, **y**, and **z**. `glClipPlane` allows the specification of additional planes, not necessarily perpendicular to the **x**, **y**, or **z** axis, against which all geometry is clipped. To determine the maximum number of additional clipping planes, call {@link glGetIntegerv} with argument {@link GL_MAX_CLIP_PLANES}. All implementations support at least six such clipping planes. Because the resulting clipping region is the intersection of the defined half-spaces, it is always convex.
 * `glClipPlane` specifies a half-space using a four-component plane equation. When `glClipPlane` is called, equation is transformed by the inverse of the modelview matrix and stored in the resulting eye coordinates. Subsequent changes to the modelview matrix have no effect on the stored plane-equation components. If the dot product of the eye coordinates of a vertex with the stored plane equation components is positive or zero, the vertex is **in** with respect to that clipping plane. Otherwise, it is **out**.
 * To enable and disable clipping planes, call {@link glEnable} and {@link glDisable} with the argument {@link GL_CLIP_PLANE} **i**, where **i** is the plane number.
 * All clipping planes are initially defined as (0, 0, 0, 0) in eye coordinates and are disabled.
 *
 * @summary specify a plane against which all geometry is clipped
 * @param plane Specifies which clipping plane is being positioned. Symbolic names of the form {@link GL_CLIP_PLANE} **i**, where **i** is an integer between 0 and {@link GL_MAX_CLIP_PLANES} −1, are accepted.
 * @param equation Specifies the address of an array of four double-precision floating-point values. These values are interpreted as a plane equation.
 * @see [glClipPlane](https://docs.gl/gl3/glClipPlane)
 */
export function glClipPlane(plane: GLenum, equation: GLdouble): void;

/**
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param red Specifies new red value for the current color.
 * @param green Specifies new green value for the current color.
 * @param blue Specifies new blue value for the current color.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor3b(red: GLbyte, green: GLbyte, blue: GLbyte): void;

/**
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param red Specifies new red value for the current color.
 * @param green Specifies new green value for the current color.
 * @param blue Specifies new blue value for the current color.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor3d(red: GLdouble, green: GLdouble, blue: GLdouble): void;

/**
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param red Specifies new red value for the current color.
 * @param green Specifies new green value for the current color.
 * @param blue Specifies new blue value for the current color.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor3f(red: GLfloat, green: GLfloat, blue: GLfloat): void;

/**
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param red Specifies new red value for the current color.
 * @param green Specifies new green value for the current color.
 * @param blue Specifies new blue value for the current color.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor3i(red: GLint, green: GLint, blue: GLint): void;

/**
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param red Specifies new red value for the current color.
 * @param green Specifies new green value for the current color.
 * @param blue Specifies new blue value for the current color.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor3s(red: GLshort, green: GLshort, blue: GLshort): void;

/**
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param red Specifies new red value for the current color.
 * @param green Specifies new green value for the current color.
 * @param blue Specifies new blue value for the current color.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor3ub(red: GLubyte, green: GLubyte, blue: GLubyte): void;

/**
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param red Specifies new red value for the current color.
 * @param green Specifies new green value for the current color.
 * @param blue Specifies new blue value for the current color.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor3us(
	red: GLushort,
	green: GLushort,
	blue: GLushort
): void;

/**
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param red Specifies new red value for the current color.
 * @param green Specifies new green value for the current color.
 * @param blue Specifies new blue value for the current color.
 * @param alpha Specifies new alpha value for the current color.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor4b(
	red: GLbyte,
	green: GLbyte,
	blue: GLbyte,
	alpha: GLbyte
): void;

/**
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param red Specifies new red value for the current color.
 * @param green Specifies new green value for the current color.
 * @param blue Specifies new blue value for the current color.
 * @param alpha Specifies new alpha value for the current color.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor4d(
	red: GLdouble,
	green: GLdouble,
	blue: GLdouble,
	alpha: GLdouble
): void;

/**
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param red Specifies new red value for the current color.
 * @param green Specifies new green value for the current color.
 * @param blue Specifies new blue value for the current color.
 * @param alpha Specifies new alpha value for the current color.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor4f(
	red: GLfloat,
	green: GLfloat,
	blue: GLfloat,
	alpha: GLfloat
): void;

/**
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param red Specifies new red value for the current color.
 * @param green Specifies new green value for the current color.
 * @param blue Specifies new blue value for the current color.
 * @param alpha Specifies new alpha value for the current color.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor4i(
	red: GLint,
	green: GLint,
	blue: GLint,
	alpha: GLint
): void;

/**
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param red Specifies new red value for the current color.
 * @param green Specifies new green value for the current color.
 * @param blue Specifies new blue value for the current color.
 * @param alpha Specifies new alpha value for the current color.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor4s(
	red: GLshort,
	green: GLshort,
	blue: GLshort,
	alpha: GLshort
): void;

/**
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param red Specifies new red value for the current color.
 * @param green Specifies new green value for the current color.
 * @param blue Specifies new blue value for the current color.
 * @param alpha Specifies new alpha value for the current color.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor4ub(
	red: GLubyte,
	green: GLubyte,
	blue: GLubyte,
	alpha: GLubyte
): void;

/**
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param red Specifies new red value for the current color.
 * @param green Specifies new green value for the current color.
 * @param blue Specifies new blue value for the current color.
 * @param alpha Specifies new alpha value for the current color.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor4us(
	red: GLushort,
	green: GLushort,
	blue: GLushort,
	alpha: GLushort
): void;

/**
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param v Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor3bv(v: GLbyte): void;

/**
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param v Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor3dv(v: GLdouble): void;

/**
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param v Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor3fv(v: GLfloat): void;

/**
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param v Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor3iv(v: GLint): void;

/**
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param v Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor3sv(v: GLshort): void;

/**
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param v Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor3ubv(v: GLubyte): void;

/**
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param v Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor3uiv(v: GLuint): void;

/**
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param v Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor3usv(v: GLushort): void;

/**
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param v Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor4bv(v: GLbyte): void;

/**
 * @summary set the current color
 * @param v Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
 *
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor4dv(v: GLdouble): void;

/**
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param v Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor4fv(v: GLfloat): void;

/**
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param v Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor4iv(v: GLint): void;

/**
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param v Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor4sv(v: GLshort): void;

/**
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param v Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor4ubv(v: GLubyte): void;

/**
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param v Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor4uiv(v: GLuint): void;

/**
 * The GL stores both a current single-valued color index and a current four-valued RGBA color. `glColor` sets a new four-valued RGBA color. `glColor` has two major variants: `glColor3` and `glColor4`. `glColor3` variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0 (full intensity) implicitly. `glColor4` variants specify all four color components explicitly.
 *
 * {@link glColor3b}, {@link glColor4b}, {@link glColor3s}, {@link glColor4s}, {@link glColor3i}, and {@link glColor4i} take three or four signed byte, short, or long integers as arguments. When v is appended to the name, the color commands can take a pointer to an array of such values.
 *
 * Current color values are stored in floating-point format, with unspecified mantissa and exponent sizes. Unsigned integer color components, when specified, are linearly mapped to floating-point values such that the largest representable value maps to 1.0 (full intensity), and 0 maps to 0.0 (zero intensity). Signed integer color components, when specified, are linearly mapped to floating-point values such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Floating-point values are mapped directly.
 *
 * Neither floating-point nor signed integer values are clamped to the range [0,1] before the current color is updated. However, color components are clamped to this range before they are interpolated or written into a color buffer.
 *
 * @summary set the current color
 * @param v Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
 * @see [glColor](https://docs.gl/gl3/glColor)
 */
export function glColor4usv(v: GLushort): void;

/**
 * `glColorMask` specify whether the individual color components in the frame buffer can or cannot be written. `glColorMask` sets the mask for all draw buffers. If red is {@link GL_FALSE}, for example, no change is made to the red component of any pixel in any of the color buffers, regardless of the drawing operation attempted.
 *
 * Changes to individual bits of components cannot be controlled. Rather, changes are either enabled or disabled for entire color components.
 *
 * @summary enable and disable writing of frame buffer color components
 * @param red Specifies whether red has to be written into the frame buffer. The initial values is {@link GL_TRUE}, indicating that the color components are written.
 * @param green Specifies whether green has to be written into the frame buffer. The initial values is {@link GL_TRUE}, indicating that the color components are written.
 * @param blue Specifies whether blue has to be written into the frame buffer. The initial values is {@link GL_TRUE}, indicating that the color components are written.
 * @param alpha Specifies whether alpha has to be written into the frame buffer. The initial values is {@link GL_TRUE}, indicating that the color components are written.
 * @see [glColorMask](https://docs.gl/gl3/glColorMask)
 */
export function glColorMask(
	red: GLboolean,
	green: GLboolean,
	blue: GLboolean,
	alpha: GLboolean
): void;

/**
 * `glColorMaski` specify whether the individual color components in the frame buffer can or cannot be written. `glColorMaski` sets the mask for a specific draw buffer. If red is {@link GL_FALSE}, for example, no change is made to the red component of any pixel in any of the color buffers, regardless of the drawing operation attempted.
 *
 * Changes to individual bits of components cannot be controlled. Rather, changes are either enabled or disabled for entire color components.
 *
 * @summary enable and disable writing of frame buffer color components
 * @param buf For `glColorMaski`, specifies the index of the draw buffer whose color mask to set.
 * @param red Specifies whether red has to be written into the frame buffer. The initial values is {@link GL_TRUE}, indicating that the color components are written.
 * @param green Specifies whether green has to be written into the frame buffer. The initial values is {@link GL_TRUE}, indicating that the color components are written.
 * @param blue Specifies whether blue has to be written into the frame buffer. The initial values is {@link GL_TRUE}, indicating that the color components are written.
 * @param alpha Specifies whether alpha has to be written into the frame buffer. The initial values is {@link GL_TRUE}, indicating that the color components are written.
 * @see [glColorMask](https://docs.gl/gl3/glColorMask)
 */
export function glColorMaski(
	buf: GLuint,
	red: GLboolean,
	green: GLboolean,
	blue: GLboolean,
	alpha: GLboolean
): void;

/**
 * `glColorMaterial` specifies which material parameters track the current color. When {@link GL_COLOR_MATERIAL} is enabled, the material parameter or parameters specified by mode, of the material or materials specified by face, track the current color at all times.
 * To enable and disable {@link GL_COLOR_MATERIAL}, call {@link glEnable} and {@link glDisable} with argument {@link GL_COLOR_MATERIAL}. {@link GL_COLOR_MATERIAL} is initially disabled.
 *
 * @summary cause a material color to track the current color
 * @param face Specifies whether front, back, or both front and back material parameters should track the current color. Accepted values are {@link GL_FRONT}, {@link GL_BACK}, and {@link GL_FRONT_AND_BACK}. The initial value is {@link GL_FRONT_AND_BACK}.
 * @param mode Specifies which of several material parameters track the current color. Accepted values are {@link GL_EMISSION}, {@link GL_AMBIENT}, {@link GL_DIFFUSE}, {@link GL_SPECULAR}, and {@link GL_AMBIENT_AND_DIFFUSE}. The initial value is {@link GL_AMBIENT_AND_DIFFUSE}.
 * @see [glColorMaterial](https://docs.gl/gl3/glColorMaterial)
 */
export function glColorMaterial(face: GLenum, mode: GLenum): void;

/**
 * `glColorPointer` specifies the location and data format of an array of color components to use when rendering. size specifies the number of components per color, and must be 3 or 4. type specifies the data type of each color component, and stride specifies the byte stride from one color to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays. (Single-array storage may be more efficient on some implementations; see {@link glInterleavedArrays}.)
 *
 * If a non-zero named buffer object is bound to the {@link GL_ARRAY_BUFFER} target (see {@link glBindBuffer}) while a color array is specified, pointer is treated as a byte offset into the buffer object's data store. Also, the buffer object binding ({@link GL_ARRAY_BUFFER_BINDING}) is saved as color vertex array client-side state ({@link GL_COLOR_ARRAY_BUFFER_BINDING}).
 *
 * When a color array is specified, size, type, stride, and pointer are saved as client-side state, in addition to the current vertex array buffer object binding.
 *
 * To enable and disable the color array, call {@link glEnableClientState} and {@link glDisableClientState} with the argument {@link GL_COLOR_ARRAY}. If enabled, the color array is used when {@link glDrawArrays}, {@link glMultiDrawArrays}, {@link glDrawElements}, {@link glMultiDrawElements}, {@link glDrawRangeElements}, or {@link glArrayElement} is called.
 *
 * @summary define an array of colors
 * @param size Specifies the number of components per color. Must be 3 or 4. The initial value is 4.
 * @param type Specifies the data type of each color component in the array. Symbolic constants {@link GL_BYTE}, {@link GL_UNSIGNED_BYTE}, {@link GL_SHORT}, {@link GL_UNSIGNED_SHORT}, {@link GL_INT}, {@link GL_UNSIGNED_INT}, {@link GL_FLOAT}, and {@link GL_DOUBLE} are accepted. The initial value is {@link GL_FLOAT}.
 * @param stride Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
 * @param pointer Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
 * @tutorial [Songho - OpenGL Vertex Array](https://www.songho.ca/opengl/gl_vertexarray.html)
 *
 * @see [glColorPointer](https://docs.gl/gl3/glColorPointer)
 */
export function glColorPointer(
	size: GLint,
	type: GLenum,
	stride: GLsizei,
	pointer: GLvoid
): void;

/**
 * `glCopyPixels` copies a screen-aligned rectangle of pixels from the specified frame buffer location to a region relative to the current raster position. Its operation is well defined only if the entire pixel source region is within the exposed portion of the window. Results of copies from outside the window, or from regions of the window that are not exposed, are hardware dependent and undefined.
 *
 * x and y specify the window coordinates of the lower left corner of the rectangular region to be copied. width and height specify the dimensions of the rectangular region to be copied. Both width and height must not be negative.
 *
 * Several parameters control the processing of the pixel data while it is being copied. These parameters are set with three commands: {@link glPixelTransfer}, {@link glPixelMap}, and {@link glPixelZoom}. This reference page describes the effects on `glCopyPixels` of most, but not all, of the parameters specified by these three commands.
 *
 * `glCopyPixels` copies values from each pixel with the lower left-hand corner at (𝐱 + 𝐢, 𝐲 + 𝐣) for 0 <= 𝐢 < width and 0 <= 𝐣 < height. This pixel is said to be the 𝐢ᵗʰ pixel in the jᵗʰ row. Pixels are copied in row order from the lowest to the highest row, left to right in each row.
 *
 * **type** specifies whether color, depth, or stencil data is to be copied. The details of the transfer for each data type are as follows:
 *
 * - {@link GL_COLOR}
 *
 * 	Indices or RGBA colors are read from the buffer currently specified as the read source buffer (see {@link glReadBuffer}). If the GL is in color index mode, each index that is read from this buffer is converted to a fixed-point format with an unspecified number of bits to the right of the binary point. Each index is then shifted left by {@link GL_INDEX_SHIFT} bits, and added to {@link GL_INDEX_OFFSET}. If {@link GL_INDEX_SHIFT} is negative, the shift is to the right. In either case, zero bits fill otherwise unspecified bit locations in the result. If {@link GL_MAP_COLOR} is true, the index is replaced with the value that it references in lookup table {@link GL_PIXEL_MAP_I_TO_I}. Whether the lookup replacement of the index is done or not, the integer part of the index is then ANDed with 2ᵇ − 1, where 𝐛 is the number of bits in a color index buffer.
 *
 * 	If the GL is in RGBA mode, the red, green, blue, and alpha components of each pixel that is read are converted to an internal floating-point format with unspecified precision. The conversion maps the largest representable component value to 1.0, and component value 0 to 0.0. The resulting floating-point color values are then multiplied by {@link GL_c_SCALE} and added to {@link GL_c_BIAS}, where ***c*** is RED, GREEN, BLUE, and ALPHA for the respective color components. The results are clamped to the range [0,1]. If {@link GL_MAP_COLOR} is true, each color component is scaled by the size of lookup table {@link GL_PIXEL_MAP_c_TO_c}, then replaced by the value that it references in that table. **c** is R, G, B, or A.
 *
 * 	If the ARB_imaging extension is supported, the color values may be additionally processed by color-table lookups, color-matrix transformations, and convolution filters.
 *
 * 	The GL then converts the resulting indices or RGBA colors to fragments by attaching the current raster position **z** coordinate and texture coordinates to each pixel, then assigning window coordinates (𝐱ᵣ + 𝐢, 𝐲ᵣ + 𝐣), where (𝐱ᵣ, 𝐲ᵣ) is the current raster position, and the pixel was the 𝐢ᵗʰ pixel in the jᵗʰ row. These pixel fragments are then treated just like the fragments generated by rasterizing points, lines, or polygons. Texture mapping, fog, and all the fragment operations are applied before the fragments are written to the frame buffer.
 *
 * - {@link GL_DEPTH}
 *
 * Depth values are read from the depth buffer and converted directly to an internal floating-point format with unspecified precision. The resulting floating-point depth value is then multiplied by {@link GL_DEPTH_SCALE} and added to {@link GL_DEPTH_BIAS}. The result is clamped to the range [0,1].
 *
 * The GL then converts the resulting depth components to fragments by attaching the current raster position color or color index and texture coordinates to each pixel, then assigning window coordinates (𝐱ᵣ + 𝐢, 𝐲ᵣ + 𝐣), where (𝐱ᵣ, 𝐲ᵣ) is the current raster position, and the pixel was the 𝐢ᵗʰ pixel in the jᵗʰ row. These pixel fragments are then treated just like the fragments generated by rasterizing points, lines, or polygons. Texture mapping, fog, and all the fragment operations are applied before the fragments are written to the frame buffer.
 *
 * - {@link GL_STENCIL}
 *
 *  Stencil indices are read from the stencil buffer and converted to an internal fixed-point format with an unspecified number of bits to the right of the binary point. Each fixed-point index is then shifted left by {@link GL_INDEX_SHIFT} bits, and added to {@link GL_INDEX_OFFSET}. If {@link GL_INDEX_SHIFT} is negative, the shift is to the right. In either case, zero bits fill otherwise unspecified bit locations in the result. If {@link GL_MAP_STENCIL} is true, the index is replaced with the value that it references in lookup table {@link GL_PIXEL_MAP_S_TO_S}. Whether the lookup replacement of the index is done or not, the integer part of the index is then ANDed with 2ᵇ − 1, where 𝐛 is the number of bits in the stencil buffer. The resulting stencil indices are then written to the stencil buffer such that the index read from the 𝐢ᵗʰ location of the jᵗʰ row is written to location (𝐱ᵣ + 𝐢, 𝐲ᵣ + 𝐣), where (𝐱ᵣ, 𝐲ᵣ) is the current raster position. Only the pixel ownership test, the scissor test, and the stencil writemask affect these write operations.
 *
 * The rasterization described thus far assumes pixel zoom factors of 1.0. If {@link glPixelZoom} is used to change the 𝐱 and 𝐲 pixel zoom factors, pixels are converted to fragments as follows. If (𝐱ᵣ, 𝐲ᵣ) is the current raster position, and a given pixel is in the 𝐢ᵗʰ location in the jᵗʰ row of the source pixel rectangle, then fragments are generated for pixels whose centers are in the rectangle with corners at
 *
 * (𝐱ᵣ + 𝐳𝐨𝐨𝐦ₓ𝐢, 𝐲ᵣ + 𝐳𝐨𝐨𝐦ᵧ𝐣)
 *
 * and
 *
 * (𝐱ᵣ + 𝐳𝐨𝐨𝐦ₓ(𝐢 + 1), 𝐲ᵣ + 𝐳𝐨𝐨𝐦ᵧ(𝐣 + 1))
 *
 * where 𝐳𝐨𝐨𝐦ₓ is the value of {@link GL_ZOOM_X} and 𝐳𝐨𝐨𝐦ᵧ is the value of {@link GL_ZOOM_Y}.
 *
 * @summary copy pixels in the frame buffer
 * @param x Specifies the window x coordinate of the lower left corner of the rectangular region of pixels to be copied.
 * @param y Specifies the window y coordinate of the lower left corner of the rectangular region of pixels to be copied.
 * @param width Specifies the width of the rectangular region of pixels to be copied. Must be nonnegative.
 * @param height Specifies the height of the rectangular region of pixels to be copied. Must be nonnegative.
 * @param type Specifies whether color values, depth values, or stencil values are to be copied. Symbolic constants {@link GL_COLOR}, {@link GL_DEPTH}, and {@link GL_STENCIL} are accepted.
 * @see [glCopyPixels](https://docs.gl/gl3/glCopyPixels)
 */
export function glCopyPixels(
	x: GLint,
	y: GLint,
	width: GLsizei,
	height: GLsizei,
	type: GLenum
): void;

/**
 * `glCopyTexImage1D` defines a one-dimensional texture image with pixels from the current {@link GL_READ_BUFFER}.
 *
 * The screen-aligned pixel row with left corner at (𝐱, 𝐲) and with a length of **width** defines the texture array at the mipmap level specified by level. internalformat specifies the internal format of the texture array.
 *
 * The pixels in the row are processed exactly as if {@link glReadPixels} had been called, but the process stops just before final conversion. At this point all pixel component values are clamped to the range [0,1] and then converted to the texture's internal format for storage in the texel array.
 *
 * Pixel ordering is such that lower 𝐱 screen coordinates correspond to lower texture coordinates.
 *
 * If any of the pixels within the specified row of the current {@link GL_READ_BUFFER} are outside the window associated with the current rendering context, then the values obtained for those pixels are undefined.
 *
 * `glCopyTexImage1D` defines a one-dimensional texture image with pixels from the current {@link GL_READ_BUFFER}.
 *
 * When internalformat is one of the sRGB types, the GL does not automatically convert the source pixels to the sRGB color space. In this case, the `glPixelMap` function can be used to accomplish the conversion.
 *
 * @summary copy pixels into a 1D texture image
 * @param target Specifies the target texture. Must be {@link GL_TEXTURE_1D}.
 * @param level Specifies the level-of-detail number. Level 0 is the base image level. Level **n** is the **n**ᵗʰ mipmap reduction image.
 * @param internalformat Specifies the internal format of the texture. Must be one of the following symbolic constants: {@link GL_COMPRESSED_RED}, {@link GL_COMPRESSED_RG}, {@link GL_COMPRESSED_RGB}, {@link GL_COMPRESSED_RGBA}. {@link GL_COMPRESSED_SRGB}, {@link GL_COMPRESSED_SRGB_ALPHA}. {@link GL_DEPTH_COMPONENT}, {@link GL_DEPTH_COMPONENT16}, {@link GL_DEPTH_COMPONENT24}, {@link GL_DEPTH_COMPONENT32}, {@link GL_RED}, {@link GL_RG}, {@link GL_RGB}, {@link GL_R3_G3_B2}, {@link GL_RGB4}, {@link GL_RGB5}, {@link GL_RGB8}, {@link GL_RGB10}, {@link GL_RGB12}, {@link GL_RGB16}, {@link GL_RGBA}, {@link GL_RGBA2}, {@link GL_RGBA4}, {@link GL_RGB5_A1}, {@link GL_RGBA8}, {@link GL_RGB10_A2}, {@link GL_RGBA12}, {@link GL_RGBA16}, {@link GL_SRGB}, {@link GL_SRGB8}, {@link GL_SRGB_ALPHA}, or {@link GL_SRGB8_ALPHA8}.
 * @param x Specifies the window x coordinate of the left corner of the row of pixels to be copied.
 * @param y Specifies the window y coordinate of the left corner of the row of pixels to be copied.
 * @param width Specifies the width of the texture image. The height of the texture image is 1.
 * @param border Must be 0.
 * @see [glCopyTexImage1D](https://docs.gl/gl3/glCopyTexImage1D)
 */

export function glCopyTexImage1D(
	target: GLenum,
	level: GLint,
	internalformat: GLenum,
	x: GLint,
	y: GLint,
	width: GLsizei,
	border: GLint
): void;

/**
 * `glCopyTexImage2D` defines a two-dimensional texture image, or cube-map texture image with pixels from the current {@link GL_READ_BUFFER}.
 *
 * The screen-aligned pixel rectangle with lower left corner at (𝐱, 𝐲) and with a width of **width** and a height of **height** defines the texture array at the mipmap level specified by **level**. **internalformat** specifies the internal format of the texture array.
 *
 * The pixels in the rectangle are processed exactly as if {@link glReadPixels} had been called, but the process stops just before final conversion. At this point all pixel component values are clamped to the range [0,1] and then converted to the texture's internal format for storage in the texel array.
 *
 * Pixel ordering is such that lower 𝐱 and 𝐲 screen coordinates correspond to lower 𝐬 and 𝐭 texture coordinates.
 *
 * If any of the pixels within the specified rectangle of the current {@link GL_READ_BUFFER} are outside the window associated with the current rendering context, then the values obtained for those pixels are undefined.
 *
 * When **internalformat** is one of the sRGB types, the GL does not automatically convert the source pixels to the sRGB color space. In this case, the `glPixelMap` function can be used to accomplish the conversion.
 *
 * @summary copy pixels into a 2D texture image
 * @param target Specifies the target texture. Must be {@link GL_TEXTURE_2D}, {@link GL_TEXTURE_CUBE_MAP_POSITIVE_X}, {@link GL_TEXTURE_CUBE_MAP_NEGATIVE_X}, {@link GL_TEXTURE_CUBE_MAP_POSITIVE_Y}, {@link GL_TEXTURE_CUBE_MAP_NEGATIVE_Y}, {@link GL_TEXTURE_CUBE_MAP_POSITIVE_Z}, or {@link GL_TEXTURE_CUBE_MAP_NEGATIVE_Z}.
 * @param level Specifies the level-of-detail number. Level 0 is the base image level. Level **n** is the **n**ᵗʰ mipmap reduction image.
 * @param internalformat Specifies the internal format of the texture. Must be one of the following symbolic constants: {@link GL_COMPRESSED_RED}, {@link GL_COMPRESSED_RG}, {@link GL_COMPRESSED_RGB}, {@link GL_COMPRESSED_RGBA}. {@link GL_COMPRESSED_SRGB}, {@link GL_COMPRESSED_SRGB_ALPHA}. {@link GL_DEPTH_COMPONENT}, {@link GL_DEPTH_COMPONENT16}, {@link GL_DEPTH_COMPONENT24}, {@link GL_DEPTH_COMPONENT32}, {@link GL_RED}, {@link GL_RG}, {@link GL_RGB}, {@link GL_R3_G3_B2}, {@link GL_RGB4}, {@link GL_RGB5}, {@link GL_RGB8}, {@link GL_RGB10}, {@link GL_RGB12}, {@link GL_RGB16}, {@link GL_RGBA}, {@link GL_RGBA2}, {@link GL_RGBA4}, {@link GL_RGB5_A1}, {@link GL_RGBA8}, {@link GL_RGB10_A2}, {@link GL_RGBA12}, {@link GL_RGBA16}, {@link GL_SRGB}, {@link GL_SRGB8}, {@link GL_SRGB_ALPHA}, or {@link GL_SRGB8_ALPHA8}.
 * @param x Specifies the window x coordinate of the lower left corner of the rectangular region of pixels to be copied.
 * @param y Specifies the window y coordinate of the lower left corner of the rectangular region of pixels to be copied.
 * @param width Specifies the width of the texture image.
 * @param height Specifies the height of the texture image.
 * @param border Must be 0.
 * @see [glCopyTexImage2D](https://docs.gl/gl3/glCopyTexImage2D)
 */
export function glCopyTexImage2D(
	target: GLenum,
	level: GLint,
	internalformat: GLenum,
	x: GLint,
	y: GLint,
	width: GLsizei,
	height: GLsizei,
	border: GLint
): void;

/**
 * `glCopyTexSubImage1D` replaces a portion of a one-dimensional texture image with pixels from the current {@link GL_READ_BUFFER} (rather than from main memory, as is the case for {@link glTexSubImage1D}).
 *
 * The screen-aligned pixel row with left corner at (𝐱, 𝐲) x, y), and with length **width** replaces the portion of the texture array with x indices **xoffset** through **xoffset + width - 1**, inclusive. The destination in the texture array may not include any texels outside the texture array as it was originally specified.
 *
 * The pixels in the row are processed exactly as if {@link glReadPixels} had been called, but the process stops just before final conversion. At this point, all pixel component values are clamped to the range [0,1] and then converted to the texture's internal format for storage in the texel array.
 *
 * It is not an error to specify a subtexture with zero width, but such a specification has no effect. If any of the pixels within the specified row of the current {@link GL_READ_BUFFER} are outside the read window associated with the current rendering context, then the values obtained for those pixels are undefined.
 *
 * No change is made to the **internalformat** or **width** parameters of the specified texture array or to texel values outside the specified subregion.
 *
 * @summary copy a one-dimensional texture subimage
 * @param target Specifies the target texture. Must be {@link GL_TEXTURE_1D}.
 * @param level Specifies the level-of-detail number. Level 0 is the base image level. Level **n** is the **n**ᵗʰ mipmap reduction image.
 * @param xoffset Specifies the texel offset within the texture array.
 * @param x Specifies the window x coordinate of the left corner of the row of pixels to be copied.
 * @param y Specifies the window y coordinate of the left corner of the row of pixels to be copied.
 * @param width Specifies the width of the texture subimage.
 * @see [glCopyTexSubImage1D](https://docs.gl/gl3/glCopyTexSubImage1D)
 */
export function glCopyTexSubImage1D(
	target: GLenum,
	level: GLint,
	xoffset: GLint,
	x: GLint,
	y: GLint,
	width: GLsizei
): void;

/**
 * `glCopyTexSubImage2D` replaces a rectangular portion of a two-dimensional texture image or cube-map texture image with pixels from the current {@link GL_READ_BUFFER} (rather than from main memory, as is the case for {@link glTexSubImage2D}).
 *
 * The screen-aligned pixel rectangle with lower left corner at (𝐱, 𝐲) and with width **width** and height **height** replaces the portion of the texture array with x indices **xoffset** through **xoffset + width − 1**, inclusive, and y indices **yoffset** through **yoffset + height − 1**, inclusive, at the mipmap level specified by **level**.
 *
 * The pixels in the rectangle are processed exactly as if {@link glReadPixels} had been called, but the process stops just before final conversion. At this point, all pixel component values are clamped to the range [0,1] and then converted to the texture's internal format for storage in the texel array.
 *
 * The destination rectangle in the texture array may not include any texels outside the texture array as it was originally specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect.
 *
 * If any of the pixels within the specified rectangle of the current {@link GL_READ_BUFFER} are outside the read window associated with the current rendering context, then the values obtained for those pixels are undefined.
 *
 * No change is made to the **internalformat**, **width** or **height** parameters of the specified texture array or to texel values outside the specified subregion.
 *
 *
 * @summary copy a two-dimensional texture subimage
 * @param target Specifies the target texture. Must be {@link GL_TEXTURE_2D}, {@link GL_TEXTURE_CUBE_MAP_POSITIVE_X}, {@link GL_TEXTURE_CUBE_MAP_NEGATIVE_X}, {@link GL_TEXTURE_CUBE_MAP_POSITIVE_Y}, {@link GL_TEXTURE_CUBE_MAP_NEGATIVE_Y}, {@link GL_TEXTURE_CUBE_MAP_POSITIVE_Z}, or {@link GL_TEXTURE_CUBE_MAP_NEGATIVE_Z}.
 * @param level Specifies the level-of-detail number. Level 0 is the base image level. Level **n** is the **n**ᵗʰ mipmap reduction image.
 * @param xoffset Specifies a texel offset in the x direction within the texture array.
 * @param yoffset Specifies a texel offset in the y direction within the texture array.
 * @param x Specifies the window x coordinate of the lower left corner of the rectangular region of pixels to be copied.
 * @param y Specifies the window y coordinate of the lower left corner of the rectangular region of pixels to be copied.
 * @param width Specifies the width of the texture subimage.
 * @param height Specifies the height of the texture subimage.
 * @see [glCopyTexSubImage2D](https://docs.gl/gl3/glCopyTexSubImage2D)
 */
export function glCopyTexSubImage2D(
	target: GLenum,
	level: GLint,
	xoffset: GLint,
	yoffset: GLint,
	x: GLint,
	y: GLint,
	width: GLsizei,
	height: GLsizei
): void;

/**
 * `glCullFace` specifies whether front- or back-facing facets are culled (as specified by **mode**) when facet culling is enabled. Facet culling is initially disabled. To enable and disable facet culling, call the {@link glEnable} and {@link glDisable} commands with the argument {@link GL_CULL_FACE}. Facets include triangles, quadrilaterals, polygons, and rectangles.
 *
 * {@link glFrontFace} specifies which of the clockwise and counterclockwise facets are front-facing and back-facing. See {@link glFrontFace}.
 *
 *
 * @summary specify whether front- or back-facing facets can be culled
 * @param mode Specifies whether front- or back-facing facets are candidates for culling. Symbolic constants {@link GL_FRONT}, {@link GL_BACK}, and {@link GL_FRONT_AND_BACK} are accepted. The initial value is {@link GL_BACK}.
 * @see [glCullFace](https://docs.gl/gl3/glCullFace)
 */
export function glCullFace(mode: GLenum): void;

/**
 * `glDeleteLists` causes a contiguous group of display lists to be deleted. **list** is the name of the first display list to be deleted, and **range** is the number of display lists to delete. All display lists 𝐝 with **list** <= 𝐝 <= **list + range − 1** are deleted.
 *
 * All storage locations allocated to the specified display lists are freed, and the names are available for reuse at a later time. Names within the range that do not have an associated display list are ignored. If **range** is 0, nothing happens.
 *
 * @summary delete a contiguous group of display lists
 * @param list Specifies the integer name of the first display list to delete.
 * @param range Specifies the number of display lists to delete.
 * @see [glDeleteLists](https://docs.gl/gl3/glDeleteLists)
 */
export function glDeleteLists(list: GLuint, range: GLsizei): void;

/**
 * `glDeleteTextures` deletes **n** textures named by the elements of the array **textures**. After a texture is deleted, it has no contents or dimensionality, and its name is free for reuse (for example by {@link glGenTextures}). If a texture that is currently bound is deleted, the binding reverts to 0 (the default texture).
 *
 * `glDeleteTextures` silently ignores 0's and names that do not correspond to existing textures.
 *
 * @summary delete named textures
 * @param n Specifies the number of textures to be deleted.
 * @param textures Specifies an array of textures to be deleted.
 * @see [glDeleteTextures](https://docs.gl/gl3/glDeleteTextures)
 */
export function glDeleteTextures(n: GLsizei, textures: GLuint): void;

/**
 * `glDepthMask` specifies whether the depth buffer is enabled for writing. If **flag** is {@link GL_FALSE}, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled.
 *
 * @summary enable or disable writing into the depth buffer
 * @param flag Specifies whether the depth buffer is enabled for writing. If **flag** is {@link GL_FALSE}, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled.
 * @see [glDepthMask](https://docs.gl/gl3/glDepthMask)
 */
export function glDepthMask(flag: GLboolean): void;

/**
 * After clipping and division by **w**, depth coordinates range from  −1 to 1, corresponding to the near and far clipping planes. `glDepthRange` specifies a linear mapping of the normalized depth coordinates in this range to window depth coordinates. Regardless of the actual depth buffer implementation, window coordinate depth values are treated as though they range from 0 through 1 (like color components). Thus, the values accepted by `glDepthRange` are both clamped to this range before they are accepted.
 *
 * The setting of (0,1) maps the near plane to 0 and the far plane to 1. With this mapping, the depth buffer range is fully utilized.
 *
 * @summary specify mapping of depth values from normalized device coordinates to window coordinates
 * @param nearVal Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.
 * @param farVal Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.
 * @tutorial [Songho - OpenGL Transformation](https://www.songho.ca/opengl/gl_transform.html)
 * @see [glDepthRange](https://docs.gl/gl3/glDepthRange)
 */
export function glDepthRange(nearVal: GLclampd, farVal: GLclampd): void;

/**
 * `glEnable` and {@link glDisable} enable and disable various capabilities. Use {@link glIsEnabled} or {@link glGet} to determine the current setting of any capability. The initial value for each capability with the exception of {@link GL_DITHER} and {@link GL_MULTISAMPLE} is {@link GL_FALSE}. The initial value for {@link GL_DITHER} and {@link GL_MULTISAMPLE} is {@link GL_TRUE}.
 *
 * Both `glEnable` and {@link glDisable} take a single argument, **cap**, which can assume one of the following values:
 *
 * Some of the GL's capabilities are indicated. `glEnablei` and `glDisablei` enable and disable indexed capabilities.
 *
 * - {@link GL_BLEND}
 * If enabled, blend the computed fragment color values with the values in the color buffers. See {@link glBlendFunc}.
 *
 * - {@link GL_CLIP_DISTANCE} **i**
 * If enabled, clip geometry against user-defined half space **i**.
 *
 * - {@link GL_COLOR_LOGIC_OP}
 * If enabled, apply the currently selected logical operation to the computed fragment color and color buffer values. See {@link glLogicOp}.
 *
 * - {@link GL_CULL_FACE}
 * If enabled, cull polygons based on their winding in window coordinates. See {@link glCullFace}.
 *
 * - {@link GL_DEPTH_CLAMP}
 * If enabled, the −w𝑐 ≤ z𝑐 ≤ w𝑐 plane equation is ignored by view volume clipping (effectively, there is no near or far plane clipping). See {@link glDepthRange}.
 *
 * - {@link GL_DEPTH_TEST}
 * If enabled, do depth comparisons and update the depth buffer. Note that even if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if the depth test is disabled. See {@link glDepthFunc} and {@link glDepthRange}.
 *
 * - {@link GL_DITHER}
 * If enabled, dither color components or indices before they are written to the color buffer.
 *
 * - {@link GL_FRAMEBUFFER_SRGB}
 * If enabled and the value of {@link GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING} for the framebuffer attachment corresponding to the destination buffer is {@link GL_SRGB}, the R, G, and B destination color values (after conversion from fixed-point to floating-point) are considered to be encoded for the sRGB color space and hence are linearized prior to their use in blending.
 *
 * - {@link GL_LINE_SMOOTH}
 * If enabled, draw lines with correct filtering. Otherwise, draw aliased lines. See {@link glLineWidth}.
 *
 * - {@link GL_MULTISAMPLE}
 * If enabled, use multiple fragment samples in computing the final color of a pixel. See {@link glSampleCoverage}.
 *
 * - {@link GL_POLYGON_OFFSET_FILL}
 * If enabled, and if the polygon is rendered in {@link GL_FILL} mode, an offset is added to depth values of a polygon's fragments before the depth comparison is performed. See {@link glPolygonOffset}.
 *
 * - {@link GL_POLYGON_OFFSET_LINE}
 * If enabled, and if the polygon is rendered in {@link GL_LINE} mode, an offset is added to depth values of a polygon's fragments before the depth comparison is performed. See {@link glPolygonOffset}.
 *
 * - {@link GL_POLYGON_OFFSET_POINT}
 * If enabled, an offset is added to depth values of a polygon's fragments before the depth comparison is performed, if the polygon is rendered in {@link GL_POINT} mode. See {@link glPolygonOffset}.
 *
 * - {@link GL_POLYGON_SMOOTH}
 * If enabled, draw polygons with proper filtering. Otherwise, draw aliased polygons. For correct antialiased polygons, an alpha buffer is needed and the polygons must be sorted front to back.
 *
 * - {@link GL_PRIMITIVE_RESTART}
 * Enables primitive restarting. If enabled, any one of the draw commands which transfers a set of generic attribute array elements to the GL will restart the primitive when the index of the vertex is equal to the primitive restart index. See {@link glPrimitiveRestartIndex}.
 *
 * - {@link GL_SAMPLE_ALPHA_TO_COVERAGE}
 * If enabled, compute a temporary coverage value where each bit is determined by the alpha value at the corresponding sample location. The temporary coverage value is then ANDed with the fragment coverage value.
 *
 * - {@link GL_SAMPLE_ALPHA_TO_ONE}
 * If enabled, each sample alpha value is replaced by the maximum representable alpha value.
 *
 * - {@link GL_SAMPLE_COVERAGE}
 * If enabled, the fragment's coverage is ANDed with the temporary coverage value. If {@link GL_SAMPLE_COVERAGE_INVERT} is set to {@link GL_TRUE}, invert the coverage value. See {@link glSampleCoverage}.
 *
 * - {@link GL_SCISSOR_TEST}
 * If enabled, discard fragments that are outside the scissor rectangle. See {@link glScissor}.
 *
 * - {@link GL_STENCIL_TEST}
 * If enabled, do stencil testing and update the stencil buffer. See {@link glStencilFunc} and {@link glStencilOp}.
 *
 * - {@link GL_TEXTURE_CUBE_MAP_SEAMLESS}
 * If enabled, modifies the way sampling is performed on cube map textures. See the spec for more information.
 *
 * - {@link GL_PROGRAM_POINT_SIZE}
 * If enabled and a vertex or geometry shader is active, then the derived point size is taken from the (potentially clipped) shader builtin {@link gl_PointSize} and clamped to the implementation-dependent point size range.
 *
 * @summary enable server-side GL capabilities
 * @param cap Specifies a symbolic constant indicating a GL capability.
 * @tutorial [Songho - OpenGL Overview](https://www.songho.ca/opengl/gl_overview.html)
 * @tutorial [open.gl - Transform Feedback](https://open.gl/feedback)
 * @tutorial [opengl-tutorial.org - Tutorial 10 : Transparency](https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-10-transparency/)
 * @see [glEnable](https://docs.gl/gl3/glEnable)
 */
export function glEnable(cap: GLenum): void;

/**
 * {@link glEnable} and `glDisable` enable and disable various capabilities. Use {@link glIsEnabled} or {@link glGet} to determine the current setting of any capability. The initial value for each capability with the exception of {@link GL_DITHER} and {@link GL_MULTISAMPLE} is {@link GL_FALSE}. The initial value for {@link GL_DITHER} and {@link GL_MULTISAMPLE} is {@link GL_TRUE}.
 *
 * Both {@link glEnable} and `glDisable` take a single argument, **cap**, which can assume one of the following values:
 *
 * Some of the GL's capabilities are indicated. `glEnablei` and `glDisablei` enable and disable indexed capabilities.
 *
 * - {@link GL_BLEND}
 * If enabled, blend the computed fragment color values with the values in the color buffers. See {@link glBlendFunc}.
 *
 * - {@link GL_CLIP_DISTANCE} **i**
 * If enabled, clip geometry against user-defined half space **i**.
 *
 * - {@link GL_COLOR_LOGIC_OP}
 * If enabled, apply the currently selected logical operation to the computed fragment color and color buffer values. See {@link glLogicOp}.
 *
 * - {@link GL_CULL_FACE}
 * If enabled, cull polygons based on their winding in window coordinates. See {@link glCullFace}.
 *
 * - {@link GL_DEPTH_CLAMP}
 * If enabled, the −w𝑐 ≤ z𝑐 ≤ w𝑐 plane equation is ignored by view volume clipping (effectively, there is no near or far plane clipping). See {@link glDepthRange}.
 *
 * - {@link GL_DEPTH_TEST}
 * If enabled, do depth comparisons and update the depth buffer. Note that even if the depth buffer exists and the depth mask is non-zero, the depth buffer is not updated if the depth test is disabled. See {@link glDepthFunc} and {@link glDepthRange}.
 *
 * - {@link GL_DITHER}
 * If enabled, dither color components or indices before they are written to the color buffer.
 *
 * - {@link GL_FRAMEBUFFER_SRGB}
 * If enabled and the value of {@link GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING} for the framebuffer attachment corresponding to the destination buffer is {@link GL_SRGB}, the R, G, and B destination color values (after conversion from fixed-point to floating-point) are considered to be encoded for the sRGB color space and hence are linearized prior to their use in blending.
 *
 * - {@link GL_LINE_SMOOTH}
 * If enabled, draw lines with correct filtering. Otherwise, draw aliased lines. See {@link glLineWidth}.
 *
 * - {@link GL_MULTISAMPLE}
 * If enabled, use multiple fragment samples in computing the final color of a pixel. See {@link glSampleCoverage}.
 *
 * - {@link GL_POLYGON_OFFSET_FILL}
 * If enabled, and if the polygon is rendered in {@link GL_FILL} mode, an offset is added to depth values of a polygon's fragments before the depth comparison is performed. See {@link glPolygonOffset}.
 *
 * - {@link GL_POLYGON_OFFSET_LINE}
 * If enabled, and if the polygon is rendered in {@link GL_LINE} mode, an offset is added to depth values of a polygon's fragments before the depth comparison is performed. See {@link glPolygonOffset}.
 *
 * - {@link GL_POLYGON_OFFSET_POINT}
 * If enabled, an offset is added to depth values of a polygon's fragments before the depth comparison is performed, if the polygon is rendered in {@link GL_POINT} mode. See {@link glPolygonOffset}.
 *
 * - {@link GL_POLYGON_SMOOTH}
 * If enabled, draw polygons with proper filtering. Otherwise, draw aliased polygons. For correct antialiased polygons, an alpha buffer is needed and the polygons must be sorted front to back.
 *
 * - {@link GL_PRIMITIVE_RESTART}
 * Enables primitive restarting. If enabled, any one of the draw commands which transfers a set of generic attribute array elements to the GL will restart the primitive when the index of the vertex is equal to the primitive restart index. See {@link glPrimitiveRestartIndex}.
 *
 * - {@link GL_SAMPLE_ALPHA_TO_COVERAGE}
 * If enabled, compute a temporary coverage value where each bit is determined by the alpha value at the corresponding sample location. The temporary coverage value is then ANDed with the fragment coverage value.
 *
 * - {@link GL_SAMPLE_ALPHA_TO_ONE}
 * If enabled, each sample alpha value is replaced by the maximum representable alpha value.
 *
 * - {@link GL_SAMPLE_COVERAGE}
 * If enabled, the fragment's coverage is ANDed with the temporary coverage value. If {@link GL_SAMPLE_COVERAGE_INVERT} is set to {@link GL_TRUE}, invert the coverage value. See {@link glSampleCoverage}.
 *
 * - {@link GL_SCISSOR_TEST}
 * If enabled, discard fragments that are outside the scissor rectangle. See {@link glScissor}.
 *
 * - {@link GL_STENCIL_TEST}
 * If enabled, do stencil testing and update the stencil buffer. See {@link glStencilFunc} and {@link glStencilOp}.
 *
 * - {@link GL_TEXTURE_CUBE_MAP_SEAMLESS}
 * If enabled, modifies the way sampling is performed on cube map textures. See the spec for more information.
 *
 * - {@link GL_PROGRAM_POINT_SIZE}
 * If enabled and a vertex or geometry shader is active, then the derived point size is taken from the (potentially clipped) shader builtin {@link gl_PointSize} and clamped to the implementation-dependent point size range.
 *
 * @summary disable server-side GL capabilities
 * @param cap Specifies a symbolic constant indicating a GL capability.
 * @tutorial [Songho - OpenGL Overview](https://www.songho.ca/opengl/gl_overview.html)
 * @tutorial [open.gl - Transform Feedback](https://open.gl/feedback)
 * @tutorial [opengl-tutorial.org - Tutorial 10 : Transparency](https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-10-transparency/)
 * @see [glDisable](https://docs.gl/gl3/glDisable)
 */
export function glDisable(cap: GLenum): void;

/**
 * `glDrawArrays` specifies multiple geometric primitives with very few subroutine calls. Instead of calling a GL procedure to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals, and colors and use them to construct a sequence of primitives with a single call to `glDrawArrays`.
 *
 * When `glDrawArrays` is called, it uses **count** sequential elements from each enabled array to construct a sequence of geometric primitives, beginning with element **first**. **mode** specifies what kind of primitives are constructed and how the array elements construct those primitives.
 *
 * Vertex attributes that are modified by `glDrawArrays` have an unspecified value after `glDrawArrays` returns. Attributes that aren't modified remain well defined.
 *
 * @summary render primitives from array data
 * @param mode Specifies what kind of primitives to render. Symbolic constants {@link GL_POINTS}, {@link GL_LINE_STRIP}, {@link GL_LINE_LOOP}, {@link GL_LINES}, {@link GL_LINE_STRIP_ADJACENCY}, {@link GL_LINES_ADJACENCY}, {@link GL_TRIANGLE_STRIP}, {@link GL_TRIANGLE_FAN}, {@link GL_TRIANGLES}, {@link GL_TRIANGLE_STRIP_ADJACENCY} and {@link GL_TRIANGLES_ADJACENCY} are accepted.
 * @param first Specifies the starting index in the enabled arrays.
 * @param count Specifies the number of indices to be rendered.
 * @example Render a vertex array (not loaded into OpenGL) using texture UV, color, and normal vertex attributes.
 * ```
 * glEnableVertexAttribArray(texcoord_attrib_index); // Attribute indexes were received from calls to glGetAttribLocation, or passed into glBindAttribLocation.
 * glEnableVertexAttribArray(normal_attrib_index);
 * glEnableVertexAttribArray(color_attrib_index);
 * glEnableVertexAttribArray(position_attrib_index);
 *
 * glVertexAttribPointer(texcoord_attrib_index, 2, GL_FLOAT, false, 0, texcoords_data); // texcoords_data is a float*, 2 per vertex, representing UV coordinates.
 * glVertexAttribPointer(normal_attrib_index, 3, GL_FLOAT, false, 0, normals_data); // normals_data is a float*, 3 per vertex, representing normal vectors.
 * glVertexAttribPointer(color_attrib_index, 3, GL_UNSIGNED_BYTE, true, sizeof(unsigned char)*3, colors_data); // colors_data is a unsigned char*, 3 per vertex, representing the color of each vertex.
 * glVertexAttribPointer(position_attrib_index, 3, GL_FLOAT, false, 0, vertex_data); // vertex_data is a float*, 3 per vertex, representing the position of each vertex
 *
 * glDrawArrays(GL_TRIANGLES, 0, vertex_count); // vertex_count is an integer containing the number of indices to be rendered
 *
 * glDisableVertexAttribArray(position_attrib_index);
 * glDisableVertexAttribArray(texcoord_attrib_index);
 * glDisableVertexAttribArray(normal_attrib_index);
 * glDisableVertexAttribArray(color_attrib_index);
 * ```
 * @tutorial [Songho - OpenGL Vertex Array](https://www.songho.ca/opengl/gl_vertexarray.html)
 * @tutorial [open.gl - Depth and Stencil Buffers](https://open.gl/depthstencils)
 * @tutorial [open.gl - Geometry Shaders](https://open.gl/geometry)
 * @tutorial [open.gl - The Graphics Pipeline](https://open.gl/drawing)
 * @tutorial [open.gl - Transform Feedback](https://open.gl/feedback)
 * @tutorial [opengl-tutorial.org - Tutorial 2 : The first triangle](https://www.opengl-tutorial.org/beginners-tutorials/tutorial-2-the-first-triangle/)
 * @tutorial [opengl-tutorial.org - Tutorial 4 : A Colored Cube](https://www.opengl-tutorial.org/beginners-tutorials/tutorial-4-a-colored-cube/)
 * @see [glDrawArrays](https://docs.gl/gl3/glDrawArrays)
 */
export function glDrawArrays(mode: GLenum, first: GLint, count: GLsizei): void;

/**
 * When colors are written to the frame buffer, they are written into the color buffers specified by `glDrawBuffer`. The specifications are as follows:
 *
 * - {@link GL_NONE}
 * No color buffers are written.
 *
 * - {@link GL_FRONT_LEFT}
 * Only the front left color buffer is written.
 *
 * - {@link GL_FRONT_RIGHT}
 * Only the front right color buffer is written.
 *
 * - {@link GL_BACK_LEFT}
 * Only the back left color buffer is written.
 *
 * - {@link GL_BACK_RIGHT}
 * Only the back right color buffer is written.
 *
 * - {@link GL_FRONT}
 * Only the front left and front right color buffers are written. If there is no front right color buffer, only the front left color buffer is written.
 *
 * - {@link GL_BACK}
 * Only the back left and back right color buffers are written. If there is no back right color buffer, only the back left color buffer is written.
 *
 * - {@link GL_LEFT}
 * Only the front left and back left color buffers are written. If there is no back left color buffer, only the front left color buffer is written.
 *
 * - {@link GL_RIGHT}
 * Only the front right and back right color buffers are written. If there is no back right color buffer, only the front right color buffer is written.
 *
 * - {@link GL_FRONT_AND_BACK}
 * All the front and back color buffers (front left, front right, back left, back right) are written. If there are no back color buffers, only the front left and front right color buffers are written. If there are no right color buffers, only the front left and back left color buffers are written. If there are no right or back color buffers, only the front left color buffer is written.
 *
 * If more than one color buffer is selected for drawing, then blending or logical operations are computed and applied independently for each color buffer and can produce different results in each buffer.
 *
 * Monoscopic contexts include only **left** buffers, and stereoscopic contexts include both **left** and **right** buffers. Likewise, single-buffered contexts include only **front** buffers, and double-buffered contexts include both **front** and **back** buffers. The context is selected at GL initialization.
 *
 * @summary specify which color buffers are to be drawn into
 * @param mode Specifies up to four color buffers to be drawn into. Symbolic constants {@link GL_NONE}, {@link GL_FRONT_LEFT}, {@link GL_FRONT_RIGHT}, {@link GL_BACK_LEFT}, {@link GL_BACK_RIGHT}, {@link GL_FRONT}, {@link GL_BACK}, {@link GL_LEFT}, {@link GL_RIGHT}, and {@link GL_FRONT_AND_BACK} are accepted. The initial value is {@link GL_FRONT} for single-buffered contexts, and {@link GL_BACK} for double-buffered contexts.
 * @see [glDrawBuffer](https://docs.gl/gl3/glDrawBuffer)
 */
export function glDrawBuffer(mode: GLenum): void;

/**
 * `glDrawElements` specifies multiple geometric primitives with very few subroutine calls. Instead of calling a GL function to pass each individual vertex, normal, texture coordinate, edge flag, or color, you can prespecify separate arrays of vertices, normals, and so on, and use them to construct a sequence of primitives with a single call to `glDrawElements`.
 *
 * When `glDrawElements` is called, it uses **count** sequential elements from an enabled array, starting at **indices** to construct a sequence of geometric primitives. **mode** specifies what kind of primitives are constructed and how the array elements construct these primitives. If more than one array is enabled, each is used.
 *
 * Vertex attributes that are modified by `glDrawElements` have an unspecified value after `glDrawElements` returns. Attributes that aren't modified maintain their previous values.
 *
 * @summary render primitives from array data
 * @param mode Specifies what kind of primitives to render. Symbolic constants {@link GL_POINTS}, {@link GL_LINE_STRIP}, {@link GL_LINE_LOOP}, {@link GL_LINES}, {@link GL_LINE_STRIP_ADJACENCY}, {@link GL_LINES_ADJACENCY}, {@link GL_TRIANGLE_STRIP}, {@link GL_TRIANGLE_FAN}, {@link GL_TRIANGLES}, {@link GL_TRIANGLE_STRIP_ADJACENCY} and {@link GL_TRIANGLES_ADJACENCY} are accepted.
 * @param count Specifies the number of elements to be rendered.
 * @param type Specifies the type of the values in **indices**. Must be one of {@link GL_UNSIGNED_BYTE}, {@link GL_UNSIGNED_SHORT}, or {@link GL_UNSIGNED_INT}.
 * @param indices Specifies an offset of the first index in the array in the data store of the buffer currently bound to the GL_ELEMENT_ARRAY_BUFFER target.
 * @tutorial [Learning Modern 3D Graphics Programming - Chapter 5. Objects in Depth [Vertex Array Objects, Indexed Drawing]](https://web.archive.org/web/20150225192608/http://www.arcsynthesis.org/gltut/Positioning/Tutorial%2005.html)
 * @tutorial [Songho - OpenGL Display List](https://www.songho.ca/opengl/gl_displaylist.html)
 * @tutorial [Songho - OpenGL Vertex Array](https://www.songho.ca/opengl/gl_vertexarray.html)
 * @tutorial [Songho - OpenGL Vertex Buffer Object (VBO)](https://www.songho.ca/opengl/gl_vbo.html)
 * @tutorial [open.gl - The Graphics Pipeline](https://open.gl/drawing)
 * @tutorial [opengl-tutorial.org - Tutorial 13 : Normal Mapping](https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-13-normal-mapping/)
 * @see [glDrawElements](https://docs.gl/gl3/glDrawElements)
 */
export function glDrawElements(
	mode: GLenum,
	count: GLsizei,
	type: GLenum,
	indices: GLvoid
): void;

/**
 * `glDrawPixels` reads pixel data from memory and writes it into the frame buffer relative to the current raster position, provided that the raster position is valid. Use {@link glRasterPos} or {@link glWindowPos} to set the current raster position; use {@link glGet} with argument {@link GL_CURRENT_RASTER_POSITION_VALID} to determine if the specified raster position is valid, and {@link glGet} with argument {@link GL_CURRENT_RASTER_POSITION} to query the raster position.
 *
 * Several parameters define the encoding of pixel data in memory and control the processing of the pixel data before it is placed in the frame buffer. These parameters are set with four commands: {@link glPixelStore}, {@link glPixelTransfer}, {@link glPixelMap}, and {@link glPixelZoom}. This reference page describes the effects on `glDrawPixels` of many, but not all, of the parameters specified by these four commands.
 *
 * Data is read from **data** as a sequence of signed or unsigned bytes, signed or unsigned shorts, signed or unsigned integers, or single-precision floating-point values, depending on **type**. When **type** is one of {@link GL_UNSIGNED_BYTE}, {@link GL_BYTE}, {@link GL_UNSIGNED_SHORT}, {@link GL_SHORT}, {@link GL_UNSIGNED_INT}, {@link GL_INT}, or {@link GL_FLOAT} each of these bytes, shorts, integers, or floating-point values is interpreted as one color or depth component, or one index, depending on **format**. When **type** is one of {@link GL_UNSIGNED_BYTE_3_3_2}, {@link GL_UNSIGNED_SHORT_5_6_5}, {@link GL_UNSIGNED_SHORT_4_4_4_4}, {@link GL_UNSIGNED_SHORT_5_5_5_1}, {@link GL_UNSIGNED_INT_8_8_8_8}, or {@link GL_UNSIGNED_INT_10_10_10_2}, each unsigned value is interpreted as containing all the components for a single pixel, with the color components arranged according to **format**. When **type** is one of {@link GL_UNSIGNED_BYTE_2_3_3_REV}, {@link GL_UNSIGNED_SHORT_5_6_5_REV}, {@link GL_UNSIGNED_SHORT_4_4_4_4_REV}, {@link GL_UNSIGNED_SHORT_1_5_5_5_REV}, {@link GL_UNSIGNED_INT_8_8_8_8_REV}, or {@link GL_UNSIGNED_INT_2_10_10_10_REV}, each unsigned value is interpreted as containing all color components, specified by **format**, for a single pixel in a reversed order. Indices are always treated individually. Color components are treated as groups of one, two, three, or four values, again based on **format**. Both individual indices and groups of components are referred to as pixels. If **type** is {@link GL_BITMAP}, the data must be unsigned bytes, and **format** must be either {@link GL_COLOR_INDEX} or {@link GL_STENCIL_INDEX}. Each unsigned byte is treated as eight 1-bit pixels, with bit ordering determined by {@link GL_UNPACK_LSB_FIRST} (see {@link glPixelStore}).
 *
 * **width** × **height** pixels are read from memory, starting at location **data**. By default, these pixels are taken from adjacent memory locations, except that after all **width** pixels are read, the read pointer is advanced to the next four-byte boundary. The four-byte row alignment is specified by {@link glPixelStore} with argument {@link GL_UNPACK_ALIGNMENT}, and it can be set to one, two, four, or eight bytes. Other pixel store parameters specify different read pointer advancements, both before the first pixel is read and after all **width** pixels are read. See the {@link glPixelStore} reference page for details on these options.
 *
 * If a non-zero named buffer object is bound to the {@link GL_PIXEL_UNPACK_BUFFER} target (see {@link glBindBuffer}) while a block of pixels is specified, **data** is treated as a byte offset into the buffer object's data store.
 *
 * The **width** × **height** pixels that are read from memory are each operated on in the same way, based on the values of several parameters specified by {@link glPixelTransfer} and {@link glPixelMap}. The details of these operations, as well as the target buffer into which the pixels are drawn, are specific to the format of the pixels, as specified by **format**. **format** can assume one of 13 symbolic values:
 *
 * - {@link GL_COLOR_INDEX}
 *
 * Each pixel is a single value, a color index. It is converted to fixed-point format, with an unspecified number of bits to the right of the binary point, regardless of the memory data type. Floating-point values convert to true fixed-point values. Signed and unsigned integer data is converted with all fraction bits set to 0. Bitmap data convert to either 0 or 1.
 *
 * Each fixed-point index is then shifted left by {@link GL_INDEX_SHIFT} bits and added to {@link GL_INDEX_OFFSET}. If {@link GL_INDEX_SHIFT} is negative, the shift is to the right. In either case, zero bits fill otherwise unspecified bit locations in the result.
 *
 * If the GL is in RGBA mode, the resulting index is converted to an RGBA pixel with the help of the {@link GL_PIXEL_MAP_I_TO_R}, {@link GL_PIXEL_MAP_I_TO_G}, {@link GL_PIXEL_MAP_I_TO_B}, and {@link GL_PIXEL_MAP_I_TO_A} tables. If the GL is in color index mode, and if {@link GL_MAP_COLOR} is true, the index is replaced with the value that it references in lookup table {@link GL_PIXEL_MAP_I_TO_I}. Whether the lookup replacement of the index is done or not, the integer part of the index is then ANDed with 2ᵇ − 1, where 𝐛 is the number of bits in a color index buffer.
 *
 * The GL then converts the resulting indices or RGBA colors to fragments by attaching the current raster position **z** coordinate and texture coordinates to each pixel, then assigning 𝐱 and 𝐲 window coordinates to the 𝐧ᵗʰ fragment such that
 *
 * x𝑛 = x𝑟 + 𝐧 % width
 *
 * y𝑛 = y𝑟 + ⌊𝐧 / width⌋
 *
 * where (x𝑟, y𝑟) is the current raster position. These pixel fragments are then treated just like the fragments generated by rasterizing points, lines, or polygons. Texture mapping, fog, and all the fragment operations are applied before the fragments are written to the frame buffer.
 *
 * - {@link GL_STENCIL_INDEX}
 *
 * Each pixel is a single value, a stencil index. It is converted to fixed-point format, with an unspecified number of bits to the right of the binary point, regardless of the memory data type. Floating-point values convert to true fixed-point values. Signed and unsigned integer data is converted with all fraction bits set to 0. Bitmap data convert to either 0 or 1.
 *
 * Each fixed-point index is then shifted left by {@link GL_INDEX_SHIFT} bits, and added to {@link GL_INDEX_OFFSET}. If {@link GL_INDEX_SHIFT} is negative, the shift is to the right. In either case, zero bits fill otherwise unspecified bit locations in the result. If {@link GL_MAP_STENCIL} is true, the index is replaced with the value that it references in lookup table {@link GL_PIXEL_MAP_S_TO_S}. Whether the lookup replacement of the index is done or not, the integer part of the index is then ANDed with 2ᵇ − 1, where 𝐛 is the number of bits in the stencil buffer. The resulting stencil indices are then written to the stencil buffer such that the 𝐧ᵗʰ index is written to location
 *
 * x𝑛 = x𝑟 + 𝐧 % width
 *
 * y𝑛 = y𝑟 + ⌊𝐧 / width⌋
 *
 * where (x𝑟, y𝑟) is the current raster position. Only the pixel ownership test, the scissor test, and the stencil writemask affect these write operations.
 *
 * - {@link GL_DEPTH_COMPONENT}
 *
 * Each pixel is a single-depth component. Floating-point data is converted directly to an internal floating-point format with unspecified precision. Signed integer data is mapped linearly to the internal floating-point format such that the most positive representable integer value maps to 1.0, and the most negative representable value maps to −1.0. Unsigned integer data is mapped similarly: the largest integer value maps to 1.0, and 0 maps to 0.0. The resulting floating-point depth value is then multiplied by {@link GL_DEPTH_SCALE} and added to {@link GL_DEPTH_BIAS}. The result is clamped to the range [0,1].
 *
 * The GL then converts the resulting depth components to fragments by attaching the current raster position color or color index and texture coordinates to each pixel, then assigning x and y window coordinates to the 𝐧ᵗʰ fragment such that
 *
 * x𝑛 = x𝑟 + 𝐧 % width
 *
 * y𝑛 = y𝑟 + ⌊𝐧 / width⌋
 *
 * where (x𝑟, y𝑟) is the current raster position. These pixel fragments are then treated just like the fragments generated by rasterizing points, lines, or polygons. Texture mapping, fog, and all the fragment operations are applied before the fragments are written to the frame buffer.
 *
 * - {@link GL_RGBA}
 * - {@link GL_BGRA}
 *
 * Each pixel is a four-component group: For {@link GL_RGBA}, the red component is first, followed by green, followed by blue, followed by alpha; for {@link GL_BGRA} the order is blue, green, red and then alpha. Floating-point values are converted directly to an internal floating-point format with unspecified precision. Signed integer values are mapped linearly to the internal floating-point format such that the most positive representable integer value maps to 1.0, and the most negative representable value maps to −1.0. (Note that this mapping does not convert 0 precisely to 0.0.) Unsigned integer data is mapped similarly: The largest integer value maps to 1.0, and 0 maps to 0.0. The resulting floating-point color values are then multiplied by {@link GL_c_SCALE} and added to {@link GL_c_BIAS}, where **c** is RED, GREEN, BLUE, and ALPHA for the respective color components. The results are clamped to the range [0,1].
 *
 * If {@link GL_MAP_COLOR} is true, each color component is scaled by the size of lookup table {@link GL_PIXEL_MAP_c_TO_c}, then replaced by the value that it references in that table. **c** is R, G, B, or A respectively.
 *
 * The GL then converts the resulting RGBA colors to fragments by attaching the current raster position **z** coordinate and texture coordinates to each pixel, then assigning x and y window coordinates to the 𝐧ᵗʰ fragment such that
 *
 * x𝑛 = x𝑟 + 𝐧 % width
 *
 * y𝑛 = y𝑟 + ⌊𝐧 / width⌋
 *
 * where (x𝑟, y𝑟) is the current raster position. These pixel fragments are then treated just like the fragments generated by rasterizing points, lines, or polygons. Texture mapping, fog, and all the fragment operations are applied before the fragments are written to the frame buffer.
 *
 * - {@link GL_RED}
 *      Each pixel is a single red component. This component is converted to the internal floating-point format in the same way the red component of an RGBA pixel is. It is then converted to an RGBA pixel with green and blue set to 0, and alpha set to 1. After this conversion, the pixel is treated as if it had been read as an RGBA pixel.
 *
 * - {@link GL_GREEN}
 *      Each pixel is a single green component. This component is converted to the internal floating-point format in the same way the green component of an RGBA pixel is. It is then converted to an RGBA pixel with red and blue set to 0, and alpha set to 1. After this conversion, the pixel is treated as if it had been read as an RGBA pixel.
 *
 * - {@link GL_BLUE}
 *       Each pixel is a single blue component. This component is converted to the internal floating-point format in the same way the blue component of an RGBA pixel is. It is then converted to an RGBA pixel with red and green set to 0, and alpha set to 1. After this conversion, the pixel is treated as if it had been read as an RGBA pixel.
 *
 * {@link GL_ALPHA}
 *      Each pixel is a three-component group: red first, followed by green, followed by blue; for {@link GL_BGR}, the first component is blue, followed by green and then red. Each component is converted to the internal floating-point format in the same way the red, green, and blue components of an RGBA pixel are. The color triple is converted to an RGBA pixel with alpha set to 1. After this conversion, the pixel is treated as if it had been read as an RGBA pixel.
 *
 * - {@link GL_LUMINANCE}
 *      Each pixel is a single luminance component. This component is converted to the internal floating-point format in the same way the red component of an RGBA pixel is. It is then converted to an RGBA pixel with red, green, and blue set to the converted luminance value, and alpha set to 1. After this conversion, the pixel is treated as if it had been read as an RGBA pixel.
 *
 * - {@link GL_LUMINANCE_ALPHA}
 *      Each pixel is a two-component group: luminance first, followed by alpha. The two components are converted to the internal floating-point format in the same way the red component of an RGBA pixel is. They are then converted to an RGBA pixel with red, green, and blue set to the converted luminance value, and alpha set to the converted alpha value. After this conversion, the pixel is treated as if it had been read as an RGBA pixel.
 *
 *
 *  The following table summarizes the meaning of the valid constants for the **type** parameter:
 *
 * | **Type**                              | **Corresponding Type**                                   |
 * | :------------------------------------ | :------------------------------------------------------- |
 * | {@link GL_UNSIGNED_BYTE}              | unsigned 8-bit integer                                   |
 * | {@link GL_BYTE}                       | signed 8-bit integer                                     |
 * | {@link GL_BITMAP}                     | single bits in unsigned 8-bit integers                   |
 * | {@link GL_UNSIGNED_SHORT}             | unsigned 16-bit integer                                  |
 * | {@link GL_SHORT}                      | signed 16-bit integer                                    |
 * | {@link GL_UNSIGNED_INT}               | unsigned 32-bit integer                                  |
 * | {@link GL_INT}                        | 32-bit integer                                           |
 * | {@link GL_FLOAT}                      | single-precision floating-point                          |
 * | {@link GL_UNSIGNED_BYTE_3_3_2}        | unsigned 8-bit integer                                   |
 * | {@link GL_UNSIGNED_BYTE_2_3_3_REV}    | unsigned 8-bit integer with reversed component ordering  |
 * | {@link GL_UNSIGNED_SHORT_5_6_5}       | unsigned 16-bit integer                                  |
 * | {@link GL_UNSIGNED_SHORT_5_6_5_REV}   | unsigned 16-bit integer with reversed component ordering |
 * | {@link GL_UNSIGNED_SHORT_4_4_4_4}     | unsigned 16-bit integer                                  |
 * | {@link GL_UNSIGNED_SHORT_4_4_4_4_REV} | unsigned 16-bit integer with reversed component ordering |
 * | {@link GL_UNSIGNED_SHORT_5_5_5_1}     | unsigned 16-bit integer                                  |
 * | {@link GL_UNSIGNED_SHORT_1_5_5_5_REV} | unsigned 16-bit integer with reversed component ordering |
 * | {@link GL_UNSIGNED_INT_8_8_8_8}       | unsigned 32-bit integer                                  |
 * | {@link GL_UNSIGNED_INT_8_8_8_8_REV}   | unsigned 32-bit integer with reversed component ordering |
 * | {@link GL_UNSIGNED_INT_10_10_10_2}    | unsigned 32-bit integer                                  |
 * | {@link GL_UNSIGNED_INT_2_10_10_10_REV}| unsigned 32-bit integer with reversed component ordering |
 *
 * The rasterization described so far assumes pixel zoom factors of 1. If {@link glPixelZoom} is used to change the x and y pixel zoom factors, pixels are converted to fragments as follows. If (x𝑟, y𝑟) is the current raster position, and a given pixel is in the 𝐧ᵗʰ column and 𝐦ᵗʰ row of the pixel rectangle, then fragments are generated for pixels whose centers are in the rectangle with corners at
 *
 * (x𝑟 + zoomₓ𝐧, y𝑟 + zoomᵧ𝐦)
 *
 * (x𝑟 + zoomₓ(𝐧 + 1), y𝑟 + zoomᵧ(𝐦 + 1))
 *
 * where zoomₓ is the value of {@link GL_ZOOM_X} and zoomy is the value of {@link GL_ZOOM_Y}.
 *
 * @summary write a block of pixels to the frame buffer
 * @param width Specifies the width of the pixel rectangle to be written into the frame buffer..
 * @param height Specifies the height of the pixel rectangle to be written into the frame buffer.
 * @param format Specifies the format of the pixel data. Symbolic constants {@link GL_COLOR_INDEX}, {@link GL_STENCIL_INDEX}, {@link GL_DEPTH_COMPONENT}, {@link GL_RGB}, {@link GL_BGR}, {@link GL_RGBA}, {@link GL_BGRA}, {@link GL_RED}, {@link GL_GREEN}, {@link GL_BLUE}, {@link GL_ALPHA}, {@link GL_LUMINANCE}, and {@link GL_LUMINANCE_ALPHA} are accepted.
 * @param type Specifies the data type for **data**. Symbolic constants {@link GL_UNSIGNED_BYTE}, {@link GL_BYTE}, {@link GL_BITMAP}, {@link GL_UNSIGNED_SHORT}, {@link GL_SHORT}, {@link GL_UNSIGNED_INT}, {@link GL_INT}, {@link GL_FLOAT}, {@link GL_UNSIGNED_BYTE_3_3_2}, {@link GL_UNSIGNED_BYTE_2_3_3_REV}, {@link GL_UNSIGNED_SHORT_5_6_5}, {@link GL_UNSIGNED_SHORT_5_6_5_REV}, {@link GL_UNSIGNED_SHORT_4_4_4_4}, {@link GL_UNSIGNED_SHORT_4_4_4_4_REV}, {@link GL_UNSIGNED_SHORT_5_5_5_1}, {@link GL_UNSIGNED_SHORT_1_5_5_5_REV}, {@link GL_UNSIGNED_INT_8_8_8_8}, {@link GL_UNSIGNED_INT_8_8_8_8_REV}, {@link GL_UNSIGNED_INT_10_10_10_2}, and {@link GL_UNSIGNED_INT_2_10_10_10_REV} are accepted.
 * @param data Specifies a pointer to the pixel data.
 * @see [glDrawPixels](https://docs.gl/gl3/glDrawPixels)
 */
export function glDrawPixels(
	width: GLsizei,
	height: GLsizei,
	format: GLenum,
	type: GLenum,
	data: GLvoid
): void;

/**
 * Each vertex of a polygon, separate triangle, or separate quadrilateral specified between a {@link glBegin}/{@link glEnd} pair is marked as the start of either a boundary or nonboundary edge. If the current edge flag is true when the vertex is specified, the vertex is marked as the start of a boundary edge. Otherwise, the vertex is marked as the start of a nonboundary edge. `glEdgeFlag` sets the edge flag bit to {@link GL_TRUE} if **flag** is {@link GL_TRUE} and to {@link GL_FALSE} otherwise.
 *
 * The vertices of connected triangles and connected quadrilaterals are always marked as boundary, regardless of the value of the edge flag.
 *
 * Boundary and nonboundary edge flags on vertices are significant only if {@link GL_POLYGON_MODE} is set to {@link GL_POINT} or {@link GL_LINE}. See {@link glPolygonMode}.
 *
 * @summary flag edges as either boundary or nonboundary
 * @param flag Specifies the current edge flag value, either {@link GL_TRUE} or {@link GL_FALSE}. The initial value is {@link GL_TRUE}.
 * @see [glEdgeFlag](https://docs.gl/gl3/glEdgeFlag)
 */
export function glEdgeFlag(flag: GLboolean): void;

/**
 * Each vertex of a polygon, separate triangle, or separate quadrilateral specified between a {@link glBegin}/{@link glEnd} pair is marked as the start of either a boundary or nonboundary edge. If the current edge flag is true when the vertex is specified, the vertex is marked as the start of a boundary edge. Otherwise, the vertex is marked as the start of a nonboundary edge. `glEdgeFlag` sets the edge flag bit to {@link GL_TRUE} if **flag** is {@link GL_TRUE} and to {@link GL_FALSE} otherwise.
 *
 * The vertices of connected triangles and connected quadrilaterals are always marked as boundary, regardless of the value of the edge flag.
 *
 * Boundary and nonboundary edge flags on vertices are significant only if {@link GL_POLYGON_MODE} is set to {@link GL_POINT} or {@link GL_LINE}. See {@link glPolygonMode}.
 *
 * @summary flag edges as either boundary or nonboundary
 * @param flag Specifies the current edge flag value, either {@link GL_TRUE} or {@link GL_FALSE}. The initial value is {@link GL_TRUE}.
 * @see [glEdgeFlag](https://docs.gl/gl3/glEdgeFlag)
 */
export function glEdgeFlagv(flag: GLboolean): void;

/**
 * `glEdgeFlagPointer` specifies the location and data format of an array of boolean edge flags to use when rendering. **stride** specifies the byte stride from one edge flag to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays.
 *
 * If a non-zero named buffer object is bound to the {@link GL_ARRAY_BUFFER} target (see {@link glBindBuffer}) while an edge flag array is specified, **pointer** is treated as a byte offset into the buffer object's data store. Also, the buffer object binding ({@link GL_ARRAY_BUFFER_BINDING}) is saved as edge flag vertex array client-side state ({@link GL_EDGE_FLAG_ARRAY_BUFFER_BINDING}).
 *
 * When an edge flag array is specified, **stride** and **pointer** are saved as client-side state, in addition to the current vertex array buffer object binding.
 *
 * To enable and disable the edge flag array, call {@link glEnableClientState} and {@link glDisableClientState} with the argument {@link GL_EDGE_FLAG_ARRAY}. If enabled, the edge flag array is used when {@link glDrawArrays}, {@link glMultiDrawArrays}, {@link glDrawElements}, {@link glMultiDrawElements}, {@link glDrawRangeElements}, or {@link glArrayElement} is called.
 *
 * @summary define an array of edge flags
 * @param stride Specifies the byte offset between consecutive edge flags. If **stride** is 0, the edge flags are understood to be tightly packed in the array. The initial value is 0.
 * @param pointer Specifies a pointer to the first edge flag in the array. The initial value is 0.
 * @see [glEdgeFlagPointer](https://docs.gl/gl3/glEdgeFlagPointer)
 */
export function glEdgeFlagPointer(stride: GLsizei, pointer: GLvoid): void;

/**
 * `glEnableClientState` and {@link glDisableClientState} enable or disable individual client-side capabilities. By default, all client-side capabilities are disabled. Both `glEnableClientState` and {@link glDisableClientState} take a single argument, **cap**, which can assume one of the following values:
 *
 * - {@link GL_COLOR_ARRAY}
 *     If enabled, the color array is enabled for writing and used during rendering when {@link glArrayElement}, {@link glDrawArrays}, {@link glDrawElements}, {@link glDrawRangeElements} {@link glMultiDrawArrays}, or {@link glMultiDrawElements} is called. See {@link glColorPointer}.
 *
 * - {@link GL_EDGE_FLAG_ARRAY}
 *     If enabled, the edge flag array is enabled for writing and used during rendering when {@link glArrayElement}, {@link glDrawArrays}, {@link glDrawElements}, {@link glDrawRangeElements} {@link glMultiDrawArrays}, or {@link glMultiDrawElements} is called. See {@link glEdgeFlagPointer}.
 *
 * - {@link GL_FOG_COORD_ARRAY}
 *     If enabled, the fog coordinate array is enabled for writing and used during rendering when {@link glArrayElement}, {@link glDrawArrays}, {@link glDrawElements}, {@link glDrawRangeElements} {@link glMultiDrawArrays}, or {@link glMultiDrawElements} is called. See {@link glFogCoordPointer}.
 *
 * - {@link GL_INDEX_ARRAY}
 *      If enabled, the index array is enabled for writing and used during rendering when {@link glArrayElement}, {@link glDrawArrays}, {@link glDrawElements}, {@link glDrawRangeElements} {@link glMultiDrawArrays}, or {@link glMultiDrawElements} is called. See {@link glIndexPointer}.
 *
 * - {@link GL_NORMAL_ARRAY}
 *      If enabled, the normal array is enabled for writing and used during rendering when {@link glArrayElement}, {@link glDrawArrays}, {@link glDrawElements}, {@link glDrawRangeElements} {@link glMultiDrawArrays}, or {@link glMultiDrawElements} is called. See {@link glNormalPointer}.
 *
 * - {@link GL_SECONDARY_COLOR_ARRAY}
 *      If enabled, the secondary color array is enabled for writing and used during rendering when {@link glArrayElement}, {@link glDrawArrays}, {@link glDrawElements}, {@link glDrawRangeElements} {@link glMultiDrawArrays}, or {@link glMultiDrawElements} is called. See {@link glColorPointer}.
 *
 * - {@link GL_TEXTURE_COORD_ARRAY}
 *      If enabled, the texture coordinate array is enabled for writing and used during rendering when {@link glArrayElement}, {@link glDrawArrays}, {@link glDrawElements}, {@link glDrawRangeElements} {@link glMultiDrawArrays}, or {@link glMultiDrawElements} is called. See {@link glTexCoordPointer}.
 *
 * - {@link GL_VERTEX_ARRAY}
 *      If enabled, the vertex array is enabled for writing and used during rendering when {@link glArrayElement}, {@link glDrawArrays}, {@link glDrawElements}, {@link glDrawRangeElements} {@link glMultiDrawArrays}, or {@link glMultiDrawElements} is called. See {@link glVertexPointer}.
 *
 * @summary enable client-side capability
 * @param cap Specifies the capability to enable. Symbolic constants {@link GL_COLOR_ARRAY}, {@link GL_EDGE_FLAG_ARRAY}, {@link GL_FOG_COORD_ARRAY}, {@link GL_INDEX_ARRAY}, {@link GL_NORMAL_ARRAY}, {@link GL_SECONDARY_COLOR_ARRAY}, {@link GL_TEXTURE_COORD_ARRAY}, and {@link GL_VERTEX_ARRAY} are accepted.
 * @tutorial [Songho - OpenGL Display List](https://www.songho.ca/opengl/gl_displaylist.html)
 * @tutorial [Songho - OpenGL Vertex Buffer Object (VBO)](https://www.songho.ca/opengl/gl_vbo.html)
 * @see [glEnableClientState](https://docs.gl/gl3/glEnableClientState)
 */
export function glEnableClientState(cap: GLenum): void;

/**
 * {@link glEnableClientState} and `glDisableClientState` enable or disable individual client-side capabilities. By default, all client-side capabilities are disabled. Both {@link glEnableClientState} and `glDisableClientState` take a single argument, **cap**, which can assume one of the following values:
 *
 * - {@link GL_COLOR_ARRAY}
 *     If enabled, the color array is enabled for writing and used during rendering when {@link glArrayElement}, {@link glDrawArrays}, {@link glDrawElements}, {@link glDrawRangeElements} {@link glMultiDrawArrays}, or {@link glMultiDrawElements} is called. See {@link glColorPointer}.
 *
 * - {@link GL_EDGE_FLAG_ARRAY}
 *     If enabled, the edge flag array is enabled for writing and used during rendering when {@link glArrayElement}, {@link glDrawArrays}, {@link glDrawElements}, {@link glDrawRangeElements} {@link glMultiDrawArrays}, or {@link glMultiDrawElements} is called. See {@link glEdgeFlagPointer}.
 *
 * - {@link GL_FOG_COORD_ARRAY}
 *     If enabled, the fog coordinate array is enabled for writing and used during rendering when {@link glArrayElement}, {@link glDrawArrays}, {@link glDrawElements}, {@link glDrawRangeElements} {@link glMultiDrawArrays}, or {@link glMultiDrawElements} is called. See {@link glFogCoordPointer}.
 *
 * - {@link GL_INDEX_ARRAY}
 *      If enabled, the index array is enabled for writing and used during rendering when {@link glArrayElement}, {@link glDrawArrays}, {@link glDrawElements}, {@link glDrawRangeElements} {@link glMultiDrawArrays}, or {@link glMultiDrawElements} is called. See {@link glIndexPointer}.
 *
 * - {@link GL_NORMAL_ARRAY}
 *      If enabled, the normal array is enabled for writing and used during rendering when {@link glArrayElement}, {@link glDrawArrays}, {@link glDrawElements}, {@link glDrawRangeElements} {@link glMultiDrawArrays}, or {@link glMultiDrawElements} is called. See {@link glNormalPointer}.
 *
 * - {@link GL_SECONDARY_COLOR_ARRAY}
 *      If enabled, the secondary color array is enabled for writing and used during rendering when {@link glArrayElement}, {@link glDrawArrays}, {@link glDrawElements}, {@link glDrawRangeElements} {@link glMultiDrawArrays}, or {@link glMultiDrawElements} is called. See {@link glColorPointer}.
 *
 * - {@link GL_TEXTURE_COORD_ARRAY}
 *      If enabled, the texture coordinate array is enabled for writing and used during rendering when {@link glArrayElement}, {@link glDrawArrays}, {@link glDrawElements}, {@link glDrawRangeElements} {@link glMultiDrawArrays}, or {@link glMultiDrawElements} is called. See {@link glTexCoordPointer}.
 *
 * - {@link GL_VERTEX_ARRAY}
 *      If enabled, the vertex array is enabled for writing and used during rendering when {@link glArrayElement}, {@link glDrawArrays}, {@link glDrawElements}, {@link glDrawRangeElements} {@link glMultiDrawArrays}, or {@link glMultiDrawElements} is called. See {@link glVertexPointer}.
 *
 * @summary disable client-side capability
 * @param cap Specifies the capability to enable. Symbolic constants {@link GL_COLOR_ARRAY}, {@link GL_EDGE_FLAG_ARRAY}, {@link GL_FOG_COORD_ARRAY}, {@link GL_INDEX_ARRAY}, {@link GL_NORMAL_ARRAY}, {@link GL_SECONDARY_COLOR_ARRAY}, {@link GL_TEXTURE_COORD_ARRAY}, and {@link GL_VERTEX_ARRAY} are accepted.
 * @tutorial [Songho - OpenGL Display List](https://www.songho.ca/opengl/gl_displaylist.html)
 * @tutorial [Songho - OpenGL Vertex Buffer Object (VBO)](https://www.songho.ca/opengl/gl_vbo.html)
 * @see [glDisableClientState](https://docs.gl/gl3/glDisableClientState)
 */
export function glDisableClientState(): void;

/**
 * `glEvalCoord1` evaluates enabled one-dimensional maps at argument **u**. `glEvalCoord2` does the same for two-dimensional maps using two domain values, **u** and **v**. To define a map, call {@link glMap1} and {@link glMap2}; to enable and disable it, call {@link glEnable} and {@link glDisable}.
 *
 * When one of the `glEvalCoord` commands is issued, all currently enabled maps of the indicated dimension are evaluated. Then, for each enabled map, it is as if the corresponding GL command had been issued with the computed value. That is, if {@link GL_MAP1_INDEX} or {@link GL_MAP2_INDEX} is enabled, a {@link glIndex} command is simulated. If {@link GL_MAP1_COLOR_4} or {@link GL_MAP2_COLOR_4} is enabled, a {@link glColor} command is simulated. If {@link GL_MAP1_NORMAL} or {@link GL_MAP2_NORMAL} is enabled, a normal vector is produced, and if any of {@link GL_MAP1_TEXTURE_COORD_1}, {@link GL_MAP1_TEXTURE_COORD_2}, {@link GL_MAP1_TEXTURE_COORD_3}, {@link GL_MAP1_TEXTURE_COORD_4}, {@link GL_MAP2_TEXTURE_COORD_1}, {@link GL_MAP2_TEXTURE_COORD_2}, {@link GL_MAP2_TEXTURE_COORD_3}, or {@link GL_MAP2_TEXTURE_COORD_4} is enabled, then an appropriate {@link glTexCoord} command is simulated.
 *
 * For color, color index, normal, and texture coordinates the GL uses evaluated values instead of current values for those evaluations that are enabled, and current values otherwise, However, the evaluated values do not update the current values. Thus, if {@link glVertex} commands are interspersed with `glEvalCoord` commands, the color, normal, and texture coordinates associated with the {@link glVertex} commands are not affected by the values generated by the `glEvalCoord` commands, but only by the most recent {@link glColor}, {@link glIndex}, {@link glNormal}, and {@link glTexCoord} commands.
 *
 * No commands are issued for maps that are not enabled. If more than one texture evaluation is enabled for a particular dimension (for example, {@link GL_MAP2_TEXTURE_COORD_1} and {@link GL_MAP2_TEXTURE_COORD_2}), then only the evaluation of the map that produces the larger number of coordinates (in this case, {@link GL_MAP2_TEXTURE_COORD_2}) is carried out. {@link GL_MAP1_VERTEX_4} overrides {@link GL_MAP1_VERTEX_3}, and {@link GL_MAP2_VERTEX_4} overrides {@link GL_MAP2_VERTEX_3}, in the same manner. If neither a three- nor a four-component vertex map is enabled for the specified dimension, the `glEvalCoord` command is ignored.
 *
 * If you have enabled automatic normal generation, by calling {@link glEnable} with argument {@link GL_AUTO_NORMAL}, `glEvalCoord2` generates surface normals analytically, regardless of the contents or enabling of the {@link GL_MAP2_NORMAL} map. Let
 *
 * 𝐦ᵐ = (∂p / ∂u) × (∂p / ∂v)
 *
 * Then the generated normal 𝐧 is 𝐧 = 𝐦 / ∥𝐦∥
 *
 * If automatic normal generation is disabled, the corresponding normal map {@link GL_MAP2_NORMAL}, if enabled, is used to produce a normal. If neither automatic normal generation nor a normal map is enabled, no normal is generated for `glEvalCoord2` commands.
 *
 * @summary evaluate enabled one- and two-dimensional maps
 * @param u Specifies a value that is the domain coordinate **u** to the basis function defined in a previous {@link glMap1} or {@link glMap2} command.
 * @see [glEvalCoord](https://docs.gl/gl3/glEvalCoord)
 */
export function glEvalCoord1d(u: GLdouble): void;

/**
 * `glEvalCoord1` evaluates enabled one-dimensional maps at argument **u**. `glEvalCoord2` does the same for two-dimensional maps using two domain values, **u** and **v**. To define a map, call {@link glMap1} and {@link glMap2}; to enable and disable it, call {@link glEnable} and {@link glDisable}.
 *
 * When one of the `glEvalCoord` commands is issued, all currently enabled maps of the indicated dimension are evaluated. Then, for each enabled map, it is as if the corresponding GL command had been issued with the computed value. That is, if {@link GL_MAP1_INDEX} or {@link GL_MAP2_INDEX} is enabled, a {@link glIndex} command is simulated. If {@link GL_MAP1_COLOR_4} or {@link GL_MAP2_COLOR_4} is enabled, a {@link glColor} command is simulated. If {@link GL_MAP1_NORMAL} or {@link GL_MAP2_NORMAL} is enabled, a normal vector is produced, and if any of {@link GL_MAP1_TEXTURE_COORD_1}, {@link GL_MAP1_TEXTURE_COORD_2}, {@link GL_MAP1_TEXTURE_COORD_3}, {@link GL_MAP1_TEXTURE_COORD_4}, {@link GL_MAP2_TEXTURE_COORD_1}, {@link GL_MAP2_TEXTURE_COORD_2}, {@link GL_MAP2_TEXTURE_COORD_3}, or {@link GL_MAP2_TEXTURE_COORD_4} is enabled, then an appropriate {@link glTexCoord} command is simulated.
 *
 * For color, color index, normal, and texture coordinates the GL uses evaluated values instead of current values for those evaluations that are enabled, and current values otherwise, However, the evaluated values do not update the current values. Thus, if {@link glVertex} commands are interspersed with `glEvalCoord` commands, the color, normal, and texture coordinates associated with the {@link glVertex} commands are not affected by the values generated by the `glEvalCoord` commands, but only by the most recent {@link glColor}, {@link glIndex}, {@link glNormal}, and {@link glTexCoord} commands.
 *
 * No commands are issued for maps that are not enabled. If more than one texture evaluation is enabled for a particular dimension (for example, {@link GL_MAP2_TEXTURE_COORD_1} and {@link GL_MAP2_TEXTURE_COORD_2}), then only the evaluation of the map that produces the larger number of coordinates (in this case, {@link GL_MAP2_TEXTURE_COORD_2}) is carried out. {@link GL_MAP1_VERTEX_4} overrides {@link GL_MAP1_VERTEX_3}, and {@link GL_MAP2_VERTEX_4} overrides {@link GL_MAP2_VERTEX_3}, in the same manner. If neither a three- nor a four-component vertex map is enabled for the specified dimension, the `glEvalCoord` command is ignored.
 *
 * If you have enabled automatic normal generation, by calling {@link glEnable} with argument {@link GL_AUTO_NORMAL}, `glEvalCoord2` generates surface normals analytically, regardless of the contents or enabling of the {@link GL_MAP2_NORMAL} map. Let
 *
 * 𝐦 = (∂p / ∂u) × (∂p / ∂v)
 *
 * Then the generated normal 𝐧 is 𝐧 = 𝐦 / ∥𝐦∥
 *
 * If automatic normal generation is disabled, the corresponding normal map {@link GL_MAP2_NORMAL}, if enabled, is used to produce a normal. If neither automatic normal generation nor a normal map is enabled, no normal is generated for `glEvalCoord2` commands.
 *
 * @summary evaluate enabled one- and two-dimensional maps
 * @param u Specifies a value that is the domain coordinate **u** to the basis function defined in a previous {@link glMap1} or {@link glMap2} command.
 * @see [glEvalCoord](https://docs.gl/gl3/glEvalCoord)
 */
export function glEvalCoord1f(u: GLfloat): void;

/**
 * `glEvalCoord1` evaluates enabled one-dimensional maps at argument **u**. `glEvalCoord2` does the same for two-dimensional maps using two domain values, **u** and **v**. To define a map, call {@link glMap1} and {@link glMap2}; to enable and disable it, call {@link glEnable} and {@link glDisable}.
 *
 * When one of the `glEvalCoord` commands is issued, all currently enabled maps of the indicated dimension are evaluated. Then, for each enabled map, it is as if the corresponding GL command had been issued with the computed value. That is, if {@link GL_MAP1_INDEX} or {@link GL_MAP2_INDEX} is enabled, a {@link glIndex} command is simulated. If {@link GL_MAP1_COLOR_4} or {@link GL_MAP2_COLOR_4} is enabled, a {@link glColor} command is simulated. If {@link GL_MAP1_NORMAL} or {@link GL_MAP2_NORMAL} is enabled, a normal vector is produced, and if any of {@link GL_MAP1_TEXTURE_COORD_1}, {@link GL_MAP1_TEXTURE_COORD_2}, {@link GL_MAP1_TEXTURE_COORD_3}, {@link GL_MAP1_TEXTURE_COORD_4}, {@link GL_MAP2_TEXTURE_COORD_1}, {@link GL_MAP2_TEXTURE_COORD_2}, {@link GL_MAP2_TEXTURE_COORD_3}, or {@link GL_MAP2_TEXTURE_COORD_4} is enabled, then an appropriate {@link glTexCoord} command is simulated.
 *
 * For color, color index, normal, and texture coordinates the GL uses evaluated values instead of current values for those evaluations that are enabled, and current values otherwise, However, the evaluated values do not update the current values. Thus, if {@link glVertex} commands are interspersed with `glEvalCoord` commands, the color, normal, and texture coordinates associated with the {@link glVertex} commands are not affected by the values generated by the `glEvalCoord` commands, but only by the most recent {@link glColor}, {@link glIndex}, {@link glNormal}, and {@link glTexCoord} commands.
 *
 * No commands are issued for maps that are not enabled. If more than one texture evaluation is enabled for a particular dimension (for example, {@link GL_MAP2_TEXTURE_COORD_1} and {@link GL_MAP2_TEXTURE_COORD_2}), then only the evaluation of the map that produces the larger number of coordinates (in this case, {@link GL_MAP2_TEXTURE_COORD_2}) is carried out. {@link GL_MAP1_VERTEX_4} overrides {@link GL_MAP1_VERTEX_3}, and {@link GL_MAP2_VERTEX_4} overrides {@link GL_MAP2_VERTEX_3}, in the same manner. If neither a three- nor a four-component vertex map is enabled for the specified dimension, the `glEvalCoord` command is ignored.
 *
 * If you have enabled automatic normal generation, by calling {@link glEnable} with argument {@link GL_AUTO_NORMAL}, `glEvalCoord2` generates surface normals analytically, regardless of the contents or enabling of the {@link GL_MAP2_NORMAL} map. Let
 *
 * 𝐦 = (∂p / ∂u) × (∂p / ∂v)
 *
 * Then the generated normal 𝐧 is 𝐧 = 𝐦 / ∥𝐦∥
 *
 * If automatic normal generation is disabled, the corresponding normal map {@link GL_MAP2_NORMAL}, if enabled, is used to produce a normal. If neither automatic normal generation nor a normal map is enabled, no normal is generated for `glEvalCoord2` commands.
 *
 * @summary evaluate enabled one- and two-dimensional maps
 * @param u Specifies a value that is the domain coordinate **u** to the basis function defined in a previous {@link glMap1} or {@link glMap2} command.
 * @param v Specifies a value that is the domain coordinate **v** to the basis function defined in a previous {@link glMap2} command. This argument is not present in a `glEvalCoord1` command.
 * @see [glEvalCoord](https://docs.gl/gl3/glEvalCoord)
 */
export function glEvalCoord2d(u: GLdouble, v: GLdouble): void;

/**
 * `glEvalCoord1` evaluates enabled one-dimensional maps at argument **u**. `glEvalCoord2` does the same for two-dimensional maps using two domain values, **u** and **v**. To define a map, call {@link glMap1} and {@link glMap2}; to enable and disable it, call {@link glEnable} and {@link glDisable}.
 *
 * When one of the `glEvalCoord` commands is issued, all currently enabled maps of the indicated dimension are evaluated. Then, for each enabled map, it is as if the corresponding GL command had been issued with the computed value. That is, if {@link GL_MAP1_INDEX} or {@link GL_MAP2_INDEX} is enabled, a {@link glIndex} command is simulated. If {@link GL_MAP1_COLOR_4} or {@link GL_MAP2_COLOR_4} is enabled, a {@link glColor} command is simulated. If {@link GL_MAP1_NORMAL} or {@link GL_MAP2_NORMAL} is enabled, a normal vector is produced, and if any of {@link GL_MAP1_TEXTURE_COORD_1}, {@link GL_MAP1_TEXTURE_COORD_2}, {@link GL_MAP1_TEXTURE_COORD_3}, {@link GL_MAP1_TEXTURE_COORD_4}, {@link GL_MAP2_TEXTURE_COORD_1}, {@link GL_MAP2_TEXTURE_COORD_2}, {@link GL_MAP2_TEXTURE_COORD_3}, or {@link GL_MAP2_TEXTURE_COORD_4} is enabled, then an appropriate {@link glTexCoord} command is simulated.
 *
 * For color, color index, normal, and texture coordinates the GL uses evaluated values instead of current values for those evaluations that are enabled, and current values otherwise, However, the evaluated values do not update the current values. Thus, if {@link glVertex} commands are interspersed with `glEvalCoord` commands, the color, normal, and texture coordinates associated with the {@link glVertex} commands are not affected by the values generated by the `glEvalCoord` commands, but only by the most recent {@link glColor}, {@link glIndex}, {@link glNormal}, and {@link glTexCoord} commands.
 *
 * No commands are issued for maps that are not enabled. If more than one texture evaluation is enabled for a particular dimension (for example, {@link GL_MAP2_TEXTURE_COORD_1} and {@link GL_MAP2_TEXTURE_COORD_2}), then only the evaluation of the map that produces the larger number of coordinates (in this case, {@link GL_MAP2_TEXTURE_COORD_2}) is carried out. {@link GL_MAP1_VERTEX_4} overrides {@link GL_MAP1_VERTEX_3}, and {@link GL_MAP2_VERTEX_4} overrides {@link GL_MAP2_VERTEX_3}, in the same manner. If neither a three- nor a four-component vertex map is enabled for the specified dimension, the `glEvalCoord` command is ignored.
 *
 * If you have enabled automatic normal generation, by calling {@link glEnable} with argument {@link GL_AUTO_NORMAL}, `glEvalCoord2` generates surface normals analytically, regardless of the contents or enabling of the {@link GL_MAP2_NORMAL} map. Let
 *
 * 𝐦 = (∂p / ∂u) × (∂p / ∂v)
 *
 * Then the generated normal 𝐧 is 𝐧 = 𝐦 / ∥𝐦∥
 *
 * If automatic normal generation is disabled, the corresponding normal map {@link GL_MAP2_NORMAL}, if enabled, is used to produce a normal. If neither automatic normal generation nor a normal map is enabled, no normal is generated for `glEvalCoord2` commands.
 *
 * @summary evaluate enabled one- and two-dimensional maps
 * @param u Specifies a value that is the domain coordinate **u** to the basis function defined in a previous {@link glMap1} or {@link glMap2} command.
 * @param v Specifies a value that is the domain coordinate **v** to the basis function defined in a previous {@link glMap2} command. This argument is not present in a `glEvalCoord1` command.
 * @see [glEvalCoord](https://docs.gl/gl3/glEvalCoord)
 */
export function glEvalCoord2f(u: GLfloat, v: GLfloat): void;

/**
 * `glEvalCoord1` evaluates enabled one-dimensional maps at argument **u**. `glEvalCoord2` does the same for two-dimensional maps using two domain values, **u** and **v**. To define a map, call {@link glMap1} and {@link glMap2}; to enable and disable it, call {@link glEnable} and {@link glDisable}.
 *
 * When one of the `glEvalCoord` commands is issued, all currently enabled maps of the indicated dimension are evaluated. Then, for each enabled map, it is as if the corresponding GL command had been issued with the computed value. That is, if {@link GL_MAP1_INDEX} or {@link GL_MAP2_INDEX} is enabled, a {@link glIndex} command is simulated. If {@link GL_MAP1_COLOR_4} or {@link GL_MAP2_COLOR_4} is enabled, a {@link glColor} command is simulated. If {@link GL_MAP1_NORMAL} or {@link GL_MAP2_NORMAL} is enabled, a normal vector is produced, and if any of {@link GL_MAP1_TEXTURE_COORD_1}, {@link GL_MAP1_TEXTURE_COORD_2}, {@link GL_MAP1_TEXTURE_COORD_3}, {@link GL_MAP1_TEXTURE_COORD_4}, {@link GL_MAP2_TEXTURE_COORD_1}, {@link GL_MAP2_TEXTURE_COORD_2}, {@link GL_MAP2_TEXTURE_COORD_3}, or {@link GL_MAP2_TEXTURE_COORD_4} is enabled, then an appropriate {@link glTexCoord} command is simulated.
 *
 * For color, color index, normal, and texture coordinates the GL uses evaluated values instead of current values for those evaluations that are enabled, and current values otherwise, However, the evaluated values do not update the current values. Thus, if {@link glVertex} commands are interspersed with `glEvalCoord` commands, the color, normal, and texture coordinates associated with the {@link glVertex} commands are not affected by the values generated by the `glEvalCoord` commands, but only by the most recent {@link glColor}, {@link glIndex}, {@link glNormal}, and {@link glTexCoord} commands.
 *
 * No commands are issued for maps that are not enabled. If more than one texture evaluation is enabled for a particular dimension (for example, {@link GL_MAP2_TEXTURE_COORD_1} and {@link GL_MAP2_TEXTURE_COORD_2}), then only the evaluation of the map that produces the larger number of coordinates (in this case, {@link GL_MAP2_TEXTURE_COORD_2}) is carried out. {@link GL_MAP1_VERTEX_4} overrides {@link GL_MAP1_VERTEX_3}, and {@link GL_MAP2_VERTEX_4} overrides {@link GL_MAP2_VERTEX_3}, in the same manner. If neither a three- nor a four-component vertex map is enabled for the specified dimension, the `glEvalCoord` command is ignored.
 *
 * If you have enabled automatic normal generation, by calling {@link glEnable} with argument {@link GL_AUTO_NORMAL}, `glEvalCoord2` generates surface normals analytically, regardless of the contents or enabling of the {@link GL_MAP2_NORMAL} map. Let
 *
 * 𝐦 = (∂p / ∂u) × (∂p / ∂v)
 *
 * Then the generated normal 𝐧 is 𝐧 = 𝐦 / ∥𝐦∥
 *
 * If automatic normal generation is disabled, the corresponding normal map {@link GL_MAP2_NORMAL}, if enabled, is used to produce a normal. If neither automatic normal generation nor a normal map is enabled, no normal is generated for `glEvalCoord2` commands.
 *
 * @summary evaluate enabled one- and two-dimensional maps
 * @param u Specifies a pointer to an array containing either one or two domain coordinates. The first coordinate is u. The second coordinate is v, which is present only in `glEvalCoord2` versions.
 * @see [glEvalCoord](https://docs.gl/gl3/glEvalCoord)
 */
export function glEvalCoord1dv(u: GLdouble): void;

/**
 * `glEvalCoord1` evaluates enabled one-dimensional maps at argument **u**. `glEvalCoord2` does the same for two-dimensional maps using two domain values, **u** and **v**. To define a map, call {@link glMap1} and {@link glMap2}; to enable and disable it, call {@link glEnable} and {@link glDisable}.
 *
 * When one of the `glEvalCoord` commands is issued, all currently enabled maps of the indicated dimension are evaluated. Then, for each enabled map, it is as if the corresponding GL command had been issued with the computed value. That is, if {@link GL_MAP1_INDEX} or {@link GL_MAP2_INDEX} is enabled, a {@link glIndex} command is simulated. If {@link GL_MAP1_COLOR_4} or {@link GL_MAP2_COLOR_4} is enabled, a {@link glColor} command is simulated. If {@link GL_MAP1_NORMAL} or {@link GL_MAP2_NORMAL} is enabled, a normal vector is produced, and if any of {@link GL_MAP1_TEXTURE_COORD_1}, {@link GL_MAP1_TEXTURE_COORD_2}, {@link GL_MAP1_TEXTURE_COORD_3}, {@link GL_MAP1_TEXTURE_COORD_4}, {@link GL_MAP2_TEXTURE_COORD_1}, {@link GL_MAP2_TEXTURE_COORD_2}, {@link GL_MAP2_TEXTURE_COORD_3}, or {@link GL_MAP2_TEXTURE_COORD_4} is enabled, then an appropriate {@link glTexCoord} command is simulated.
 *
 * For color, color index, normal, and texture coordinates the GL uses evaluated values instead of current values for those evaluations that are enabled, and current values otherwise, However, the evaluated values do not update the current values. Thus, if {@link glVertex} commands are interspersed with `glEvalCoord` commands, the color, normal, and texture coordinates associated with the {@link glVertex} commands are not affected by the values generated by the `glEvalCoord` commands, but only by the most recent {@link glColor}, {@link glIndex}, {@link glNormal}, and {@link glTexCoord} commands.
 *
 * No commands are issued for maps that are not enabled. If more than one texture evaluation is enabled for a particular dimension (for example, {@link GL_MAP2_TEXTURE_COORD_1} and {@link GL_MAP2_TEXTURE_COORD_2}), then only the evaluation of the map that produces the larger number of coordinates (in this case, {@link GL_MAP2_TEXTURE_COORD_2}) is carried out. {@link GL_MAP1_VERTEX_4} overrides {@link GL_MAP1_VERTEX_3}, and {@link GL_MAP2_VERTEX_4} overrides {@link GL_MAP2_VERTEX_3}, in the same manner. If neither a three- nor a four-component vertex map is enabled for the specified dimension, the `glEvalCoord` command is ignored.
 *
 * If you have enabled automatic normal generation, by calling {@link glEnable} with argument {@link GL_AUTO_NORMAL}, `glEvalCoord2` generates surface normals analytically, regardless of the contents or enabling of the {@link GL_MAP2_NORMAL} map. Let
 *
 * 𝐦 = (∂p / ∂u) × (∂p / ∂v)
 *
 * Then the generated normal 𝐧 is 𝐧 = 𝐦 / ∥𝐦∥
 *
 * If automatic normal generation is disabled, the corresponding normal map {@link GL_MAP2_NORMAL}, if enabled, is used to produce a normal. If neither automatic normal generation nor a normal map is enabled, no normal is generated for `glEvalCoord2` commands.
 *
 * @summary evaluate enabled one- and two-dimensional maps
 * @param u Specifies a pointer to an array containing either one or two domain coordinates. The first coordinate is u. The second coordinate is v, which is present only in `glEvalCoord2` versions.
 * @see [glEvalCoord](https://docs.gl/gl3/glEvalCoord)
 */
export function glEvalCoord1fv(u: GLfloat): void;

/**
 * `glEvalCoord1` evaluates enabled one-dimensional maps at argument **u**. `glEvalCoord2` does the same for two-dimensional maps using two domain values, **u** and **v**. To define a map, call {@link glMap1} and {@link glMap2}; to enable and disable it, call {@link glEnable} and {@link glDisable}.
 *
 * When one of the `glEvalCoord` commands is issued, all currently enabled maps of the indicated dimension are evaluated. Then, for each enabled map, it is as if the corresponding GL command had been issued with the computed value. That is, if {@link GL_MAP1_INDEX} or {@link GL_MAP2_INDEX} is enabled, a {@link glIndex} command is simulated. If {@link GL_MAP1_COLOR_4} or {@link GL_MAP2_COLOR_4} is enabled, a {@link glColor} command is simulated. If {@link GL_MAP1_NORMAL} or {@link GL_MAP2_NORMAL} is enabled, a normal vector is produced, and if any of {@link GL_MAP1_TEXTURE_COORD_1}, {@link GL_MAP1_TEXTURE_COORD_2}, {@link GL_MAP1_TEXTURE_COORD_3}, {@link GL_MAP1_TEXTURE_COORD_4}, {@link GL_MAP2_TEXTURE_COORD_1}, {@link GL_MAP2_TEXTURE_COORD_2}, {@link GL_MAP2_TEXTURE_COORD_3}, or {@link GL_MAP2_TEXTURE_COORD_4} is enabled, then an appropriate {@link glTexCoord} command is simulated.
 *
 * For color, color index, normal, and texture coordinates the GL uses evaluated values instead of current values for those evaluations that are enabled, and current values otherwise, However, the evaluated values do not update the current values. Thus, if {@link glVertex} commands are interspersed with `glEvalCoord` commands, the color, normal, and texture coordinates associated with the {@link glVertex} commands are not affected by the values generated by the `glEvalCoord` commands, but only by the most recent {@link glColor}, {@link glIndex}, {@link glNormal}, and {@link glTexCoord} commands.
 *
 * No commands are issued for maps that are not enabled. If more than one texture evaluation is enabled for a particular dimension (for example, {@link GL_MAP2_TEXTURE_COORD_1} and {@link GL_MAP2_TEXTURE_COORD_2}), then only the evaluation of the map that produces the larger number of coordinates (in this case, {@link GL_MAP2_TEXTURE_COORD_2}) is carried out. {@link GL_MAP1_VERTEX_4} overrides {@link GL_MAP1_VERTEX_3}, and {@link GL_MAP2_VERTEX_4} overrides {@link GL_MAP2_VERTEX_3}, in the same manner. If neither a three- nor a four-component vertex map is enabled for the specified dimension, the `glEvalCoord` command is ignored.
 *
 * If you have enabled automatic normal generation, by calling {@link glEnable} with argument {@link GL_AUTO_NORMAL}, `glEvalCoord2` generates surface normals analytically, regardless of the contents or enabling of the {@link GL_MAP2_NORMAL} map. Let
 *
 * 𝐦 = (∂p / ∂u) × (∂p / ∂v)
 *
 * Then the generated normal 𝐧 is 𝐧 = 𝐦 / ∥𝐦∥
 *
 * If automatic normal generation is disabled, the corresponding normal map {@link GL_MAP2_NORMAL}, if enabled, is used to produce a normal. If neither automatic normal generation nor a normal map is enabled, no normal is generated for `glEvalCoord2` commands.
 *
 * @summary evaluate enabled one- and two-dimensional maps
 * @param u Specifies a pointer to an array containing either one or two domain coordinates. The first coordinate is u. The second coordinate is v, which is present only in `glEvalCoord2` versions.
 * @see [glEvalCoord](https://docs.gl/gl3/glEvalCoord)
 */
export function glEvalCoord2dv(u: GLdouble): void;

/**
 * `glEvalCoord1` evaluates enabled one-dimensional maps at argument **u**. `glEvalCoord2` does the same for two-dimensional maps using two domain values, **u** and **v**. To define a map, call {@link glMap1} and {@link glMap2}; to enable and disable it, call {@link glEnable} and {@link glDisable}.
 *
 * When one of the `glEvalCoord` commands is issued, all currently enabled maps of the indicated dimension are evaluated. Then, for each enabled map, it is as if the corresponding GL command had been issued with the computed value. That is, if {@link GL_MAP1_INDEX} or {@link GL_MAP2_INDEX} is enabled, a {@link glIndex} command is simulated. If {@link GL_MAP1_COLOR_4} or {@link GL_MAP2_COLOR_4} is enabled, a {@link glColor} command is simulated. If {@link GL_MAP1_NORMAL} or {@link GL_MAP2_NORMAL} is enabled, a normal vector is produced, and if any of {@link GL_MAP1_TEXTURE_COORD_1}, {@link GL_MAP1_TEXTURE_COORD_2}, {@link GL_MAP1_TEXTURE_COORD_3}, {@link GL_MAP1_TEXTURE_COORD_4}, {@link GL_MAP2_TEXTURE_COORD_1}, {@link GL_MAP2_TEXTURE_COORD_2}, {@link GL_MAP2_TEXTURE_COORD_3}, or {@link GL_MAP2_TEXTURE_COORD_4} is enabled, then an appropriate {@link glTexCoord} command is simulated.
 *
 * For color, color index, normal, and texture coordinates the GL uses evaluated values instead of current values for those evaluations that are enabled, and current values otherwise, However, the evaluated values do not update the current values. Thus, if {@link glVertex} commands are interspersed with `glEvalCoord` commands, the color, normal, and texture coordinates associated with the {@link glVertex} commands are not affected by the values generated by the `glEvalCoord` commands, but only by the most recent {@link glColor}, {@link glIndex}, {@link glNormal}, and {@link glTexCoord} commands.
 *
 * No commands are issued for maps that are not enabled. If more than one texture evaluation is enabled for a particular dimension (for example, {@link GL_MAP2_TEXTURE_COORD_1} and {@link GL_MAP2_TEXTURE_COORD_2}), then only the evaluation of the map that produces the larger number of coordinates (in this case, {@link GL_MAP2_TEXTURE_COORD_2}) is carried out. {@link GL_MAP1_VERTEX_4} overrides {@link GL_MAP1_VERTEX_3}, and {@link GL_MAP2_VERTEX_4} overrides {@link GL_MAP2_VERTEX_3}, in the same manner. If neither a three- nor a four-component vertex map is enabled for the specified dimension, the `glEvalCoord` command is ignored.
 *
 * If you have enabled automatic normal generation, by calling {@link glEnable} with argument {@link GL_AUTO_NORMAL}, `glEvalCoord2` generates surface normals analytically, regardless of the contents or enabling of the {@link GL_MAP2_NORMAL} map. Let
 *
 * 𝐦 = (∂p / ∂u) × (∂p / ∂v)
 *
 * Then the generated normal 𝐧 is 𝐧 = 𝐦 / ∥𝐦∥
 *
 * If automatic normal generation is disabled, the corresponding normal map {@link GL_MAP2_NORMAL}, if enabled, is used to produce a normal. If neither automatic normal generation nor a normal map is enabled, no normal is generated for `glEvalCoord2` commands.
 *
 * @summary evaluate enabled one- and two-dimensional maps
 * @param u Specifies a pointer to an array containing either one or two domain coordinates. The first coordinate is u. The second coordinate is v, which is present only in `glEvalCoord2` versions.
 * @see [glEvalCoord](https://docs.gl/gl3/glEvalCoord)
 */
export function glEvalCoord2fv(u: GLfloat): void;

/**
 * {@link glMapGrid} and `glEvalMesh` are used in tandem to efficiently generate and evaluate a series of evenly-spaced map domain values. `glEvalMesh` steps through the integer domain of a one- or two-dimensional grid, whose range is the domain of the evaluation maps specified by {@link glMap1} and {@link glMap2}. **mode** determines whether the resulting vertices are connected as points, lines, or filled polygons.
 *
 * In the one-dimensional case, `glEvalMesh1`, the mesh is generated as if the following code fragment were executed:
 *
 * ```
 * glBegin(type);
 * for (i = i1; i <= i2; i += 1) {
 * 		glEvalCoord1(i⋅Δu + u₁);
 * }
 * glEnd();
 * ```
 *
 * where
 *
 * Δu = (u₂ − u₁) / 𝐧
 *
 * and 𝐧, u₁, and u₂ are the arguments to the most recent {@link glMapGrid1} command. **type** is {@link GL_POINTS} if **mode** is {@link GL_POINT}, or {@link GL_LINES} if **mode** is {@link GL_LINE}.
 *
 * The one absolute numeric requirement is that if 𝐢 = 𝐧, then the value computed from i⋅Δu + u₁ is exactly u₂.
 *
 * In the two-dimensional case, `glEvalMesh2`, let .cp
 *
 * Δu = (u₂ − u₁) / 𝐧
 *
 * Δv = (v₂ − v₁) / 𝐦
 *
 * where 𝐧, u₁, u₂, 𝐦, v₁, and v₂ are the arguments to the most recent {@link glMapGrid2} command. Then, if **mode** is {@link GL_FILL}, the `glEvalMesh2` command is equivalent to:
 *
 * ```
 * for (j = j1; j < j2; j += 1) {
 * 		glBegin(GL_QUAD_STRIP);
 * 		for (i = i1; i <= i2; i += 1) {
 * 			glEvalCoord2(i⋅Δu + u₁, j⋅Δv + v₁);
 * 			glEvalCoord2(i⋅Δu + u₁, (j + 1)⋅Δv + v₁);
 * 		}
 * 		glEnd();
 * }
 * ```
 *
 * If **mode** is {@link GL_LINE}, then a call to `glEvalMesh2` is equivalent to:
 *
 * ```
 * for (j = j1; j <= j2; j += 1) {
 * 		glBegin(GL_LINE_STRIP);
 * 		for (i = i1; i <= i2; i += 1) {
 * 			glEvalCoord2(i⋅Δu + u₁, j⋅Δv + v₁);
 * 		}
 * 		glEnd();
 * }
 *
 * for (i = i1; i <= i2; i += 1) {
 * 		glBegin(GL_LINE_STRIP);
 * 		for (j = j1; j <= j2; j += 1) {
 * 			glEvalCoord2(i⋅Δu + u₁, j⋅Δv + v₁);
 * 		}
 * 		glEnd();
 * }
 * ```
 *
 * And finally, if **mode** is {@link GL_POINT}, then a call to `glEvalMesh2` is equivalent to:
 *
 * ```
 * glBegin(GL_POINTS);
 * for (j = j1; j <= j2; j += 1) {
 * 		for (i = i1; i <= i2; i += 1) {
 * 			glEvalCoord2(i⋅Δu + u₁, j⋅Δv + v₁);
 * 		}
 * }
 * glEnd();
 * ```
 *
 * three cases, the only absolute numeric requirements are that if i = 𝐧, then the value computed from i⋅Δu + u₁ is exactly u₂, and if j = 𝐦, then the value computed from j⋅Δv + v₁ is exactly v₂.
 *
 * @summary compute a one-dimensional grid of points or lines
 * @param mode In `glEvalMesh1`, specifies whether to compute a one-dimensional mesh of points or lines. Symbolic constants {@link GL_POINT} and {@link GL_LINE} are accepted.
 * @param i1 Specifies the first integer value for grid domain variable
 * @param i2 Specifies the last integer value for grid domain variable
 * @see [glEvalMesh](https://docs.gl/gl3/glEvalMesh)
 */
export function glEvalMesh1(mode: GLenum, i1: GLint, i2: GLint): void;

/**
 * {@link glMapGrid} and `glEvalMesh` are used in tandem to efficiently generate and evaluate a series of evenly-spaced map domain values. `glEvalMesh` steps through the integer domain of a one- or two-dimensional grid, whose range is the domain of the evaluation maps specified by {@link glMap1} and {@link glMap2}. **mode** determines whether the resulting vertices are connected as points, lines, or filled polygons.
 *
 * In the one-dimensional case, `glEvalMesh1`, the mesh is generated as if the following code fragment were executed:
 *
 * ```
 * glBegin(type);
 * for (i = i1; i <= i2; i += 1) {
 * 		glEvalCoord1(i⋅Δu + u₁);
 * }
 * glEnd();
 * ```
 *
 * where
 *
 * Δu = (u₂ − u₁) / 𝐧
 *
 * and 𝐧, u₁, and u₂ are the arguments to the most recent {@link glMapGrid1} command. **type** is {@link GL_POINTS} if **mode** is {@link GL_POINT}, or {@link GL_LINES} if **mode** is {@link GL_LINE}.
 *
 * The one absolute numeric requirement is that if 𝐢 = 𝐧, then the value computed from i⋅Δu + u₁ is exactly u₂.
 *
 * In the two-dimensional case, `glEvalMesh2`, let .cp
 *
 * Δu = (u₂ − u₁) / 𝐧
 *
 * Δv = (v₂ − v₁) / 𝐦
 *
 * where 𝐧, u₁, u₂, 𝐦, v₁, and v₂ are the arguments to the most recent {@link glMapGrid2} command. Then, if **mode** is {@link GL_FILL}, the `glEvalMesh2` command is equivalent to:
 *
 * ```
 * for (j = j1; j < j2; j += 1) {
 * 		glBegin(GL_QUAD_STRIP);
 * 		for (i = i1; i <= i2; i += 1) {
 * 			glEvalCoord2(i⋅Δu + u₁, j⋅Δv + v₁);
 * 			glEvalCoord2(i⋅Δu + u₁, (j + 1)⋅Δv + v₁);
 * 		}
 * 		glEnd();
 * }
 * ```
 *
 * If **mode** is {@link GL_LINE}, then a call to `glEvalMesh2` is equivalent to:
 *
 * ```
 * for (j = j1; j <= j2; j += 1) {
 * 		glBegin(GL_LINE_STRIP);
 * 		for (i = i1; i <= i2; i += 1) {
 * 			glEvalCoord2(i⋅Δu + u₁, j⋅Δv + v₁);
 * 		}
 * 		glEnd();
 * }
 *
 * for (i = i1; i <= i2; i += 1) {
 * 		glBegin(GL_LINE_STRIP);
 * 		for (j = j1; j <= j2; j += 1) {
 * 			glEvalCoord2(i⋅Δu + u₁, j⋅Δv + v₁);
 * 		}
 * 		glEnd();
 * }
 * ```
 *
 * And finally, if **mode** is {@link GL_POINT}, then a call to `glEvalMesh2` is equivalent to:
 *
 * ```
 * glBegin(GL_POINTS);
 * for (j = j1; j <= j2; j += 1) {
 * 		for (i = i1; i <= i2; i += 1) {
 * 			glEvalCoord2(i⋅Δu + u₁, j⋅Δv + v₁);
 * 		}
 * }
 * glEnd();
 * ```
 *
 * three cases, the only absolute numeric requirements are that if i = 𝐧, then the value computed from i⋅Δu + u₁ is exactly u₂, and if j = 𝐦, then the value computed from j⋅Δv + v₁ is exactly v₂.
 *
 * @summary compute a two-dimensional grid of points or lines
 * @param mode In `glEvalMesh1`, specifies whether to compute a one-dimensional mesh of points or lines. Symbolic constants {@link GL_POINT} and {@link GL_LINE} are accepted.
 * @param i1 Specifies the first integer value for grid domain variable i.
 * @param i2 Specifies the last integer value for grid domain variable i.
 * @param j1 Specifies the first integer value for grid domain variable j.
 * @param j2 Specifies the last integer value for grid domain variable j.
 * @see [glEvalMesh](https://docs.gl/gl3/glEvalMesh)
 */
export function glEvalMesh2(
	mode: GLenum,
	i1: GLint,
	i2: GLint,
	j1: GLint,
	j2: GLint
): void;

/**
 *  {@link glMapGrid} and {@link glEvalMesh} are used in tandem to efficiently generate and evaluate a series of evenly spaced map domain values. `glEvalPoint` can be used to evaluate a single grid point in the same gridspace that is traversed by {@link glEvalMesh}. Calling `glEvalPoint1` is equivalent to calling
 *
 * ```glEvalCoord1 (i⋅Δu + u₁);```
 *
 * where
 *
 * Δu = (u₂ − u₁) / 𝐧
 *
 * and 𝐧, u₁, and u₂ are the arguments to the most recent {@link glMapGrid1} command. The one absolute numeric requirement is that if i = 𝐧, then the value computed from i⋅Δu + u₁ is exactly u₂.
 *
 * In the two-dimensional case, `glEvalPoint2`, let
 *
 * Δu = (u₂ − u₁) / 𝐧
 *
 * Δv = (v₂ − v₁) / 𝐦
 *
 * where 𝐧, u₁, u₂, 𝐦, v₁, and v₂ are the arguments to the most recent {@link glMapGrid2} command. Then the `glEvalPoint2` command is equivalent to calling
 *
 * ```glEvalCoord2(i⋅Δu + u₁, j⋅Δv + v₁);```
 *
 * The only absolute numeric requirements are that if i = 𝐧, then the value computed from i⋅Δu + u₁ is exactly u₂, and if j = 𝐦, then the value computed from j⋅Δv + v₁ is exactly v₂.
 *
 * @summary generate and evaluate a single point in a mesh
 * @param i Specifies the integer value for grid domain variable i.
 * @see [glEvalPoint](https://docs.gl/gl3/glEvalPoint)
 */
export function glEvalPoint1(i: GLint): void;

/**
 *  {@link glMapGrid} and {@link glEvalMesh} are used in tandem to efficiently generate and evaluate a series of evenly spaced map domain values. `glEvalPoint` can be used to evaluate a single grid point in the same gridspace that is traversed by {@link glEvalMesh}. Calling `glEvalPoint1` is equivalent to calling
 *
 * ```glEvalCoord1 (i⋅Δu + u₁);```
 *
 * where
 *
 * Δu = (u₂ − u₁) / 𝐧
 *
 * and 𝐧, u₁, and u₂ are the arguments to the most recent {@link glMapGrid1} command. The one absolute numeric requirement is that if i = 𝐧, then the value computed from i⋅Δu + u₁ is exactly u₂.
 *
 * In the two-dimensional case, `glEvalPoint2`, let
 *
 * Δu = (u₂ − u₁) / 𝐧
 *
 * Δv = (v₂ − v₁) / 𝐦
 *
 * where 𝐧, u₁, u₂, 𝐦, v₁, and v₂ are the arguments to the most recent {@link glMapGrid2} command. Then the `glEvalPoint2` command is equivalent to calling
 *
 * ```glEvalCoord2(i⋅Δu + u₁, j⋅Δv + v₁);```
 *
 * The only absolute numeric requirements are that if i = 𝐧, then the value computed from i⋅Δu + u₁ is exactly u₂, and if j = 𝐦, then the value computed from j⋅Δv + v₁ is exactly v₂.
 *
 * @summary generate and evaluate a single point in a mesh
 * @param i Specifies the integer value for grid domain variable i.
 * @param j Specifies the integer value for grid domain variable j.
 * @see [glEvalPoint](https://docs.gl/gl3/glEvalPoint)
 */
export function glEvalPoint2(i: GLint, j: GLint): void;

/**
 * The `glFeedbackBuffer` function controls feedback. Feedback, like selection, is a GL mode. The mode is selected by calling {@link glRenderMode} with {@link GL_FEEDBACK}. When the GL is in feedback mode, no pixels are produced by rasterization. Instead, information about primitives that would have been rasterized is fed back to the application using the GL.
 *
 * `glFeedbackBuffer` has three arguments: **buffer** is a pointer to an array of floating-point values into which feedback information is placed. **size** indicates the size of the array. **type** is a symbolic constant describing the information that is fed back for each vertex. `glFeedbackBuffer` must be issued before feedback mode is enabled (by calling {@link glRenderMode} with argument {@link GL_FEEDBACK}). Setting {@link GL_FEEDBACK} without establishing the feedback buffer, or calling `glFeedbackBuffer` while the GL is in feedback mode, is an error.
 *
 * When {@link glRenderMode} is called while in feedback mode, it returns the number of entries placed in the feedback array and resets the feedback array pointer to the base of the feedback buffer. The returned value never exceeds **size**. If the feedback data required more room than was available in **buffer**, {@link glRenderMode} returns a negative value. To take the GL out of feedback mode, call {@link glRenderMode} with a parameter value other than {@link GL_FEEDBACK}.
 *
 * While in feedback mode, each primitive, bitmap, or pixel rectangle that would be rasterized generates a block of values that are copied into the feedback array. If doing so would cause the number of entries to exceed the maximum, the block is partially written so as to fill the array (if there is any room left at all), and an overflow flag is set. Each block begins with a code indicating the primitive type, followed by values that describe the primitive's vertices and associated data. Entries are also written for bitmaps and pixel rectangles. Feedback occurs after polygon culling and {@link glPolygonMode} interpretation of polygons has taken place, so polygons that are culled are not returned in the feedback buffer. It can also occur after polygons with more than three edges are broken up into triangles, if the GL implementation renders polygons by performing this decomposition.
 *
 * The {@link glPassThrough} command can be used to insert a marker into the feedback buffer. See {@link glPassThrough}.
 *
 * Following is the grammar for the blocks of values written into the feedback buffer. Each primitive is indicated with a unique identifying value followed by some number of vertices. Polygon entries include an integer value indicating how many vertices follow. A vertex is fed back as some number of floating-point values, as determined by **type**. Colors are fed back as four values in RGBA mode and one value in color index mode.
 *
 * feedbackList ← feedbackItem feedbackList | feedbackItem
 *
 * feedbackItem ← point | lineSegment | polygon | bitmap | pixelRectangle | passThru
 *
 * point ← {@link GL_POINT_TOKEN} vertex
 *
 * lineSegment ← {@link GL_LINE_TOKEN} vertex vertex | {@link GL_LINE_RESET_TOKEN} vertex vertex
 *
 * polygon ← {@link GL_POLYGON_TOKEN} n polySpec
 *
 * polySpec ← polySpec vertex | vertex vertex vertex
 *
 * bitmap ← {@link GL_BITMAP_TOKEN} vertex
 *
 * pixelRectangle ← {@link GL_DRAW_PIXEL_TOKEN} vertex | {@link GL_COPY_PIXEL_TOKEN} vertex
 *
 * passThru ← {@link GL_PASS_THROUGH_TOKEN} value
 *
 * vertex ← 2d | 3d | 3dColor | 3dColorTexture | 4dColorTexture
 *
 * 2d ← value value
 *
 * 3d ← value value value
 *
 * 3dColor ← value value value color
 *
 * 3dColorTexture ← value value value color tex
 *
 * 4dColorTexture ← value value value value color tex
 *
 * color ← rgba | index
 *
 * rgba ← value value value value
 *
 * index ← value
 *
 * tex ← value value value value
 *
 * **value** is a floating-point number, and **n** is a floating-point integer giving the number of vertices in the polygon. {@link GL_POINT_TOKEN}, {@link GL_LINE_TOKEN}, {@link GL_LINE_RESET_TOKEN}, {@link GL_POLYGON_TOKEN}, {@link GL_BITMAP_TOKEN}, {@link GL_DRAW_PIXEL_TOKEN}, {@link GL_COPY_PIXEL_TOKEN} and {@link GL_PASS_THROUGH_TOKEN} are symbolic floating-point constants. {@link GL_LINE_RESET_TOKEN} is returned whenever the line stipple pattern is reset. The data returned as a vertex depends on the feedback **type**.
 *
 * The following table gives the correspondence between **type** and the number of values per vertex. **k** is 1 in color index mode and 4 in RGBA mode.
 *
 * | **Type**                    | **Coordinates**            | **Color** | **Texture** | **Total Number of Values** |
 * | :-------------------------- | :------------------------- | :-------- | :---------- | :------------------------- |
 * | {@link GL_2D}               | **x**, **y**               |           |             | 2                          |
 * | {@link GL_3D}               | **x**, **y**, **z**        |           |             | 3                          |
 * | {@link GL_3D_COLOR}         | **x**, **y**, **z**        | 𝑲         |             | 3 + 𝑲                      |
 * | {@link GL_3D_COLOR_TEXTURE} | **x**, **y**, **z**        | 𝑲         | 4           | 7 + 𝑲                      |
 * | {@link GL_4D_COLOR_TEXTURE} | **x**, **y**, **z**, **w** | 𝑲         | 4           | 8 + 𝑲                      |
 *
 * Feedback vertex coordinates are in window coordinates, except **w**, which is in clip coordinates. Feedback colors are lighted, if lighting is enabled. Feedback texture coordinates are generated, if texture coordinate generation is enabled. They are always transformed by the texture matrix.
 *
 * @summary controls feedback mode
 * @param size Specifies the maximum number of values that can be written into **buffer**.
 * @param type Specifies a symbolic constant that describes the information that will be returned for each vertex. {@link GL_2D}, {@link GL_3D}, {@link GL_3D_COLOR}, {@link GL_3D_COLOR_TEXTURE}, and {@link GL_4D_COLOR_TEXTURE} are accepted.
 * @param buffer Returns the feedback data.
 * @see [glFeedbackBuffer](https://docs.gl/gl3/glFeedbackBuffer)
 */
export function glFeedbackBuffer(
	size: GLsizei,
	type: GLenum,
	buffer: GLfloat
): void;

/**
 * `glFinish` does not return until the effects of all previously called GL commands are complete. Such effects include all changes to GL state, all changes to connection state, and all changes to the frame buffer contents.
 *
 * @summary block until all GL execution is complete
 * @tutorial [Songho - OpenGL Display List](https://www.songho.ca/opengl/gl_displaylist.html)
 * @see [glFinish](https://docs.gl/gl3/glFinish)
 */
export function glFinish(): void;

/**
 * Different GL implementations buffer commands in several different locations, including network buffers and the graphics accelerator itself. `glFlush` empties all of these buffers, causing all issued commands to be executed as quickly as they are accepted by the actual rendering engine. Though this execution may not be completed in any particular time period, it does complete in finite time.
 *
 * Because any GL program might be executed over a network, or on an accelerator that buffers commands, all programs should call `glFlush` whenever they count on having all of their previously issued commands completed. For example, call `glFlush` before waiting for user input that depends on the generated image.
 *
 * @summary force execution of GL commands in finite time
 * @see [glFlush](https://docs.gl/gl3/glFlush)
 */
export function glFlush(): void;

/**
 * Fog is initially disabled. While enabled, fog affects rasterized geometry, bitmaps, and pixel blocks, but not buffer clear operations. To enable and disable fog, call {@link glEnable} and {@link glDisable} with argument {@link GL_FOG}.
 *
 * `glFog` assigns the value or values in **params** to the fog parameter specified by **pname**. The following values are accepted for **pname**:
 *
 * - {@link GL_FOG_MODE}
 * **params** is a single integer or floating-point value that specifies the equation to be used to compute the fog blend factor, ƒ. Three symbolic constants are accepted: {@link GL_LINEAR}, {@link GL_EXP}, and {@link GL_EXP2}. The equations corresponding to these symbolic constants are defined below. The initial fog mode is {@link GL_EXP}.
 *
 * - {@link GL_FOG_DENSITY}
 *  **params** is a single integer or floating-point value that specifies *density*, the fog density used in both exponential fog equations. Only nonnegative densities are accepted. The initial fog density is 1.
 *
 * - {@link GL_FOG_START}
 *  **params** is a single integer or floating-point value that specifies *start*, the near distance used in the linear fog equation. The initial near distance is 0.
 *
 * - {@link GL_FOG_END}
 *  **params** is a single integer or floating-point value that specifies *end*, the far distance used in the linear fog equation. The initial far distance is 1.
 *
 * - {@link GL_FOG_INDEX}
 *
 *  **params** is a single integer or floating-point value that specifies 𝐢𝑓, the fog color index. The initial fog index is 0.
 *
 * - {@link GL_FOG_COLOR}
 *  **params** contains four integer or floating-point values that specify 𝐂𝑓, the fog color. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. After conversion, all color components are clamped to the range [0,1]. The initial fog color is (0, 0, 0, 0).
 *
 * - {@link GL_FOG_COORD_SRC}
 * **params** contains either of the following symbolic constants: {@link GL_FOG_COORD} or {@link GL_FRAGMENT_DEPTH}. {@link GL_FOG_COORD} specifies that the current fog coordinate should be used as distance value in the fog color computation. {@link GL_FRAGMENT_DEPTH} specifies that the current fragment depth should be used as distance value in the fog computation.
 *
 *  Fog blends a fog color with each rasterized pixel fragment's post-texturing color using a blending factor ƒ. Factor ƒ is computed in one of three ways, depending on the fog mode. Let 𝐂 be either the distance in eye coordinate from the origin (in the case that the {@link GL_FOG_COORD_SRC} is {@link GL_FRAGMENT_DEPTH}) or the current fog coordinate (in the case that {@link GL_FOG_COORD_SRC} is {@link GL_FOG_COORD}). The equation for {@link GL_LINEAR} fog is
 *
 * ƒ = end − 𝐂 / end − start
 *
 * The equation for {@link GL_EXP} fog is
 *
 * ƒ = 𝐞 ^ −(density⋅𝐂)
 *
 * The equation for {@link GL_EXP2} fog is
 *
 * ƒ = 𝐞 ^ −(density⋅𝐂)²
 *
 * Regardless of the fog mode, ƒ is clamped to the range [0,1] after it is computed. Then, if the GL is in RGBA color mode, the fragment's red, green, and blue colors, represented by 𝐂ᵣ, are replaced by
 *
 * 𝐂ᵣ′′ = ƒ × 𝐂ᵣ + (1 − ƒ) × 𝐂𝑓
 *
 * Fog does not affect a fragment's alpha component.
 *
 * In color index mode, the fragment's color index 𝐢ᵣ is replaced by
 *
 * 𝐢ᵣ′′ = 𝐢ᵣ + (1 − ƒ) × 𝐢𝑓
 *
 * @summary specify fog parameters
 * @param pname Specifies a single-valued fog parameter. {@link GL_FOG_MODE}, {@link GL_FOG_DENSITY}, {@link GL_FOG_START}, {@link GL_FOG_END}, {@link GL_FOG_INDEX}, and {@link GL_FOG_COORD_SRC} are accepted.
 * @param param Specifies the value that **pname** will be set to.
 * @see [glFog](https://docs.gl/gl3/glFog)
 */
export function glFogf(pname: GLenum, param: GLfloat): void;

/**
 * Fog is initially disabled. While enabled, fog affects rasterized geometry, bitmaps, and pixel blocks, but not buffer clear operations. To enable and disable fog, call {@link glEnable} and {@link glDisable} with argument {@link GL_FOG}.
 *
 * `glFog` assigns the value or values in **params** to the fog parameter specified by **pname**. The following values are accepted for **pname**:
 *
 * - {@link GL_FOG_MODE}
 * **params** is a single integer or floating-point value that specifies the equation to be used to compute the fog blend factor, ƒ. Three symbolic constants are accepted: {@link GL_LINEAR}, {@link GL_EXP}, and {@link GL_EXP2}. The equations corresponding to these symbolic constants are defined below. The initial fog mode is {@link GL_EXP}.
 *
 * - {@link GL_FOG_DENSITY}
 *  **params** is a single integer or floating-point value that specifies *density*, the fog density used in both exponential fog equations. Only nonnegative densities are accepted. The initial fog density is 1.
 *
 * - {@link GL_FOG_START}
 *  **params** is a single integer or floating-point value that specifies *start*, the near distance used in the linear fog equation. The initial near distance is 0.
 *
 * - {@link GL_FOG_END}
 *  **params** is a single integer or floating-point value that specifies *end*, the far distance used in the linear fog equation. The initial far distance is 1.
 *
 * - {@link GL_FOG_INDEX}
 *
 *  **params** is a single integer or floating-point value that specifies 𝐢𝑓, the fog color index. The initial fog index is 0.
 *
 * - {@link GL_FOG_COLOR}
 *  **params** contains four integer or floating-point values that specify 𝐂𝑓, the fog color. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. After conversion, all color components are clamped to the range [0,1]. The initial fog color is (0, 0, 0, 0).
 *
 * - {@link GL_FOG_COORD_SRC}
 * **params** contains either of the following symbolic constants: {@link GL_FOG_COORD} or {@link GL_FRAGMENT_DEPTH}. {@link GL_FOG_COORD} specifies that the current fog coordinate should be used as distance value in the fog color computation. {@link GL_FRAGMENT_DEPTH} specifies that the current fragment depth should be used as distance value in the fog computation.
 *
 *  Fog blends a fog color with each rasterized pixel fragment's post-texturing color using a blending factor ƒ. Factor ƒ is computed in one of three ways, depending on the fog mode. Let 𝐂 be either the distance in eye coordinate from the origin (in the case that the {@link GL_FOG_COORD_SRC} is {@link GL_FRAGMENT_DEPTH}) or the current fog coordinate (in the case that {@link GL_FOG_COORD_SRC} is {@link GL_FOG_COORD}). The equation for {@link GL_LINEAR} fog is
 *
 * ƒ = end − 𝐂 / end − start
 *
 * The equation for {@link GL_EXP} fog is
 *
 * ƒ = 𝐞 ^ −(density⋅𝐂)
 *
 * The equation for {@link GL_EXP2} fog is
 *
 * ƒ = 𝐞 ^ −(density⋅𝐂)²
 *
 * Regardless of the fog mode, ƒ is clamped to the range [0,1] after it is computed. Then, if the GL is in RGBA color mode, the fragment's red, green, and blue colors, represented by 𝐂ᵣ, are replaced by
 *
 * 𝐂ᵣ′′ = ƒ × 𝐂ᵣ + (1 − ƒ) × 𝐂𝑓
 *
 * Fog does not affect a fragment's alpha component.
 *
 * In color index mode, the fragment's color index 𝐢ᵣ is replaced by
 *
 * 𝐢ᵣ′′ = 𝐢ᵣ + (1 − ƒ) × 𝐢𝑓
 *
 * @summary specify fog parameters
 * @param pname Specifies a single-valued fog parameter. {@link GL_FOG_MODE}, {@link GL_FOG_DENSITY}, {@link GL_FOG_START}, {@link GL_FOG_END}, {@link GL_FOG_INDEX}, and {@link GL_FOG_COORD_SRC} are accepted.
 * @param param Specifies the value that **pname** will be set to.
 * @see [glFog](https://docs.gl/gl3/glFog)
 */
export function glFogi(pname: GLenum, param: GLint): void;

/**
 * Fog is initially disabled. While enabled, fog affects rasterized geometry, bitmaps, and pixel blocks, but not buffer clear operations. To enable and disable fog, call {@link glEnable} and {@link glDisable} with argument {@link GL_FOG}.
 *
 * `glFog` assigns the value or values in **params** to the fog parameter specified by **pname**. The following values are accepted for **pname**:
 *
 * - {@link GL_FOG_MODE}
 * **params** is a single integer or floating-point value that specifies the equation to be used to compute the fog blend factor, ƒ. Three symbolic constants are accepted: {@link GL_LINEAR}, {@link GL_EXP}, and {@link GL_EXP2}. The equations corresponding to these symbolic constants are defined below. The initial fog mode is {@link GL_EXP}.
 *
 * - {@link GL_FOG_DENSITY}
 *  **params** is a single integer or floating-point value that specifies *density*, the fog density used in both exponential fog equations. Only nonnegative densities are accepted. The initial fog density is 1.
 *
 * - {@link GL_FOG_START}
 *  **params** is a single integer or floating-point value that specifies *start*, the near distance used in the linear fog equation. The initial near distance is 0.
 *
 * - {@link GL_FOG_END}
 *  **params** is a single integer or floating-point value that specifies *end*, the far distance used in the linear fog equation. The initial far distance is 1.
 *
 * - {@link GL_FOG_INDEX}
 *
 *  **params** is a single integer or floating-point value that specifies 𝐢𝑓, the fog color index. The initial fog index is 0.
 *
 * - {@link GL_FOG_COLOR}
 *  **params** contains four integer or floating-point values that specify 𝐂𝑓, the fog color. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. After conversion, all color components are clamped to the range [0,1]. The initial fog color is (0, 0, 0, 0).
 *
 * - {@link GL_FOG_COORD_SRC}
 * **params** contains either of the following symbolic constants: {@link GL_FOG_COORD} or {@link GL_FRAGMENT_DEPTH}. {@link GL_FOG_COORD} specifies that the current fog coordinate should be used as distance value in the fog color computation. {@link GL_FRAGMENT_DEPTH} specifies that the current fragment depth should be used as distance value in the fog computation.
 *
 *  Fog blends a fog color with each rasterized pixel fragment's post-texturing color using a blending factor ƒ. Factor ƒ is computed in one of three ways, depending on the fog mode. Let 𝐂 be either the distance in eye coordinate from the origin (in the case that the {@link GL_FOG_COORD_SRC} is {@link GL_FRAGMENT_DEPTH}) or the current fog coordinate (in the case that {@link GL_FOG_COORD_SRC} is {@link GL_FOG_COORD}). The equation for {@link GL_LINEAR} fog is
 *
 * ƒ = end − 𝐂 / end − start
 *
 * The equation for {@link GL_EXP} fog is
 *
 * ƒ = 𝐞 ^ −(density⋅𝐂)
 *
 * The equation for {@link GL_EXP2} fog is
 *
 * ƒ = 𝐞 ^ −(density⋅𝐂)²
 *
 * Regardless of the fog mode, ƒ is clamped to the range [0,1] after it is computed. Then, if the GL is in RGBA color mode, the fragment's red, green, and blue colors, represented by 𝐂ᵣ, are replaced by
 *
 * 𝐂ᵣ′′ = ƒ × 𝐂ᵣ + (1 − ƒ) × 𝐂𝑓
 *
 * Fog does not affect a fragment's alpha component.
 *
 * In color index mode, the fragment's color index 𝐢ᵣ is replaced by
 *
 * 𝐢ᵣ′′ = 𝐢ᵣ + (1 − ƒ) × 𝐢𝑓
 *
 * @summary specify fog parameters
 * @param pname Specifies a fog parameter. {@link GL_FOG_MODE}, {@link GL_FOG_DENSITY}, {@link GL_FOG_START}, {@link GL_FOG_END}, {@link GL_FOG_INDEX}, {@link GL_FOG_COLOR}, and {@link GL_FOG_COORD_SRC} are accepted.
 * @param params Specifies the value or values to be assigned to **pname**. {@link GL_FOG_COLOR} requires an array of four values. All other parameters accept an array containing only a single value.
 * @see [glFog](https://docs.gl/gl3/glFog)
 */
export function glFogfv(pname: GLenum, params: GLfloat): void;

/**
 * Fog is initially disabled. While enabled, fog affects rasterized geometry, bitmaps, and pixel blocks, but not buffer clear operations. To enable and disable fog, call {@link glEnable} and {@link glDisable} with argument {@link GL_FOG}.
 *
 * `glFog` assigns the value or values in **params** to the fog parameter specified by **pname**. The following values are accepted for **pname**:
 *
 * - {@link GL_FOG_MODE}
 * **params** is a single integer or floating-point value that specifies the equation to be used to compute the fog blend factor, ƒ. Three symbolic constants are accepted: {@link GL_LINEAR}, {@link GL_EXP}, and {@link GL_EXP2}. The equations corresponding to these symbolic constants are defined below. The initial fog mode is {@link GL_EXP}.
 *
 * - {@link GL_FOG_DENSITY}
 *  **params** is a single integer or floating-point value that specifies *density*, the fog density used in both exponential fog equations. Only nonnegative densities are accepted. The initial fog density is 1.
 *
 * - {@link GL_FOG_START}
 *  **params** is a single integer or floating-point value that specifies *start*, the near distance used in the linear fog equation. The initial near distance is 0.
 *
 * - {@link GL_FOG_END}
 *  **params** is a single integer or floating-point value that specifies *end*, the far distance used in the linear fog equation. The initial far distance is 1.
 *
 * - {@link GL_FOG_INDEX}
 *
 *  **params** is a single integer or floating-point value that specifies 𝐢𝑓, the fog color index. The initial fog index is 0.
 *
 * - {@link GL_FOG_COLOR}
 *  **params** contains four integer or floating-point values that specify 𝐂𝑓, the fog color. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. After conversion, all color components are clamped to the range [0,1]. The initial fog color is (0, 0, 0, 0).
 *
 * - {@link GL_FOG_COORD_SRC}
 * **params** contains either of the following symbolic constants: {@link GL_FOG_COORD} or {@link GL_FRAGMENT_DEPTH}. {@link GL_FOG_COORD} specifies that the current fog coordinate should be used as distance value in the fog color computation. {@link GL_FRAGMENT_DEPTH} specifies that the current fragment depth should be used as distance value in the fog computation.
 *
 *  Fog blends a fog color with each rasterized pixel fragment's post-texturing color using a blending factor ƒ. Factor ƒ is computed in one of three ways, depending on the fog mode. Let 𝐂 be either the distance in eye coordinate from the origin (in the case that the {@link GL_FOG_COORD_SRC} is {@link GL_FRAGMENT_DEPTH}) or the current fog coordinate (in the case that {@link GL_FOG_COORD_SRC} is {@link GL_FOG_COORD}). The equation for {@link GL_LINEAR} fog is
 *
 * ƒ = end − 𝐂 / end − start
 *
 * The equation for {@link GL_EXP} fog is
 *
 * ƒ = 𝐞 ^ −(density⋅𝐂)
 *
 * The equation for {@link GL_EXP2} fog is
 *
 * ƒ = 𝐞 ^ −(density⋅𝐂)²
 *
 * Regardless of the fog mode, ƒ is clamped to the range [0,1] after it is computed. Then, if the GL is in RGBA color mode, the fragment's red, green, and blue colors, represented by 𝐂ᵣ, are replaced by
 *
 * 𝐂ᵣ′′ = ƒ × 𝐂ᵣ + (1 − ƒ) × 𝐂𝑓
 *
 * Fog does not affect a fragment's alpha component.
 *
 * In color index mode, the fragment's color index 𝐢ᵣ is replaced by
 *
 * 𝐢ᵣ′′ = 𝐢ᵣ + (1 − ƒ) × 𝐢𝑓
 *
 * @summary specify fog parameters
 * @param pname Specifies a fog parameter. {@link GL_FOG_MODE}, {@link GL_FOG_DENSITY}, {@link GL_FOG_START}, {@link GL_FOG_END}, {@link GL_FOG_INDEX}, {@link GL_FOG_COLOR}, and {@link GL_FOG_COORD_SRC} are accepted.
 * @param params Specifies the value or values to be assigned to **pname**. {@link GL_FOG_COLOR} requires an array of four values. All other parameters accept an array containing only a single value.
 * @see [glFog](https://docs.gl/gl3/glFog)
 */
export function glFogiv(pname: GLenum, params: GLint): void;

/**
 * In a scene composed entirely of opaque closed surfaces, back-facing polygons are never visible. Eliminating these invisible polygons has the obvious benefit of speeding up the rendering of the image. To enable and disable elimination of back-facing polygons, call {@link glEnable} and {@link glDisable} with argument {@link GL_CULL_FACE}.
 *
 * The projection of a polygon to window coordinates is said to have clockwise winding if an imaginary object following the path from its first vertex, its second vertex, and so on, to its last vertex, and finally back to its first vertex, moves in a clockwise direction about the interior of the polygon. The polygon's winding is said to be counterclockwise if the imaginary object following the same path moves in a counterclockwise direction about the interior of the polygon. `glFrontFace` specifies whether polygons with clockwise winding in window coordinates, or counterclockwise winding in window coordinates, are taken to be front-facing. Passing {@link GL_CCW} to **mode** selects counterclockwise polygons as front-facing; {@link GL_CW} selects clockwise polygons as front-facing. By default, counterclockwise polygons are taken to be front-facing.
 *
 * @summary define front- and back-facing polygons
 * @param mode Specifies the orientation of front-facing polygons. {@link GL_CW} and {@link GL_CCW} are accepted. The initial value is {@link GL_CCW}.
 * @see [glFrontFace](https://docs.gl/gl3/glFrontFace)
 */
export function glFrontFace(mode: GLenum): void;

/**
 * `glFrustum` describes a perspective matrix that produces a perspective projection. The current matrix (see {@link glMatrixMode}) is multiplied by this matrix and the result replaces the current matrix, as if {@link glMultMatrix} were called with the following matrix as its argument:
 *
 * ⎡ㅤ2 nearVal / right − leftㅤㅤㅤㅤㅤㅤㅤㅤㅤ0ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ𝐀ㅤㅤㅤㅤ0ㅤ⎤
 *
 * ⎢ㅤㅤㅤㅤㅤㅤㅤ0ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ2 nearVal / right − leftㅤㅤㅤ𝐁ㅤㅤㅤㅤ0ㅤ⎥
 *
 * ⎢ㅤㅤㅤㅤㅤㅤㅤ0ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ0ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ𝐂ㅤㅤㅤㅤ𝐃ㅤ⎥
 *
 * ⎣ㅤㅤㅤㅤㅤㅤㅤ0ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ0ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ−1ㅤㅤㅤㅤ0ㅤ⎦
 *
 * 𝐀 = right + left / right - left
 *
 * 𝐁 = top + bottom / top - bottom
 *
 * 𝐂 = −(farVal + nearVal) / farVal - nearVal
 *
 * 𝐃 = −2 farVal × nearVal / farVal - nearVal
 *
 * Typically, the matrix mode is {@link GL_PROJECTION}, and (*left*, *bottom*, −*nearVal*) and (*right*, *top*, −*nearVal*) specify the points on the near clipping plane that are mapped to the lower left and upper right corners of the window, assuming that the eye is located at (0, 0, 0). −*farVal* specifies the location of the far clipping plane. Both **nearVal** and **farVal** must be positive.
 *
 * Use {@link glPushMatrix} and {@link glPopMatrix} to save and restore the current matrix stack.
 *
 * @summary multiply the current matrix by a perspective matrix
 * @param left Specifies the coordinate for the left vertical clipping plane.
 * @param right Specifies the coordinate for the right vertical clipping plane.
 * @param bottom Specifies the coordinate for the bottom horizontal clipping plane.
 * @param top Specifies the coordinate for the top horizontal clipping plane.
 * @param nearVal Specifies the distance to the near depth clipping plane. Must be positive.
 * @param farVal Specifies the distance to the far depth clipping plane. Must be positive.
 * @tutorial [Songho - OpenGL Matrix Class (C++)](https://www.songho.ca/opengl/gl_matrix.html)
 * @see [glFrustum](https://docs.gl/gl3/glFrustum)
 */
export function glFrustum(
	left: GLdouble,
	right: GLdouble,
	bottom: GLdouble,
	top: GLdouble,
	nearVal: GLdouble,
	farVal: GLdouble
): void;

/**
 * `glGenLists` has one argument, **range**. It returns an integer **n** such that **range** contiguous empty display lists, named 𝐧, 𝐧 + 1, ..., 𝐧 + *range* − 1, are created. If **range** is 0, if there is no group of **range** contiguous names available, or if any error is generated, no display lists are generated, and 0 is returned.
 *
 * @summary generate a contiguous set of empty display lists
 * @param range Specifies the number of contiguous empty display lists to be generated.
 * @see [glGenLists](https://docs.gl/gl3/glGenLists)
 */
export function glGenLists(range: GLsizei): GLuint;

/**
 * `glGenTextures` returns **n** texture names in **textures**. There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to `glGenTextures`.
 *
 * The generated textures have no dimensionality; they assume the dimensionality of the texture target to which they are first bound (see {@link glBindTexture}).
 *
 * Texture names returned by a call to `glGenTextures` are not returned by subsequent calls, unless they are first deleted with {@link glDeleteTextures}.
 *
 * @summary generate texture names
 * @param n Specifies the number of texture names to be generated.
 * @param textures Specifies an array in which the generated texture names are stored.
 * @tutorial [open.gl - Framebuffers](https://open.gl/framebuffers)
 * @tutorial [opengl-tutorial.org - Tutorial 14 : Render To Texture](https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-14-render-to-texture/)
 * @tutorial [opengl-tutorial.org - Tutorial 16 : Shadow mapping](https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/)
 * @tutorial [opengl-tutorial.org - Tutorial 5 : A Textured Cube](https://www.opengl-tutorial.org/beginners-tutorials/tutorial-5-a-textured-cube/)
 * @see [glGenTextures](https://docs.gl/gl3/glGenTextures)
 */
export function glGenTextures(n: GLsizei, textures: GLuint): void;

/**
 * These four commands return values for simple state variables in GL. **pname** is a symbolic constant indicating the state variable to be returned, and **params** is a pointer to an array of the indicated type in which to place the returned data.
 *
 * Type conversion is performed if **params** has a different type than the state variable value being requested. If `glGetBooleanv` is called, a floating-point (or integer) value is converted to {@link GL_FALSE} if and only if it is 0.0 (or 0). Otherwise, it is converted to {@link GL_TRUE}. If `glGetIntegerv` is called, boolean values are returned as {@link GL_TRUE} or {@link GL_FALSE}, and most floating-point values are rounded to the nearest integer value. Floating-point colors and normals, however, are returned with a linear mapping that maps 1.0 to the most positive representable integer value and −1.0 to the most negative representable integer value. If `glGetFloatv` or `glGetDoublev` is called, boolean values are returned as {@link GL_TRUE} or {@link GL_FALSE}, and integer values are converted to floating-point values.
 *
 * The following symbolic constants are accepted by **pname**:
 *
 * - {@link GL_ACTIVE_TEXTURE}
 * **params** returns a single value indicating the active multitexture unit. The initial value is {@link GL_TEXTURE0}. See {@link glActiveTexture}.
 *
 * - {@link GL_ALIASED_LINE_WIDTH_RANGE}
 * **params** returns a pair of values indicating the range of widths supported for aliased lines. See {@link glLineWidth}.
 *
 * - {@link GL_SMOOTH_LINE_WIDTH_RANGE}
 * **params** returns a pair of values indicating the range of widths supported for smooth (antialiased) lines. See {@link glLineWidth}.
 *
 * - {@link GL_SMOOTH_LINE_WIDTH_GRANULARITY}
 * **params** returns a single value indicating the level of quantization applied to smooth line width parameters.
 *
 * - {@link GL_ARRAY_BUFFER_BINDING}
 * **params** returns a single value, the name of the buffer object currently bound to the target {@link GL_ARRAY_BUFFER}. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See {@link glBindBuffer}.
 *
 * - {@link GL_BLEND}
 * **params** returns a single boolean value indicating whether blending is enabled. The initial value is {@link GL_FALSE}. See {@link glBlendFunc}.
 *
 * - {@link GL_BLEND_COLOR}
 * **params** returns four values, the red, green, blue, and alpha values which are the components of the blend color. See {@link glBlendColor}.
 *
 * - {@link GL_BLEND_DST_ALPHA}
 * **params** returns one value, the symbolic constant identifying the alpha destination blend function. The initial value is {@link GL_ZERO}. See {@link glBlendFunc} and {@link glBlendFuncSeparate}.
 *
 * - {@link GL_BLEND_DST_RGB}
 * **params** returns one value, the symbolic constant identifying the RGB destination blend function. The initial value is {@link GL_ZERO}. See {@link glBlendFunc} and {@link glBlendFuncSeparate}.
 *
 * - {@link GL_BLEND_EQUATION_RGB}
 * **params** returns one value, a symbolic constant indicating whether the RGB blend equation is {@link GL_FUNC_ADD}, {@link GL_FUNC_SUBTRACT}, {@link GL_FUNC_REVERSE_SUBTRACT}, {@link GL_MIN} or {@link GL_MAX}. See {@link glBlendEquationSeparate}.
 *
 * - {@link GL_BLEND_EQUATION_ALPHA}
 * **params** returns one value, a symbolic constant indicating whether the Alpha blend equation is {@link GL_FUNC_ADD}, {@link GL_FUNC_SUBTRACT}, {@link GL_FUNC_REVERSE_SUBTRACT}, {@link GL_MIN} or {@link GL_MAX}. See {@link glBlendEquationSeparate}.
 *
 * - {@link GL_BLEND_SRC_ALPHA}
 * **params** returns one value, the symbolic constant identifying the alpha source blend function. The initial value is {@link GL_ONE}. See {@link glBlendFunc} and {@link glBlendFuncSeparate}.
 *
 * - {@link GL_BLEND_SRC_RGB}
 * **params** returns one value, the symbolic constant identifying the RGB source blend function. The initial value is {@link GL_ONE}. See {@link glBlendFunc} and {@link glBlendFuncSeparate}.
 *
 * - {@link GL_COLOR_CLEAR_VALUE}
 * **params** returns four values: the red, green, blue, and alpha values used to clear the color buffers. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and −1.0 returns the most negative representable integer value. The initial value is (0, 0, 0, 0). See {@link glClearColor}.
 *
 * - {@link GL_COLOR_LOGIC_OP}
 * **params** returns a single boolean value indicating whether a fragment's RGBA color values are merged into the framebuffer using a logical operation. The initial value is {@link GL_FALSE}. See {@link glLogicOp}.
 *
 * - {@link GL_COLOR_WRITEMASK}
 * **params** returns four boolean values: the red, green, blue, and alpha write enables for the color buffers. The initial value is ({@link GL_TRUE}, {@link GL_TRUE}, {@link GL_TRUE}, {@link GL_TRUE}). See {@link glColorMask}.
 *
 * - {@link GL_COMPRESSED_TEXTURE_FORMATS}
 * **params** returns a list of symbolic constants of length {@link GL_NUM_COMPRESSED_TEXTURE_FORMATS} indicating which compressed texture formats are available. See {@link glCompressedTexImage2D}.
 *
 * - {@link GL_CULL_FACE}
 * **params** returns a single boolean value indicating whether polygon culling is enabled. The initial value is {@link GL_FALSE}. See {@link glCullFace}.
 *
 * - {@link GL_CURRENT_PROGRAM}
 * **params** returns one value, the name of the program object that is currently active, or 0 if no program object is active. See {@link glUseProgram}.
 *
 * - {@link GL_DEPTH_CLEAR_VALUE}
 * **params** returns one value, the value that is used to clear the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. The initial value is 1. See {@link glClearDepth}.
 *
 * - {@link GL_DEPTH_FUNC}
 * **params** returns one value, the symbolic constant that indicates the depth comparison function. The initial value is {@link GL_LESS}. See {@link glDepthFunc}.
 *
 * - {@link GL_DEPTH_RANGE}
 * **params** returns two values: the near and far mapping limits for the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and −1.0 returns the most negative representable integer value. The initial value is (0, 1). See {@link glDepthRange}.
 *
 * - {@link GL_DEPTH_TEST}
 * **params** returns a single boolean value indicating whether depth testing of fragments is enabled. The initial value is {@link GL_FALSE}. See {@link glDepthFunc} and {@link glDepthRange}.
 *
 * - {@link GL_DEPTH_WRITEMASK}
 * **params** returns a single boolean value indicating if the depth buffer is enabled for writing. The initial value is {@link GL_TRUE}. See {@link glDepthMask}.
 *
 * - {@link GL_DITHER}
 * **params** returns a single boolean value indicating whether dithering of fragment colors and indices is enabled. The initial value is {@link GL_TRUE}.
 *
 * - {@link GL_DOUBLEBUFFER}
 * **params** returns a single boolean value indicating whether double buffering is supported.
 *
 * - {@link GL_DRAW_BUFFER}
 * **params** returns one value, a symbolic constant indicating which buffers are being drawn to. See {@link glDrawBuffer}. The initial value is {@link GL_BACK} if there are back buffers, otherwise it is {@link GL_FRONT}.
 *
 * - {@link GL_DRAW_BUFFER}**i**
 * **params** returns one value, a symbolic constant indicating which buffers are being drawn to by the corresponding output color. See {@link glDrawBuffers}. The initial value of {@link GL_DRAW_BUFFER0} is {@link GL_BACK} if there are back buffers, otherwise it is {@link GL_FRONT}. The initial values of draw buffers for all other output colors is {@link GL_NONE}.
 *
 * - {@link GL_DRAW_FRAMEBUFFER_BINDING}
 * **params** returns one value, the name of the framebuffer object currently bound to the {@link GL_DRAW_FRAMEBUFFER} target. If the default framebuffer is bound, this value will be zero. The initial value is zero. See {@link glBindFramebuffer}.
 *
 * - {@link GL_READ_FRAMEBUFFER_BINDING}
 * **params** returns one value, the name of the framebuffer object currently bound to the {@link GL_READ_FRAMEBUFFER} target. If the default framebuffer is bound, this value will be zero. The initial value is zero. See {@link glBindFramebuffer}.
 *
 * - {@link GL_ELEMENT_ARRAY_BUFFER_BINDING}
 * **params** returns a single value, the name of the buffer object currently bound to the target {@link GL_ELEMENT_ARRAY_BUFFER}. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See {@link glBindBuffer}.
 *
 * - {@link GL_RENDERBUFFER_BINDING}
 * **params** returns a single value, the name of the renderbuffer object currently bound to the target {@link GL_RENDERBUFFER}. If no renderbuffer object is bound to this target, 0 is returned. The initial value is 0. See {@link glBindRenderbuffer}.
 *
 * - {@link GL_FRAGMENT_SHADER_DERIVATIVE_HINT}
 * **params** returns one value, a symbolic constant indicating the mode of the derivative accuracy hint for fragment shaders. The initial value is {@link GL_DONT_CARE}. See {@link glHint}.
 *
 * - {@link GL_LINE_SMOOTH}
 * **params** returns a single boolean value indicating whether antialiasing of lines is enabled. The initial value is {@link GL_FALSE}. See {@link glLineWidth}.
 *
 * - {@link GL_LINE_SMOOTH_HINT}
 * **params** returns one value, a symbolic constant indicating the mode of the line antialiasing hint. The initial value is {@link GL_DONT_CARE}. See {@link glHint}.
 *
 * - {@link GL_LINE_WIDTH}
 * **params** returns one value, the line width as specified with {@link glLineWidth}. The initial value is 1.
 *
 * - {@link GL_LOGIC_OP_MODE}
 * **params** returns one value, a symbolic constant indicating the selected logic operation mode. The initial value is {@link GL_COPY}. See {@link glLogicOp}.
 *
 * - {@link GL_MAX_3D_TEXTURE_SIZE}
 * **params** returns one value, a rough estimate of the largest 3D texture that the GL can handle. The value must be at least 64. Use {@link GL_PROXY_TEXTURE_3D} to determine if a texture is too large. See {@link glTexImage3D}.
 *
 * - {@link GL_MAX_CLIP_DISTANCES}
 * **params** returns one value, the maximum number of application-defined clipping distances. The value must be at least 8.
 *
 * - {@link GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS}
 * **params** returns one value, the number of words for fragment shader uniform variables in all uniform blocks (including default). The value must be at least 1. See {@link glUniform}.
 *
 * - {@link GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS}
 * **params** returns one value, the maximum supported texture image units that can be used to access texture maps from the vertex shader and the fragment processor combined. If both the vertex shader and the fragment processing stage access the same texture image unit, then that counts as using two texture image units against this limit. The value must be at least 48. See {@link glActiveTexture}.
 *
 * - {@link GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS}
 * **params** returns one value, the number of words for vertex shader uniform variables in all uniform blocks (including default). The value must be at least 1. See {@link glUniform}.
 *
 * - {@link GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS}
 * **params** returns one value, the number of words for geometry shader uniform variables in all uniform blocks (including default). The value must be at least 1. See {@link glUniform}.
 *
 * - {@link GL_MAX_VARYING_COMPONENTS}
 * **params** returns one value, the number components for varying variables, which must be at least 60.
 *
 * - {@link GL_MAX_COMBINED_UNIFORM_BLOCKS}
 * **params** returns one value, the maximum number of uniform blocks per program. The value must be at least 36. See {@link glUniformBlockBinding}.
 *
 * - {@link GL_MAX_CUBE_MAP_TEXTURE_SIZE}
 * **params** returns one value. The value gives a rough estimate of the largest cube-map texture that the GL can handle. The value must be at least 1024. Use {@link GL_PROXY_TEXTURE_CUBE_MAP} to determine if a texture is too large. See {@link glTexImage2D}.
 *
 * - {@link GL_MAX_DRAW_BUFFERS}
 * **params** returns one value, the maximum number of simultaneous outputs that may be written in a fragment shader. The value must be at least 8. See {@link glDrawBuffers}.
 *
 * - {@link GL_MAX_DUAL_SOURCE_DRAW_BUFFERS}
 * **params** returns one value, the maximum number of active draw buffers when using dual-source blending. The value must be at least 1. See {@link glBlendFunc} and {@link glBlendFuncSeparate}.
 *
 * - {@link GL_MAX_ELEMENTS_INDICES}
 * **params** returns one value, the recommended maximum number of vertex array indices. See {@link glDrawRangeElements}.
 *
 * - {@link GL_MAX_ELEMENTS_VERTICES}
 * **params** returns one value, the recommended maximum number of vertex array vertices. See {@link glDrawRangeElements}.
 *
 * - {@link GL_MAX_FRAGMENT_UNIFORM_COMPONENTS}
 * **params** returns one value, the maximum number of individual floating-point, integer, or boolean values that can be held in uniform variable storage for a fragment shader. The value must be at least 1024. See {@link glUniform}.
 *
 * - {@link GL_MAX_FRAGMENT_UNIFORM_BLOCKS}
 * **params** returns one value, the maximum number of uniform blocks per fragment shader. The value must be at least 12. See {@link glUniformBlockBinding}.
 *
 * - {@link GL_MAX_FRAGMENT_INPUT_COMPONENTS}
 * **params** returns one value, the maximum number of components of the inputs read by the fragment shader, which must be at least 128.
 *
 * - {@link GL_MIN_PROGRAM_TEXEL_OFFSET}
 * **params** returns one value, the minimum texel offset allowed in a texture lookup, which must be at most -8.
 *
 * - {@link GL_MAX_PROGRAM_TEXEL_OFFSET}
 * **params** returns one value, the maximum texel offset allowed in a texture lookup, which must be at least 7.
 *
 * - {@link GL_MAX_RECTANGLE_TEXTURE_SIZE}
 * **params** returns one value. The value gives a rough estimate of the largest rectangular texture that the GL can handle. The value must be at least 1024. Use {@link GL_PROXY_TEXTURE_RECTANGLE} to determine if a texture is too large. See {@link glTexImage2D}.
 *
 * - {@link GL_MAX_TEXTURE_IMAGE_UNITS}
 * **params** returns one value, the maximum supported texture image units that can be used to access texture maps from the fragment shader. The value must be at least 16. See {@link glActiveTexture}.
 *
 * - {@link GL_MAX_TEXTURE_LOD_BIAS}
 * **params** returns one value, the maximum, absolute value of the texture level-of-detail bias. The value must be at least 2.0.
 *
 * - {@link GL_MAX_TEXTURE_SIZE}
 * **params** returns one value. The value gives a rough estimate of the largest texture that the GL can handle. The value must be at least 1024. Use a proxy texture target such as {@link GL_PROXY_TEXTURE_1D} or {@link GL_PROXY_TEXTURE_2D} to determine if a texture is too large. See {@link glTexImage1D} and {@link glTexImage2D}.
 *
 * - {@link GL_MAX_RENDERBUFFER_SIZE}
 * **params** returns one value. The value indicates the maximum supported size for renderbuffers. See {@link glFramebufferRenderbuffer}.
 *
 * - {@link GL_MAX_ARRAY_TEXTURE_LAYERS}
 * **params** returns one value. The value indicates the maximum number of layers allowed in an array texture, and must be at least 256. See {@link glTexImage2D}.
 *
 * - {@link GL_MAX_TEXTURE_BUFFER_SIZE}
 * **params** returns one value. The value gives the maximum number of texels allowed in the texel array of a texture buffer object. Value must be at least 65536.
 *
 * - {@link GL_MAX_UNIFORM_BLOCK_SIZE}
 * **params** returns one value, the maximum size in basic machine units of a uniform block. The value must be at least 16384. See {@link glUniformBlockBinding}.
 *
 * - {@link GL_MAX_VARYING_FLOATS}
 * **params** returns one value, the maximum number of interpolators available for processing varying variables used by vertex and fragment shaders. This value represents the number of individual floating-point values that can be interpolated; varying variables declared as vectors, matrices, and arrays will all consume multiple interpolators. The value must be at least 32.
 *
 * - {@link GL_MAX_VERTEX_ATTRIBS}
 * **params** returns one value, the maximum number of 4-component generic vertex attributes accessible to a vertex shader. The value must be at least 16. See {@link glVertexAttrib}.
 *
 * - {@link GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS}
 * **params** returns one value, the maximum supported texture image units that can be used to access texture maps from the vertex shader. The value may be at least 16. See {@link glActiveTexture}.
 *
 * - {@link GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS}
 * **params** returns one value, the maximum supported texture image units that can be used to access texture maps from the geometry shader. The value must be at least 16. See {@link glActiveTexture}.
 *
 * - {@link GL_MAX_VERTEX_UNIFORM_COMPONENTS}
 * **params** returns one value, the maximum number of individual floating-point, integer, or boolean values that can be held in uniform variable storage for a vertex shader. The value must be at least 1024. See {@link glUniform}.
 *
 * - {@link GL_MAX_VERTEX_OUTPUT_COMPONENTS}
 * **params** returns one value, the maximum number of components of output written by a vertex shader, which must be at least 64.
 *
 * - {@link GL_MAX_GEOMETRY_UNIFORM_COMPONENTS}
 * **params** returns one value, the maximum number of individual floating-point, integer, or boolean values that can be held in uniform variable storage for a geometry shader. The value must be at least 1024. See {@link glUniform}.
 *
 * - {@link GL_MAX_SAMPLE_MASK_WORDS}
 * **params** returns one value, the maximum number of sample mask words.
 *
 * - {@link GL_MAX_COLOR_TEXTURE_SAMPLES}
 * **params** returns one value, the maximum number of samples in a color multisample texture.
 *
 * - {@link GL_MAX_DEPTH_TEXTURE_SAMPLES}
 * **params** returns one value, the maximum number of samples in a multisample depth or depth-stencil texture.
 *
 * - {@link GL_MAX_DEPTH_TEXTURE_SAMPLES}
 * **params** returns one value, the maximum number of samples in a multisample depth or depth-stencil texture.
 *
 * - {@link GL_MAX_INTEGER_SAMPLES}
 * **params** returns one value, the maximum number of samples supported in integer format multisample buffers.
 *
 * - {@link GL_MAX_SERVER_WAIT_TIMEOUT}
 * **params** returns one value, the maximum {@link glWaitSync} timeout interval.
 *
 * - {@link GL_MAX_UNIFORM_BUFFER_BINDINGS}
 * **params** returns one value, the maximum number of uniform buffer binding points on the context, which must be at least 36.
 *
 * - {@link GL_MAX_UNIFORM_BLOCK_SIZE}
 * **params** returns one value, the maximum size in basic machine units of a uniform block, which must be at least 16384.
 *
 * - {@link GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT}
 * **params** returns one value, the minimum required alignment for uniform buffer sizes and offsets.
 *
 * - {@link GL_MAX_VERTEX_UNIFORM_BLOCKS}
 * **params** returns one value, the maximum number of uniform blocks per vertex shader. The value must be at least 12. See {@link glUniformBlockBinding}.
 *
 * - {@link GL_MAX_GEOMETRY_UNIFORM_BLOCKS}
 * **params** returns one value, the maximum number of uniform blocks per geometry shader. The value must be at least 12. See {@link glUniformBlockBinding}.
 *
 * - {@link GL_MAX_GEOMETRY_INPUT_COMPONENTS}
 * **params** returns one value, the maximum number of components of inputs read by a geometry shader, which must be at least 64.
 *
 * - {@link GL_MAX_GEOMETRY_OUTPUT_COMPONENTS}
 * **params** returns one value, the maximum number of components of outputs written by a geometry shader, which must be at least 128.
 *
 * - {@link GL_MAX_VIEWPORT_DIMS}
 * **params** returns two values: the maximum supported width and height of the viewport. These must be at least as large as the visible dimensions of the display being rendered to. See {@link glViewport}.
 *
 * - {@link GL_NUM_COMPRESSED_TEXTURE_FORMATS}
 * **params** returns a single integer value indicating the number of available compressed texture formats. The minimum value is 4. See {@link glCompressedTexImage2D}.
 *
 * - {@link GL_PACK_ALIGNMENT}
 * **params** returns one value, the byte alignment used for writing pixel data to memory. The initial value is 4. See {@link glPixelStore}.
 *
 * - {@link GL_PACK_IMAGE_HEIGHT}
 * **params** returns one value, the image height used for writing pixel data to memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_PACK_LSB_FIRST}
 * **params** returns a single boolean value indicating whether single-bit pixels being written to memory are written first to the least significant bit of each unsigned byte. The initial value is {@link GL_FALSE}. See {@link glPixelStore}.
 *
 * - {@link GL_PACK_ROW_LENGTH}
 * **params** returns one value, the row length used for writing pixel data to memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_PACK_SKIP_IMAGES}
 * **params** returns one value, the number of pixel images skipped before the first pixel is written into memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_PACK_SKIP_PIXELS}
 * **params** returns one value, the number of pixel locations skipped before the first pixel is written into memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_PACK_SKIP_ROWS}
 * **params** returns one value, the number of rows of pixel locations skipped before the first pixel is written into memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_PACK_SWAP_BYTES}
 * **params** returns a single boolean value indicating whether the bytes of two-byte and four-byte pixel indices and components are swapped before being written to memory. The initial value is {@link GL_FALSE}. See {@link glPixelStore}.
 *
 * - {@link GL_PIXEL_PACK_BUFFER_BINDING}
 * **params** returns a single value, the name of the buffer object currently bound to the target {@link GL_PIXEL_PACK_BUFFER}. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See {@link glBindBuffer}.
 *
 * - {@link GL_PIXEL_UNPACK_BUFFER_BINDING}
 * **params** returns a single value, the name of the buffer object currently bound to the target {@link GL_PIXEL_UNPACK_BUFFER}. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See {@link glBindBuffer}.
 *
 * - {@link GL_POINT_FADE_THRESHOLD_SIZE}
 * **params** returns one value, the point size threshold for determining the point size. See {@link glPointParameter}.
 *
 * - {@link GL_PRIMITIVE_RESTART_INDEX}
 * **params** returns one value, the current primitive restart index. The initial value is 0. See {@link glPrimitiveRestartIndex}.
 *
 * - {@link GL_PROGRAM_POINT_SIZE}
 * **params** returns a single boolean value indicating whether vertex program point size mode is enabled. If enabled, then the point size is taken from the shader built-in gl_PointSize. If disabled, then the point size is taken from the point state as specified by {@link glPointSize}. The initial value is {@link GL_FALSE}.
 *
 * - {@link GL_PROVOKING_VERTEX}
 * **params** returns one value, the currently selected provoking vertex convention. The initial value is {@link GL_LAST_VERTEX_CONVENTION}. See {@link glProvokingVertex}.
 *
 * - {@link GL_POINT_SIZE}
 * **params** returns one value, the point size as specified by {@link glPointSize}. The initial value is 1.
 *
 * - {@link GL_POINT_SIZE_GRANULARITY}
 * **params** returns one value, the size difference between adjacent supported sizes for antialiased points. See {@link glPointSize}.
 *
 * - {@link GL_POINT_SIZE_RANGE}
 * **params** returns two values: the smallest and largest supported sizes for antialiased points. The smallest size must be at most 1, and the largest size must be at least 1. See {@link glPointSize}.
 *
 * - {@link GL_POLYGON_OFFSET_FACTOR}
 * **params** returns one value, the scaling factor used to determine the variable offset that is added to the depth value of each fragment generated when a polygon is rasterized. The initial value is 0. See {@link glPolygonOffset}.
 *
 * - {@link GL_POLYGON_OFFSET_UNITS}
 * **params** returns one value. This value is multiplied by an implementation-specific value and then added to the depth value of each fragment generated when a polygon is rasterized. The initial value is 0. See {@link glPolygonOffset}.
 *
 * - {@link GL_POLYGON_OFFSET_FILL}
 * **params** returns a single boolean value indicating whether polygon offset is enabled for polygons in fill mode. The initial value is {@link GL_FALSE}. See {@link glPolygonOffset}.
 *
 * - {@link GL_POLYGON_OFFSET_LINE}
 * **params** returns a single boolean value indicating whether polygon offset is enabled for polygons in line mode. The initial value is {@link GL_FALSE}. See {@link glPolygonOffset}.
 *
 * - {@link GL_POLYGON_OFFSET_POINT}
 * **params** returns a single boolean value indicating whether polygon offset is enabled for polygons in point mode. The initial value is {@link GL_FALSE}. See {@link glPolygonOffset}.
 *
 * - {@link GL_POLYGON_SMOOTH}
 * **params** returns a single boolean value indicating whether antialiasing of polygons is enabled. The initial value is {@link GL_FALSE}. See {@link glPolygonMode}.
 *
 * - {@link GL_POLYGON_SMOOTH_HINT}
 * **params** returns one value, a symbolic constant indicating the mode of the polygon antialiasing hint. The initial value is {@link GL_DONT_CARE}. See {@link glHint}.
 *
 * - {@link GL_READ_BUFFER}
 * **params** returns one value, a symbolic constant indicating which color buffer is selected for reading. The initial value is {@link GL_BACK} if there is a back buffer, otherwise it is {@link GL_FRONT}. See {@link glReadPixels}.
 *
 * - {@link GL_SAMPLE_BUFFERS}
 * **params** returns a single integer value indicating the number of sample buffers associated with the framebuffer. See {@link glSampleCoverage}.
 *
 * - {@link GL_SAMPLE_COVERAGE_VALUE}
 * **params** returns a single positive floating-point value indicating the current sample coverage value. See {@link glSampleCoverage}.
 *
 * - {@link GL_SAMPLE_COVERAGE_INVERT}
 * **params** returns a single boolean value indicating if the temporary coverage value should be inverted. See {@link glSampleCoverage}.
 *
 * - {@link GL_SAMPLER_BINDING}
 * **params** returns a single value, the name of the sampler object currently bound to the active texture unit. The initial value is 0. See {@link glBindSampler}.
 *
 * - {@link GL_SAMPLES}
 * **params** returns a single integer value indicating the coverage mask size. See {@link glSampleCoverage}.
 *
 * - {@link GL_SCISSOR_BOX}
 * **params** returns four values: the 𝐱 and 𝐲 window coordinates of the scissor box, followed by its width and height. Initially the 𝐱 and 𝐲 window coordinates are both 0 and the *width* and *height* are set to the size of the window. See {@link glScissor}.
 *
 * - {@link GL_SCISSOR_TEST}
 * **params** returns a single boolean value indicating whether scissoring is enabled. The initial value is {@link GL_FALSE}. See {@link glScissor}.
 *
 * - {@link GL_STENCIL_BACK_FAIL}
 * **params** returns one value, a symbolic constant indicating what action is taken for back-facing polygons when the stencil test fails. The initial value is {@link GL_KEEP}. See {@link glStencilOpSeparate}.
 *
 * - {@link GL_STENCIL_BACK_FUNC}
 * **params** returns one value, a symbolic constant indicating what function is used for back-facing polygons to compare the stencil reference value with the stencil buffer value. The initial value is {@link GL_ALWAYS}. See {@link glStencilFuncSeparate}.
 *
 * - {@link GL_STENCIL_BACK_PASS_DEPTH_FAIL}
 * **params** returns one value, a symbolic constant indicating what action is taken for back-facing polygons when the stencil test passes, but the depth test fails. The initial value is {@link GL_KEEP}. See {@link glStencilOpSeparate}.
 *
 * - {@link GL_STENCIL_BACK_PASS_DEPTH_PASS}
 * **params** returns one value, a symbolic constant indicating what action is taken for back-facing polygons when the stencil test passes and the depth test passes. The initial value is {@link GL_KEEP}. See {@link glStencilOpSeparate}.
 *
 * - {@link GL_STENCIL_BACK_REF}
 * **params** returns one value, the reference value that is compared with the contents of the stencil buffer for back-facing polygons. The initial value is 0. See {@link glStencilFuncSeparate}.
 *
 * - {@link GL_STENCIL_BACK_VALUE_MASK}
 * **params** returns one value, the mask that is used for back-facing polygons to mask both the stencil reference value and the stencil buffer value before they are compared. The initial value is all 1's. See {@link glStencilFuncSeparate}.
 *
 * - {@link GL_STENCIL_BACK_WRITEMASK}
 * **params** returns one value, the mask that controls writing of the stencil bitplanes for back-facing polygons. The initial value is all 1's. See {@link glStencilMaskSeparate}.
 *
 * - {@link GL_STENCIL_CLEAR_VALUE}
 * **params** returns one value, the index to which the stencil bitplanes are cleared. The initial value is 0. See {@link glClearStencil}.
 *
 * - {@link GL_STENCIL_FAIL}
 * **params** returns one value, a symbolic constant indicating what action is taken when the stencil test fails. The initial value is {@link GL_KEEP}. See {@link glStencilOp}. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See {@link glStencilOpSeparate}.
 *
 * - {@link GL_STENCIL_FUNC}
 * **params** returns one value, a symbolic constant indicating what function is used to compare the stencil reference value with the stencil buffer value. The initial value is {@link GL_ALWAYS}. See {@link glStencilFunc}. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See {@link glStencilFuncSeparate}.
 *
 * - {@link GL_STENCIL_PASS_DEPTH_FAIL}
 * **params** returns one value, a symbolic constant indicating what action is taken when the stencil test passes, but the depth test fails. The initial value is {@link GL_KEEP}. See {@link glStencilOp}. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See {@link glStencilOpSeparate}.
 *
 * - {@link GL_STENCIL_PASS_DEPTH_PASS}
 * **params** returns one value, a symbolic constant indicating what action is taken when the stencil test passes and the depth test passes. The initial value is {@link GL_KEEP}. See {@link glStencilOp}. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See {@link glStencilOpSeparate}.
 *
 * - {@link GL_STENCIL_REF}
 * **params** returns one value, the reference value that is compared with the contents of the stencil buffer. The initial value is 0. See {@link glStencilFunc}. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See {@link glStencilFuncSeparate}.
 *
 * - {@link GL_STENCIL_TEST}
 * **params** returns a single boolean value indicating whether stencil testing of fragments is enabled. The initial value is {@link GL_FALSE}. See {@link glStencilFunc} and {@link glStencilOp}.
 *
 * - {@link GL_STENCIL_VALUE_MASK}
 * **params** returns one value, the mask that is used to mask both the stencil reference value and the stencil buffer value before they are compared. The initial value is all 1's. See {@link glStencilFunc}. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See {@link glStencilFuncSeparate}.
 *
 * - {@link GL_STENCIL_WRITEMASK}
 * **params** returns one value, the mask that controls writing of the stencil bitplanes. The initial value is all 1's. See {@link glStencilMask}. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See {@link glStencilMaskSeparate}.
 *
 * - {@link GL_STEREO}
 * **params** returns a single boolean value indicating whether stereo buffers (left and right) are supported.
 *
 * - {@link GL_SUBPIXEL_BITS}
 * **params** returns one value, an estimate of the number of bits of subpixel resolution that are used to position rasterized geometry in window coordinates. The value must be at least 4.
 *
 * - {@link GL_TEXTURE_BINDING_1D}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_1D}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_1D_ARRAY}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_1D_ARRAY}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_2D}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_2D}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_2D_ARRAY}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_2D_ARRAY}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_2D_MULTISAMPLE}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_2D_MULTISAMPLE}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_2D_MULTISAMPLE_ARRAY}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_3D}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_3D}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_BUFFER}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_BUFFER}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_CUBE_MAP}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_CUBE_MAP}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_RECTANGLE}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_RECTANGLE}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_COMPRESSION_HINT}
 * **params** returns a single value indicating the mode of the texture compression hint. The initial value is {@link GL_DONT_CARE}.
 *
 * - {@link GL_TEXTURE_BINDING_BUFFER}
 * **params** returns a single value, the name of the texture buffer object currently bound. The initial value is 0. See {@link glBindBuffer}.
 *
 * - {@link GL_TIMESTAMP}
 * **params** returns a single value, the 64-bit value of the current GL time. See {@link glQueryCounter}.
 *
 * - {@link GL_TRANSFORM_FEEDBACK_BUFFER_BINDING}
 * When used with non-indexed variants of `glGet` (such as `glGetIntegerv`), **params** returns a single value, the name of the buffer object currently bound to the target {@link GL_TRANSFORM_FEEDBACK_BUFFER}. If no buffer object is bound to this target, 0 is returned. When used with indexed variants of `glGet` (such as `glGetIntegeri_v`), **params** returns a single value, the name of the buffer object bound to the indexed transform feedback attribute stream. The initial value is 0 for all targets. See {@link glBindBuffer}, {@link glBindBufferBase}, and {@link glBindBufferRange}.
 *
 * - {@link GL_TRANSFORM_FEEDBACK_BUFFER_START}
 * When used with indexed variants of `glGet` (such as `glGetInteger64i_v`), **params** returns a single value, the start offset of the binding range for each transform feedback attribute stream. The initial value is 0 for all streams. See {@link glBindBufferRange}.
 *
 * - {@link GL_TRANSFORM_FEEDBACK_BUFFER_SIZE}
 * When used with indexed variants of `glGet` (such as `glGetInteger64i_v`), **params** returns a single value, the size of the binding range for each transform feedback attribute stream. The initial value is 0 for all streams. See {@link glBindBufferRange}.
 *
 * - {@link GL_UNIFORM_BUFFER_BINDING}
 * When used with non-indexed variants of `glGet` (such as `glGetIntegerv`), **params** returns a single value, the name of the buffer object currently bound to the target {@link GL_UNIFORM_BUFFER}. If no buffer object is bound to this target, 0 is returned. When used with indexed variants of `glGet` (such as `glGetIntegeri_v`), **params** returns a single value, the name of the buffer object bound to the indexed uniform buffer binding point. The initial value is 0 for all targets. See {@link glBindBuffer}, {@link glBindBufferBase}, and {@link glBindBufferRange}.
 *
 * - {@link GL_UNIFORM_BUFFER_START}
 * When used with indexed variants of `glGet` (such as `glGetInteger64i_v`), **params** returns a single value, the start offset of the binding range for each indexed uniform buffer binding. The initial value is 0 for all bindings. See {@link glBindBufferRange}.
 *
 * - {@link GL_UNIFORM_BUFFER_SIZE}
 * When used with indexed variants of `glGet` (such as `glGetInteger64i_v`), **params** returns a single value, the size of the binding range for each indexed uniform buffer binding. The initial value is 0 for all bindings. See {@link glBindBufferRange}.
 *
 * - {@link GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT}
 * **params** returns a single value, the minimum required alignment for uniform buffer sizes and offset. The initial value is 1. See {@link glUniformBlockBinding}.
 *
 * - {@link GL_UNPACK_ALIGNMENT}
 * **params** returns one value, the byte alignment used for reading pixel data from memory. The initial value is 4. See {@link glPixelStore}.
 *
 * - {@link GL_UNPACK_IMAGE_HEIGHT}
 * **params** returns one value, the image height used for reading pixel data from memory. The initial is 0. See {@link glPixelStore}.
 *
 * - {@link GL_UNPACK_LSB_FIRST}
 * **params** returns a single boolean value indicating whether single-bit pixels being read from memory are read first from the least significant bit of each unsigned byte. The initial value is {@link GL_FALSE}. See {@link glPixelStore}.
 *
 * - {@link GL_UNPACK_ROW_LENGTH}
 * **params** returns one value, the row length used for reading pixel data from memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_UNPACK_SKIP_IMAGES}
 * **params** returns one value, the number of pixel images skipped before the first pixel is read from memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_UNPACK_SKIP_PIXELS}
 * **params** returns one value, the number of pixel locations skipped before the first pixel is read from memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_UNPACK_SKIP_ROWS}
 * **params** returns one value, the number of rows of pixel locations skipped before the first pixel is read from memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_UNPACK_SWAP_BYTES}
 * **params** returns a single boolean value indicating whether the bytes of two-byte and four-byte pixel indices and components are swapped after being read from memory. The initial value is {@link GL_FALSE}. See {@link glPixelStore}.
 *
 * - {@link GL_NUM_EXTENSIONS}
 * **params** returns one value, the number of extensions supported by the GL implementation for the current context. See {@link glGetString}.
 *
 * - {@link GL_MAJOR_VERSION}
 * **params** returns one value, the major version number of the OpenGL API supported by the current context.
 *
 * - {@link GL_MINOR_VERSION}
 * **params** returns one value, the minor version number of the OpenGL API supported by the current context.
 *
 * - {@link GL_CONTEXT_FLAGS}
 * **params** returns one value, the flags with which the context was created (such as debugging functionality).
 *
 * - {@link GL_VIEWPORT}
 * **params** returns four values: the 𝐱 and 𝐲 window coordinates of the viewport, followed by its width and height. Initially the 𝐱 and 𝐲 window coordinates are both set to 0, and the *width* and *height* are set to the width and height of the window into which the GL will do its rendering. See {@link glViewport}.
 *
 * Many of the boolean parameters can also be queried more easily using {@link glIsEnabled}.
 *
 * @summary return the value or values of a selected parameter
 * @param pname Specifies the parameter value to be returned. The symbolic constants in the list below are accepted.
 * @param params Returns the value or values of the specified parameter.
 * @see [glGet](https://docs.gl/gl3/glGet)
 */
export function glGetBooleanv(pname: GLenum, params: GLboolean): void;

/**
 * These four commands return values for simple state variables in GL. **pname** is a symbolic constant indicating the state variable to be returned, and **params** is a pointer to an array of the indicated type in which to place the returned data.
 *
 * Type conversion is performed if **params** has a different type than the state variable value being requested. If `glGetBooleanv` is called, a floating-point (or integer) value is converted to {@link GL_FALSE} if and only if it is 0.0 (or 0). Otherwise, it is converted to {@link GL_TRUE}. If `glGetIntegerv` is called, boolean values are returned as {@link GL_TRUE} or {@link GL_FALSE}, and most floating-point values are rounded to the nearest integer value. Floating-point colors and normals, however, are returned with a linear mapping that maps 1.0 to the most positive representable integer value and −1.0 to the most negative representable integer value. If `glGetFloatv` or `glGetDoublev` is called, boolean values are returned as {@link GL_TRUE} or {@link GL_FALSE}, and integer values are converted to floating-point values.
 *
 * The following symbolic constants are accepted by **pname**:
 *
 * - {@link GL_ACTIVE_TEXTURE}
 * **params** returns a single value indicating the active multitexture unit. The initial value is {@link GL_TEXTURE0}. See {@link glActiveTexture}.
 *
 * - {@link GL_ALIASED_LINE_WIDTH_RANGE}
 * **params** returns a pair of values indicating the range of widths supported for aliased lines. See {@link glLineWidth}.
 *
 * - {@link GL_SMOOTH_LINE_WIDTH_RANGE}
 * **params** returns a pair of values indicating the range of widths supported for smooth (antialiased) lines. See {@link glLineWidth}.
 *
 * - {@link GL_SMOOTH_LINE_WIDTH_GRANULARITY}
 * **params** returns a single value indicating the level of quantization applied to smooth line width parameters.
 *
 * - {@link GL_ARRAY_BUFFER_BINDING}
 * **params** returns a single value, the name of the buffer object currently bound to the target {@link GL_ARRAY_BUFFER}. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See {@link glBindBuffer}.
 *
 * - {@link GL_BLEND}
 * **params** returns a single boolean value indicating whether blending is enabled. The initial value is {@link GL_FALSE}. See {@link glBlendFunc}.
 *
 * - {@link GL_BLEND_COLOR}
 * **params** returns four values, the red, green, blue, and alpha values which are the components of the blend color. See {@link glBlendColor}.
 *
 * - {@link GL_BLEND_DST_ALPHA}
 * **params** returns one value, the symbolic constant identifying the alpha destination blend function. The initial value is {@link GL_ZERO}. See {@link glBlendFunc} and {@link glBlendFuncSeparate}.
 *
 * - {@link GL_BLEND_DST_RGB}
 * **params** returns one value, the symbolic constant identifying the RGB destination blend function. The initial value is {@link GL_ZERO}. See {@link glBlendFunc} and {@link glBlendFuncSeparate}.
 *
 * - {@link GL_BLEND_EQUATION_RGB}
 * **params** returns one value, a symbolic constant indicating whether the RGB blend equation is {@link GL_FUNC_ADD}, {@link GL_FUNC_SUBTRACT}, {@link GL_FUNC_REVERSE_SUBTRACT}, {@link GL_MIN} or {@link GL_MAX}. See {@link glBlendEquationSeparate}.
 *
 * - {@link GL_BLEND_EQUATION_ALPHA}
 * **params** returns one value, a symbolic constant indicating whether the Alpha blend equation is {@link GL_FUNC_ADD}, {@link GL_FUNC_SUBTRACT}, {@link GL_FUNC_REVERSE_SUBTRACT}, {@link GL_MIN} or {@link GL_MAX}. See {@link glBlendEquationSeparate}.
 *
 * - {@link GL_BLEND_SRC_ALPHA}
 * **params** returns one value, the symbolic constant identifying the alpha source blend function. The initial value is {@link GL_ONE}. See {@link glBlendFunc} and {@link glBlendFuncSeparate}.
 *
 * - {@link GL_BLEND_SRC_RGB}
 * **params** returns one value, the symbolic constant identifying the RGB source blend function. The initial value is {@link GL_ONE}. See {@link glBlendFunc} and {@link glBlendFuncSeparate}.
 *
 * - {@link GL_COLOR_CLEAR_VALUE}
 * **params** returns four values: the red, green, blue, and alpha values used to clear the color buffers. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and −1.0 returns the most negative representable integer value. The initial value is (0, 0, 0, 0). See {@link glClearColor}.
 *
 * - {@link GL_COLOR_LOGIC_OP}
 * **params** returns a single boolean value indicating whether a fragment's RGBA color values are merged into the framebuffer using a logical operation. The initial value is {@link GL_FALSE}. See {@link glLogicOp}.
 *
 * - {@link GL_COLOR_WRITEMASK}
 * **params** returns four boolean values: the red, green, blue, and alpha write enables for the color buffers. The initial value is ({@link GL_TRUE}, {@link GL_TRUE}, {@link GL_TRUE}, {@link GL_TRUE}). See {@link glColorMask}.
 *
 * - {@link GL_COMPRESSED_TEXTURE_FORMATS}
 * **params** returns a list of symbolic constants of length {@link GL_NUM_COMPRESSED_TEXTURE_FORMATS} indicating which compressed texture formats are available. See {@link glCompressedTexImage2D}.
 *
 * - {@link GL_CULL_FACE}
 * **params** returns a single boolean value indicating whether polygon culling is enabled. The initial value is {@link GL_FALSE}. See {@link glCullFace}.
 *
 * - {@link GL_CURRENT_PROGRAM}
 * **params** returns one value, the name of the program object that is currently active, or 0 if no program object is active. See {@link glUseProgram}.
 *
 * - {@link GL_DEPTH_CLEAR_VALUE}
 * **params** returns one value, the value that is used to clear the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. The initial value is 1. See {@link glClearDepth}.
 *
 * - {@link GL_DEPTH_FUNC}
 * **params** returns one value, the symbolic constant that indicates the depth comparison function. The initial value is {@link GL_LESS}. See {@link glDepthFunc}.
 *
 * - {@link GL_DEPTH_RANGE}
 * **params** returns two values: the near and far mapping limits for the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and −1.0 returns the most negative representable integer value. The initial value is (0, 1). See {@link glDepthRange}.
 *
 * - {@link GL_DEPTH_TEST}
 * **params** returns a single boolean value indicating whether depth testing of fragments is enabled. The initial value is {@link GL_FALSE}. See {@link glDepthFunc} and {@link glDepthRange}.
 *
 * - {@link GL_DEPTH_WRITEMASK}
 * **params** returns a single boolean value indicating if the depth buffer is enabled for writing. The initial value is {@link GL_TRUE}. See {@link glDepthMask}.
 *
 * - {@link GL_DITHER}
 * **params** returns a single boolean value indicating whether dithering of fragment colors and indices is enabled. The initial value is {@link GL_TRUE}.
 *
 * - {@link GL_DOUBLEBUFFER}
 * **params** returns a single boolean value indicating whether double buffering is supported.
 *
 * - {@link GL_DRAW_BUFFER}
 * **params** returns one value, a symbolic constant indicating which buffers are being drawn to. See {@link glDrawBuffer}. The initial value is {@link GL_BACK} if there are back buffers, otherwise it is {@link GL_FRONT}.
 *
 * - {@link GL_DRAW_BUFFER}**i**
 * **params** returns one value, a symbolic constant indicating which buffers are being drawn to by the corresponding output color. See {@link glDrawBuffers}. The initial value of {@link GL_DRAW_BUFFER0} is {@link GL_BACK} if there are back buffers, otherwise it is {@link GL_FRONT}. The initial values of draw buffers for all other output colors is {@link GL_NONE}.
 *
 * - {@link GL_DRAW_FRAMEBUFFER_BINDING}
 * **params** returns one value, the name of the framebuffer object currently bound to the {@link GL_DRAW_FRAMEBUFFER} target. If the default framebuffer is bound, this value will be zero. The initial value is zero. See {@link glBindFramebuffer}.
 *
 * - {@link GL_READ_FRAMEBUFFER_BINDING}
 * **params** returns one value, the name of the framebuffer object currently bound to the {@link GL_READ_FRAMEBUFFER} target. If the default framebuffer is bound, this value will be zero. The initial value is zero. See {@link glBindFramebuffer}.
 *
 * - {@link GL_ELEMENT_ARRAY_BUFFER_BINDING}
 * **params** returns a single value, the name of the buffer object currently bound to the target {@link GL_ELEMENT_ARRAY_BUFFER}. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See {@link glBindBuffer}.
 *
 * - {@link GL_RENDERBUFFER_BINDING}
 * **params** returns a single value, the name of the renderbuffer object currently bound to the target {@link GL_RENDERBUFFER}. If no renderbuffer object is bound to this target, 0 is returned. The initial value is 0. See {@link glBindRenderbuffer}.
 *
 * - {@link GL_FRAGMENT_SHADER_DERIVATIVE_HINT}
 * **params** returns one value, a symbolic constant indicating the mode of the derivative accuracy hint for fragment shaders. The initial value is {@link GL_DONT_CARE}. See {@link glHint}.
 *
 * - {@link GL_LINE_SMOOTH}
 * **params** returns a single boolean value indicating whether antialiasing of lines is enabled. The initial value is {@link GL_FALSE}. See {@link glLineWidth}.
 *
 * - {@link GL_LINE_SMOOTH_HINT}
 * **params** returns one value, a symbolic constant indicating the mode of the line antialiasing hint. The initial value is {@link GL_DONT_CARE}. See {@link glHint}.
 *
 * - {@link GL_LINE_WIDTH}
 * **params** returns one value, the line width as specified with {@link glLineWidth}. The initial value is 1.
 *
 * - {@link GL_LOGIC_OP_MODE}
 * **params** returns one value, a symbolic constant indicating the selected logic operation mode. The initial value is {@link GL_COPY}. See {@link glLogicOp}.
 *
 * - {@link GL_MAX_3D_TEXTURE_SIZE}
 * **params** returns one value, a rough estimate of the largest 3D texture that the GL can handle. The value must be at least 64. Use {@link GL_PROXY_TEXTURE_3D} to determine if a texture is too large. See {@link glTexImage3D}.
 *
 * - {@link GL_MAX_CLIP_DISTANCES}
 * **params** returns one value, the maximum number of application-defined clipping distances. The value must be at least 8.
 *
 * - {@link GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS}
 * **params** returns one value, the number of words for fragment shader uniform variables in all uniform blocks (including default). The value must be at least 1. See {@link glUniform}.
 *
 * - {@link GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS}
 * **params** returns one value, the maximum supported texture image units that can be used to access texture maps from the vertex shader and the fragment processor combined. If both the vertex shader and the fragment processing stage access the same texture image unit, then that counts as using two texture image units against this limit. The value must be at least 48. See {@link glActiveTexture}.
 *
 * - {@link GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS}
 * **params** returns one value, the number of words for vertex shader uniform variables in all uniform blocks (including default). The value must be at least 1. See {@link glUniform}.
 *
 * - {@link GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS}
 * **params** returns one value, the number of words for geometry shader uniform variables in all uniform blocks (including default). The value must be at least 1. See {@link glUniform}.
 *
 * - {@link GL_MAX_VARYING_COMPONENTS}
 * **params** returns one value, the number components for varying variables, which must be at least 60.
 *
 * - {@link GL_MAX_COMBINED_UNIFORM_BLOCKS}
 * **params** returns one value, the maximum number of uniform blocks per program. The value must be at least 36. See {@link glUniformBlockBinding}.
 *
 * - {@link GL_MAX_CUBE_MAP_TEXTURE_SIZE}
 * **params** returns one value. The value gives a rough estimate of the largest cube-map texture that the GL can handle. The value must be at least 1024. Use {@link GL_PROXY_TEXTURE_CUBE_MAP} to determine if a texture is too large. See {@link glTexImage2D}.
 *
 * - {@link GL_MAX_DRAW_BUFFERS}
 * **params** returns one value, the maximum number of simultaneous outputs that may be written in a fragment shader. The value must be at least 8. See {@link glDrawBuffers}.
 *
 * - {@link GL_MAX_DUAL_SOURCE_DRAW_BUFFERS}
 * **params** returns one value, the maximum number of active draw buffers when using dual-source blending. The value must be at least 1. See {@link glBlendFunc} and {@link glBlendFuncSeparate}.
 *
 * - {@link GL_MAX_ELEMENTS_INDICES}
 * **params** returns one value, the recommended maximum number of vertex array indices. See {@link glDrawRangeElements}.
 *
 * - {@link GL_MAX_ELEMENTS_VERTICES}
 * **params** returns one value, the recommended maximum number of vertex array vertices. See {@link glDrawRangeElements}.
 *
 * - {@link GL_MAX_FRAGMENT_UNIFORM_COMPONENTS}
 * **params** returns one value, the maximum number of individual floating-point, integer, or boolean values that can be held in uniform variable storage for a fragment shader. The value must be at least 1024. See {@link glUniform}.
 *
 * - {@link GL_MAX_FRAGMENT_UNIFORM_BLOCKS}
 * **params** returns one value, the maximum number of uniform blocks per fragment shader. The value must be at least 12. See {@link glUniformBlockBinding}.
 *
 * - {@link GL_MAX_FRAGMENT_INPUT_COMPONENTS}
 * **params** returns one value, the maximum number of components of the inputs read by the fragment shader, which must be at least 128.
 *
 * - {@link GL_MIN_PROGRAM_TEXEL_OFFSET}
 * **params** returns one value, the minimum texel offset allowed in a texture lookup, which must be at most -8.
 *
 * - {@link GL_MAX_PROGRAM_TEXEL_OFFSET}
 * **params** returns one value, the maximum texel offset allowed in a texture lookup, which must be at least 7.
 *
 * - {@link GL_MAX_RECTANGLE_TEXTURE_SIZE}
 * **params** returns one value. The value gives a rough estimate of the largest rectangular texture that the GL can handle. The value must be at least 1024. Use {@link GL_PROXY_TEXTURE_RECTANGLE} to determine if a texture is too large. See {@link glTexImage2D}.
 *
 * - {@link GL_MAX_TEXTURE_IMAGE_UNITS}
 * **params** returns one value, the maximum supported texture image units that can be used to access texture maps from the fragment shader. The value must be at least 16. See {@link glActiveTexture}.
 *
 * - {@link GL_MAX_TEXTURE_LOD_BIAS}
 * **params** returns one value, the maximum, absolute value of the texture level-of-detail bias. The value must be at least 2.0.
 *
 * - {@link GL_MAX_TEXTURE_SIZE}
 * **params** returns one value. The value gives a rough estimate of the largest texture that the GL can handle. The value must be at least 1024. Use a proxy texture target such as {@link GL_PROXY_TEXTURE_1D} or {@link GL_PROXY_TEXTURE_2D} to determine if a texture is too large. See {@link glTexImage1D} and {@link glTexImage2D}.
 *
 * - {@link GL_MAX_RENDERBUFFER_SIZE}
 * **params** returns one value. The value indicates the maximum supported size for renderbuffers. See {@link glFramebufferRenderbuffer}.
 *
 * - {@link GL_MAX_ARRAY_TEXTURE_LAYERS}
 * **params** returns one value. The value indicates the maximum number of layers allowed in an array texture, and must be at least 256. See {@link glTexImage2D}.
 *
 * - {@link GL_MAX_TEXTURE_BUFFER_SIZE}
 * **params** returns one value. The value gives the maximum number of texels allowed in the texel array of a texture buffer object. Value must be at least 65536.
 *
 * - {@link GL_MAX_UNIFORM_BLOCK_SIZE}
 * **params** returns one value, the maximum size in basic machine units of a uniform block. The value must be at least 16384. See {@link glUniformBlockBinding}.
 *
 * - {@link GL_MAX_VARYING_FLOATS}
 * **params** returns one value, the maximum number of interpolators available for processing varying variables used by vertex and fragment shaders. This value represents the number of individual floating-point values that can be interpolated; varying variables declared as vectors, matrices, and arrays will all consume multiple interpolators. The value must be at least 32.
 *
 * - {@link GL_MAX_VERTEX_ATTRIBS}
 * **params** returns one value, the maximum number of 4-component generic vertex attributes accessible to a vertex shader. The value must be at least 16. See {@link glVertexAttrib}.
 *
 * - {@link GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS}
 * **params** returns one value, the maximum supported texture image units that can be used to access texture maps from the vertex shader. The value may be at least 16. See {@link glActiveTexture}.
 *
 * - {@link GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS}
 * **params** returns one value, the maximum supported texture image units that can be used to access texture maps from the geometry shader. The value must be at least 16. See {@link glActiveTexture}.
 *
 * - {@link GL_MAX_VERTEX_UNIFORM_COMPONENTS}
 * **params** returns one value, the maximum number of individual floating-point, integer, or boolean values that can be held in uniform variable storage for a vertex shader. The value must be at least 1024. See {@link glUniform}.
 *
 * - {@link GL_MAX_VERTEX_OUTPUT_COMPONENTS}
 * **params** returns one value, the maximum number of components of output written by a vertex shader, which must be at least 64.
 *
 * - {@link GL_MAX_GEOMETRY_UNIFORM_COMPONENTS}
 * **params** returns one value, the maximum number of individual floating-point, integer, or boolean values that can be held in uniform variable storage for a geometry shader. The value must be at least 1024. See {@link glUniform}.
 *
 * - {@link GL_MAX_SAMPLE_MASK_WORDS}
 * **params** returns one value, the maximum number of sample mask words.
 *
 * - {@link GL_MAX_COLOR_TEXTURE_SAMPLES}
 * **params** returns one value, the maximum number of samples in a color multisample texture.
 *
 * - {@link GL_MAX_DEPTH_TEXTURE_SAMPLES}
 * **params** returns one value, the maximum number of samples in a multisample depth or depth-stencil texture.
 *
 * - {@link GL_MAX_DEPTH_TEXTURE_SAMPLES}
 * **params** returns one value, the maximum number of samples in a multisample depth or depth-stencil texture.
 *
 * - {@link GL_MAX_INTEGER_SAMPLES}
 * **params** returns one value, the maximum number of samples supported in integer format multisample buffers.
 *
 * - {@link GL_MAX_SERVER_WAIT_TIMEOUT}
 * **params** returns one value, the maximum {@link glWaitSync} timeout interval.
 *
 * - {@link GL_MAX_UNIFORM_BUFFER_BINDINGS}
 * **params** returns one value, the maximum number of uniform buffer binding points on the context, which must be at least 36.
 *
 * - {@link GL_MAX_UNIFORM_BLOCK_SIZE}
 * **params** returns one value, the maximum size in basic machine units of a uniform block, which must be at least 16384.
 *
 * - {@link GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT}
 * **params** returns one value, the minimum required alignment for uniform buffer sizes and offsets.
 *
 * - {@link GL_MAX_VERTEX_UNIFORM_BLOCKS}
 * **params** returns one value, the maximum number of uniform blocks per vertex shader. The value must be at least 12. See {@link glUniformBlockBinding}.
 *
 * - {@link GL_MAX_GEOMETRY_UNIFORM_BLOCKS}
 * **params** returns one value, the maximum number of uniform blocks per geometry shader. The value must be at least 12. See {@link glUniformBlockBinding}.
 *
 * - {@link GL_MAX_GEOMETRY_INPUT_COMPONENTS}
 * **params** returns one value, the maximum number of components of inputs read by a geometry shader, which must be at least 64.
 *
 * - {@link GL_MAX_GEOMETRY_OUTPUT_COMPONENTS}
 * **params** returns one value, the maximum number of components of outputs written by a geometry shader, which must be at least 128.
 *
 * - {@link GL_MAX_VIEWPORT_DIMS}
 * **params** returns two values: the maximum supported width and height of the viewport. These must be at least as large as the visible dimensions of the display being rendered to. See {@link glViewport}.
 *
 * - {@link GL_NUM_COMPRESSED_TEXTURE_FORMATS}
 * **params** returns a single integer value indicating the number of available compressed texture formats. The minimum value is 4. See {@link glCompressedTexImage2D}.
 *
 * - {@link GL_PACK_ALIGNMENT}
 * **params** returns one value, the byte alignment used for writing pixel data to memory. The initial value is 4. See {@link glPixelStore}.
 *
 * - {@link GL_PACK_IMAGE_HEIGHT}
 * **params** returns one value, the image height used for writing pixel data to memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_PACK_LSB_FIRST}
 * **params** returns a single boolean value indicating whether single-bit pixels being written to memory are written first to the least significant bit of each unsigned byte. The initial value is {@link GL_FALSE}. See {@link glPixelStore}.
 *
 * - {@link GL_PACK_ROW_LENGTH}
 * **params** returns one value, the row length used for writing pixel data to memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_PACK_SKIP_IMAGES}
 * **params** returns one value, the number of pixel images skipped before the first pixel is written into memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_PACK_SKIP_PIXELS}
 * **params** returns one value, the number of pixel locations skipped before the first pixel is written into memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_PACK_SKIP_ROWS}
 * **params** returns one value, the number of rows of pixel locations skipped before the first pixel is written into memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_PACK_SWAP_BYTES}
 * **params** returns a single boolean value indicating whether the bytes of two-byte and four-byte pixel indices and components are swapped before being written to memory. The initial value is {@link GL_FALSE}. See {@link glPixelStore}.
 *
 * - {@link GL_PIXEL_PACK_BUFFER_BINDING}
 * **params** returns a single value, the name of the buffer object currently bound to the target {@link GL_PIXEL_PACK_BUFFER}. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See {@link glBindBuffer}.
 *
 * - {@link GL_PIXEL_UNPACK_BUFFER_BINDING}
 * **params** returns a single value, the name of the buffer object currently bound to the target {@link GL_PIXEL_UNPACK_BUFFER}. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See {@link glBindBuffer}.
 *
 * - {@link GL_POINT_FADE_THRESHOLD_SIZE}
 * **params** returns one value, the point size threshold for determining the point size. See {@link glPointParameter}.
 *
 * - {@link GL_PRIMITIVE_RESTART_INDEX}
 * **params** returns one value, the current primitive restart index. The initial value is 0. See {@link glPrimitiveRestartIndex}.
 *
 * - {@link GL_PROGRAM_POINT_SIZE}
 * **params** returns a single boolean value indicating whether vertex program point size mode is enabled. If enabled, then the point size is taken from the shader built-in gl_PointSize. If disabled, then the point size is taken from the point state as specified by {@link glPointSize}. The initial value is {@link GL_FALSE}.
 *
 * - {@link GL_PROVOKING_VERTEX}
 * **params** returns one value, the currently selected provoking vertex convention. The initial value is {@link GL_LAST_VERTEX_CONVENTION}. See {@link glProvokingVertex}.
 *
 * - {@link GL_POINT_SIZE}
 * **params** returns one value, the point size as specified by {@link glPointSize}. The initial value is 1.
 *
 * - {@link GL_POINT_SIZE_GRANULARITY}
 * **params** returns one value, the size difference between adjacent supported sizes for antialiased points. See {@link glPointSize}.
 *
 * - {@link GL_POINT_SIZE_RANGE}
 * **params** returns two values: the smallest and largest supported sizes for antialiased points. The smallest size must be at most 1, and the largest size must be at least 1. See {@link glPointSize}.
 *
 * - {@link GL_POLYGON_OFFSET_FACTOR}
 * **params** returns one value, the scaling factor used to determine the variable offset that is added to the depth value of each fragment generated when a polygon is rasterized. The initial value is 0. See {@link glPolygonOffset}.
 *
 * - {@link GL_POLYGON_OFFSET_UNITS}
 * **params** returns one value. This value is multiplied by an implementation-specific value and then added to the depth value of each fragment generated when a polygon is rasterized. The initial value is 0. See {@link glPolygonOffset}.
 *
 * - {@link GL_POLYGON_OFFSET_FILL}
 * **params** returns a single boolean value indicating whether polygon offset is enabled for polygons in fill mode. The initial value is {@link GL_FALSE}. See {@link glPolygonOffset}.
 *
 * - {@link GL_POLYGON_OFFSET_LINE}
 * **params** returns a single boolean value indicating whether polygon offset is enabled for polygons in line mode. The initial value is {@link GL_FALSE}. See {@link glPolygonOffset}.
 *
 * - {@link GL_POLYGON_OFFSET_POINT}
 * **params** returns a single boolean value indicating whether polygon offset is enabled for polygons in point mode. The initial value is {@link GL_FALSE}. See {@link glPolygonOffset}.
 *
 * - {@link GL_POLYGON_SMOOTH}
 * **params** returns a single boolean value indicating whether antialiasing of polygons is enabled. The initial value is {@link GL_FALSE}. See {@link glPolygonMode}.
 *
 * - {@link GL_POLYGON_SMOOTH_HINT}
 * **params** returns one value, a symbolic constant indicating the mode of the polygon antialiasing hint. The initial value is {@link GL_DONT_CARE}. See {@link glHint}.
 *
 * - {@link GL_READ_BUFFER}
 * **params** returns one value, a symbolic constant indicating which color buffer is selected for reading. The initial value is {@link GL_BACK} if there is a back buffer, otherwise it is {@link GL_FRONT}. See {@link glReadPixels}.
 *
 * - {@link GL_SAMPLE_BUFFERS}
 * **params** returns a single integer value indicating the number of sample buffers associated with the framebuffer. See {@link glSampleCoverage}.
 *
 * - {@link GL_SAMPLE_COVERAGE_VALUE}
 * **params** returns a single positive floating-point value indicating the current sample coverage value. See {@link glSampleCoverage}.
 *
 * - {@link GL_SAMPLE_COVERAGE_INVERT}
 * **params** returns a single boolean value indicating if the temporary coverage value should be inverted. See {@link glSampleCoverage}.
 *
 * - {@link GL_SAMPLER_BINDING}
 * **params** returns a single value, the name of the sampler object currently bound to the active texture unit. The initial value is 0. See {@link glBindSampler}.
 *
 * - {@link GL_SAMPLES}
 * **params** returns a single integer value indicating the coverage mask size. See {@link glSampleCoverage}.
 *
 * - {@link GL_SCISSOR_BOX}
 * **params** returns four values: the 𝐱 and 𝐲 window coordinates of the scissor box, followed by its width and height. Initially the 𝐱 and 𝐲 window coordinates are both 0 and the *width* and *height* are set to the size of the window. See {@link glScissor}.
 *
 * - {@link GL_SCISSOR_TEST}
 * **params** returns a single boolean value indicating whether scissoring is enabled. The initial value is {@link GL_FALSE}. See {@link glScissor}.
 *
 * - {@link GL_STENCIL_BACK_FAIL}
 * **params** returns one value, a symbolic constant indicating what action is taken for back-facing polygons when the stencil test fails. The initial value is {@link GL_KEEP}. See {@link glStencilOpSeparate}.
 *
 * - {@link GL_STENCIL_BACK_FUNC}
 * **params** returns one value, a symbolic constant indicating what function is used for back-facing polygons to compare the stencil reference value with the stencil buffer value. The initial value is {@link GL_ALWAYS}. See {@link glStencilFuncSeparate}.
 *
 * - {@link GL_STENCIL_BACK_PASS_DEPTH_FAIL}
 * **params** returns one value, a symbolic constant indicating what action is taken for back-facing polygons when the stencil test passes, but the depth test fails. The initial value is {@link GL_KEEP}. See {@link glStencilOpSeparate}.
 *
 * - {@link GL_STENCIL_BACK_PASS_DEPTH_PASS}
 * **params** returns one value, a symbolic constant indicating what action is taken for back-facing polygons when the stencil test passes and the depth test passes. The initial value is {@link GL_KEEP}. See {@link glStencilOpSeparate}.
 *
 * - {@link GL_STENCIL_BACK_REF}
 * **params** returns one value, the reference value that is compared with the contents of the stencil buffer for back-facing polygons. The initial value is 0. See {@link glStencilFuncSeparate}.
 *
 * - {@link GL_STENCIL_BACK_VALUE_MASK}
 * **params** returns one value, the mask that is used for back-facing polygons to mask both the stencil reference value and the stencil buffer value before they are compared. The initial value is all 1's. See {@link glStencilFuncSeparate}.
 *
 * - {@link GL_STENCIL_BACK_WRITEMASK}
 * **params** returns one value, the mask that controls writing of the stencil bitplanes for back-facing polygons. The initial value is all 1's. See {@link glStencilMaskSeparate}.
 *
 * - {@link GL_STENCIL_CLEAR_VALUE}
 * **params** returns one value, the index to which the stencil bitplanes are cleared. The initial value is 0. See {@link glClearStencil}.
 *
 * - {@link GL_STENCIL_FAIL}
 * **params** returns one value, a symbolic constant indicating what action is taken when the stencil test fails. The initial value is {@link GL_KEEP}. See {@link glStencilOp}. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See {@link glStencilOpSeparate}.
 *
 * - {@link GL_STENCIL_FUNC}
 * **params** returns one value, a symbolic constant indicating what function is used to compare the stencil reference value with the stencil buffer value. The initial value is {@link GL_ALWAYS}. See {@link glStencilFunc}. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See {@link glStencilFuncSeparate}.
 *
 * - {@link GL_STENCIL_PASS_DEPTH_FAIL}
 * **params** returns one value, a symbolic constant indicating what action is taken when the stencil test passes, but the depth test fails. The initial value is {@link GL_KEEP}. See {@link glStencilOp}. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See {@link glStencilOpSeparate}.
 *
 * - {@link GL_STENCIL_PASS_DEPTH_PASS}
 * **params** returns one value, a symbolic constant indicating what action is taken when the stencil test passes and the depth test passes. The initial value is {@link GL_KEEP}. See {@link glStencilOp}. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See {@link glStencilOpSeparate}.
 *
 * - {@link GL_STENCIL_REF}
 * **params** returns one value, the reference value that is compared with the contents of the stencil buffer. The initial value is 0. See {@link glStencilFunc}. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See {@link glStencilFuncSeparate}.
 *
 * - {@link GL_STENCIL_TEST}
 * **params** returns a single boolean value indicating whether stencil testing of fragments is enabled. The initial value is {@link GL_FALSE}. See {@link glStencilFunc} and {@link glStencilOp}.
 *
 * - {@link GL_STENCIL_VALUE_MASK}
 * **params** returns one value, the mask that is used to mask both the stencil reference value and the stencil buffer value before they are compared. The initial value is all 1's. See {@link glStencilFunc}. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See {@link glStencilFuncSeparate}.
 *
 * - {@link GL_STENCIL_WRITEMASK}
 * **params** returns one value, the mask that controls writing of the stencil bitplanes. The initial value is all 1's. See {@link glStencilMask}. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See {@link glStencilMaskSeparate}.
 *
 * - {@link GL_STEREO}
 * **params** returns a single boolean value indicating whether stereo buffers (left and right) are supported.
 *
 * - {@link GL_SUBPIXEL_BITS}
 * **params** returns one value, an estimate of the number of bits of subpixel resolution that are used to position rasterized geometry in window coordinates. The value must be at least 4.
 *
 * - {@link GL_TEXTURE_BINDING_1D}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_1D}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_1D_ARRAY}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_1D_ARRAY}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_2D}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_2D}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_2D_ARRAY}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_2D_ARRAY}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_2D_MULTISAMPLE}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_2D_MULTISAMPLE}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_2D_MULTISAMPLE_ARRAY}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_3D}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_3D}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_BUFFER}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_BUFFER}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_CUBE_MAP}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_CUBE_MAP}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_RECTANGLE}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_RECTANGLE}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_COMPRESSION_HINT}
 * **params** returns a single value indicating the mode of the texture compression hint. The initial value is {@link GL_DONT_CARE}.
 *
 * - {@link GL_TEXTURE_BINDING_BUFFER}
 * **params** returns a single value, the name of the texture buffer object currently bound. The initial value is 0. See {@link glBindBuffer}.
 *
 * - {@link GL_TIMESTAMP}
 * **params** returns a single value, the 64-bit value of the current GL time. See {@link glQueryCounter}.
 *
 * - {@link GL_TRANSFORM_FEEDBACK_BUFFER_BINDING}
 * When used with non-indexed variants of `glGet` (such as `glGetIntegerv`), **params** returns a single value, the name of the buffer object currently bound to the target {@link GL_TRANSFORM_FEEDBACK_BUFFER}. If no buffer object is bound to this target, 0 is returned. When used with indexed variants of `glGet` (such as `glGetIntegeri_v`), **params** returns a single value, the name of the buffer object bound to the indexed transform feedback attribute stream. The initial value is 0 for all targets. See {@link glBindBuffer}, {@link glBindBufferBase}, and {@link glBindBufferRange}.
 *
 * - {@link GL_TRANSFORM_FEEDBACK_BUFFER_START}
 * When used with indexed variants of `glGet` (such as `glGetInteger64i_v`), **params** returns a single value, the start offset of the binding range for each transform feedback attribute stream. The initial value is 0 for all streams. See {@link glBindBufferRange}.
 *
 * - {@link GL_TRANSFORM_FEEDBACK_BUFFER_SIZE}
 * When used with indexed variants of `glGet` (such as `glGetInteger64i_v`), **params** returns a single value, the size of the binding range for each transform feedback attribute stream. The initial value is 0 for all streams. See {@link glBindBufferRange}.
 *
 * - {@link GL_UNIFORM_BUFFER_BINDING}
 * When used with non-indexed variants of `glGet` (such as `glGetIntegerv`), **params** returns a single value, the name of the buffer object currently bound to the target {@link GL_UNIFORM_BUFFER}. If no buffer object is bound to this target, 0 is returned. When used with indexed variants of `glGet` (such as `glGetIntegeri_v`), **params** returns a single value, the name of the buffer object bound to the indexed uniform buffer binding point. The initial value is 0 for all targets. See {@link glBindBuffer}, {@link glBindBufferBase}, and {@link glBindBufferRange}.
 *
 * - {@link GL_UNIFORM_BUFFER_START}
 * When used with indexed variants of `glGet` (such as `glGetInteger64i_v`), **params** returns a single value, the start offset of the binding range for each indexed uniform buffer binding. The initial value is 0 for all bindings. See {@link glBindBufferRange}.
 *
 * - {@link GL_UNIFORM_BUFFER_SIZE}
 * When used with indexed variants of `glGet` (such as `glGetInteger64i_v`), **params** returns a single value, the size of the binding range for each indexed uniform buffer binding. The initial value is 0 for all bindings. See {@link glBindBufferRange}.
 *
 * - {@link GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT}
 * **params** returns a single value, the minimum required alignment for uniform buffer sizes and offset. The initial value is 1. See {@link glUniformBlockBinding}.
 *
 * - {@link GL_UNPACK_ALIGNMENT}
 * **params** returns one value, the byte alignment used for reading pixel data from memory. The initial value is 4. See {@link glPixelStore}.
 *
 * - {@link GL_UNPACK_IMAGE_HEIGHT}
 * **params** returns one value, the image height used for reading pixel data from memory. The initial is 0. See {@link glPixelStore}.
 *
 * - {@link GL_UNPACK_LSB_FIRST}
 * **params** returns a single boolean value indicating whether single-bit pixels being read from memory are read first from the least significant bit of each unsigned byte. The initial value is {@link GL_FALSE}. See {@link glPixelStore}.
 *
 * - {@link GL_UNPACK_ROW_LENGTH}
 * **params** returns one value, the row length used for reading pixel data from memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_UNPACK_SKIP_IMAGES}
 * **params** returns one value, the number of pixel images skipped before the first pixel is read from memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_UNPACK_SKIP_PIXELS}
 * **params** returns one value, the number of pixel locations skipped before the first pixel is read from memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_UNPACK_SKIP_ROWS}
 * **params** returns one value, the number of rows of pixel locations skipped before the first pixel is read from memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_UNPACK_SWAP_BYTES}
 * **params** returns a single boolean value indicating whether the bytes of two-byte and four-byte pixel indices and components are swapped after being read from memory. The initial value is {@link GL_FALSE}. See {@link glPixelStore}.
 *
 * - {@link GL_NUM_EXTENSIONS}
 * **params** returns one value, the number of extensions supported by the GL implementation for the current context. See {@link glGetString}.
 *
 * - {@link GL_MAJOR_VERSION}
 * **params** returns one value, the major version number of the OpenGL API supported by the current context.
 *
 * - {@link GL_MINOR_VERSION}
 * **params** returns one value, the minor version number of the OpenGL API supported by the current context.
 *
 * - {@link GL_CONTEXT_FLAGS}
 * **params** returns one value, the flags with which the context was created (such as debugging functionality).
 *
 * - {@link GL_VIEWPORT}
 * **params** returns four values: the 𝐱 and 𝐲 window coordinates of the viewport, followed by its width and height. Initially the 𝐱 and 𝐲 window coordinates are both set to 0, and the *width* and *height* are set to the width and height of the window into which the GL will do its rendering. See {@link glViewport}.
 *
 * Many of the boolean parameters can also be queried more easily using {@link glIsEnabled}.
 *
 * @summary return the value or values of a selected parameter
 * @param pname Specifies the parameter value to be returned. The symbolic constants in the list below are accepted.
 * @param params Returns the value or values of the specified parameter.
 * @see [glGet](https://docs.gl/gl3/glGet)
 */
export function glGetDoublev(pname: GLenum, params: GLdouble): void;

/**
 * These four commands return values for simple state variables in GL. **pname** is a symbolic constant indicating the state variable to be returned, and **params** is a pointer to an array of the indicated type in which to place the returned data.
 *
 * Type conversion is performed if **params** has a different type than the state variable value being requested. If `glGetBooleanv` is called, a floating-point (or integer) value is converted to {@link GL_FALSE} if and only if it is 0.0 (or 0). Otherwise, it is converted to {@link GL_TRUE}. If `glGetIntegerv` is called, boolean values are returned as {@link GL_TRUE} or {@link GL_FALSE}, and most floating-point values are rounded to the nearest integer value. Floating-point colors and normals, however, are returned with a linear mapping that maps 1.0 to the most positive representable integer value and −1.0 to the most negative representable integer value. If `glGetFloatv` or `glGetDoublev` is called, boolean values are returned as {@link GL_TRUE} or {@link GL_FALSE}, and integer values are converted to floating-point values.
 *
 * The following symbolic constants are accepted by **pname**:
 *
 * - {@link GL_ACTIVE_TEXTURE}
 * **params** returns a single value indicating the active multitexture unit. The initial value is {@link GL_TEXTURE0}. See {@link glActiveTexture}.
 *
 * - {@link GL_ALIASED_LINE_WIDTH_RANGE}
 * **params** returns a pair of values indicating the range of widths supported for aliased lines. See {@link glLineWidth}.
 *
 * - {@link GL_SMOOTH_LINE_WIDTH_RANGE}
 * **params** returns a pair of values indicating the range of widths supported for smooth (antialiased) lines. See {@link glLineWidth}.
 *
 * - {@link GL_SMOOTH_LINE_WIDTH_GRANULARITY}
 * **params** returns a single value indicating the level of quantization applied to smooth line width parameters.
 *
 * - {@link GL_ARRAY_BUFFER_BINDING}
 * **params** returns a single value, the name of the buffer object currently bound to the target {@link GL_ARRAY_BUFFER}. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See {@link glBindBuffer}.
 *
 * - {@link GL_BLEND}
 * **params** returns a single boolean value indicating whether blending is enabled. The initial value is {@link GL_FALSE}. See {@link glBlendFunc}.
 *
 * - {@link GL_BLEND_COLOR}
 * **params** returns four values, the red, green, blue, and alpha values which are the components of the blend color. See {@link glBlendColor}.
 *
 * - {@link GL_BLEND_DST_ALPHA}
 * **params** returns one value, the symbolic constant identifying the alpha destination blend function. The initial value is {@link GL_ZERO}. See {@link glBlendFunc} and {@link glBlendFuncSeparate}.
 *
 * - {@link GL_BLEND_DST_RGB}
 * **params** returns one value, the symbolic constant identifying the RGB destination blend function. The initial value is {@link GL_ZERO}. See {@link glBlendFunc} and {@link glBlendFuncSeparate}.
 *
 * - {@link GL_BLEND_EQUATION_RGB}
 * **params** returns one value, a symbolic constant indicating whether the RGB blend equation is {@link GL_FUNC_ADD}, {@link GL_FUNC_SUBTRACT}, {@link GL_FUNC_REVERSE_SUBTRACT}, {@link GL_MIN} or {@link GL_MAX}. See {@link glBlendEquationSeparate}.
 *
 * - {@link GL_BLEND_EQUATION_ALPHA}
 * **params** returns one value, a symbolic constant indicating whether the Alpha blend equation is {@link GL_FUNC_ADD}, {@link GL_FUNC_SUBTRACT}, {@link GL_FUNC_REVERSE_SUBTRACT}, {@link GL_MIN} or {@link GL_MAX}. See {@link glBlendEquationSeparate}.
 *
 * - {@link GL_BLEND_SRC_ALPHA}
 * **params** returns one value, the symbolic constant identifying the alpha source blend function. The initial value is {@link GL_ONE}. See {@link glBlendFunc} and {@link glBlendFuncSeparate}.
 *
 * - {@link GL_BLEND_SRC_RGB}
 * **params** returns one value, the symbolic constant identifying the RGB source blend function. The initial value is {@link GL_ONE}. See {@link glBlendFunc} and {@link glBlendFuncSeparate}.
 *
 * - {@link GL_COLOR_CLEAR_VALUE}
 * **params** returns four values: the red, green, blue, and alpha values used to clear the color buffers. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and −1.0 returns the most negative representable integer value. The initial value is (0, 0, 0, 0). See {@link glClearColor}.
 *
 * - {@link GL_COLOR_LOGIC_OP}
 * **params** returns a single boolean value indicating whether a fragment's RGBA color values are merged into the framebuffer using a logical operation. The initial value is {@link GL_FALSE}. See {@link glLogicOp}.
 *
 * - {@link GL_COLOR_WRITEMASK}
 * **params** returns four boolean values: the red, green, blue, and alpha write enables for the color buffers. The initial value is ({@link GL_TRUE}, {@link GL_TRUE}, {@link GL_TRUE}, {@link GL_TRUE}). See {@link glColorMask}.
 *
 * - {@link GL_COMPRESSED_TEXTURE_FORMATS}
 * **params** returns a list of symbolic constants of length {@link GL_NUM_COMPRESSED_TEXTURE_FORMATS} indicating which compressed texture formats are available. See {@link glCompressedTexImage2D}.
 *
 * - {@link GL_CULL_FACE}
 * **params** returns a single boolean value indicating whether polygon culling is enabled. The initial value is {@link GL_FALSE}. See {@link glCullFace}.
 *
 * - {@link GL_CURRENT_PROGRAM}
 * **params** returns one value, the name of the program object that is currently active, or 0 if no program object is active. See {@link glUseProgram}.
 *
 * - {@link GL_DEPTH_CLEAR_VALUE}
 * **params** returns one value, the value that is used to clear the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. The initial value is 1. See {@link glClearDepth}.
 *
 * - {@link GL_DEPTH_FUNC}
 * **params** returns one value, the symbolic constant that indicates the depth comparison function. The initial value is {@link GL_LESS}. See {@link glDepthFunc}.
 *
 * - {@link GL_DEPTH_RANGE}
 * **params** returns two values: the near and far mapping limits for the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and −1.0 returns the most negative representable integer value. The initial value is (0, 1). See {@link glDepthRange}.
 *
 * - {@link GL_DEPTH_TEST}
 * **params** returns a single boolean value indicating whether depth testing of fragments is enabled. The initial value is {@link GL_FALSE}. See {@link glDepthFunc} and {@link glDepthRange}.
 *
 * - {@link GL_DEPTH_WRITEMASK}
 * **params** returns a single boolean value indicating if the depth buffer is enabled for writing. The initial value is {@link GL_TRUE}. See {@link glDepthMask}.
 *
 * - {@link GL_DITHER}
 * **params** returns a single boolean value indicating whether dithering of fragment colors and indices is enabled. The initial value is {@link GL_TRUE}.
 *
 * - {@link GL_DOUBLEBUFFER}
 * **params** returns a single boolean value indicating whether double buffering is supported.
 *
 * - {@link GL_DRAW_BUFFER}
 * **params** returns one value, a symbolic constant indicating which buffers are being drawn to. See {@link glDrawBuffer}. The initial value is {@link GL_BACK} if there are back buffers, otherwise it is {@link GL_FRONT}.
 *
 * - {@link GL_DRAW_BUFFER}**i**
 * **params** returns one value, a symbolic constant indicating which buffers are being drawn to by the corresponding output color. See {@link glDrawBuffers}. The initial value of {@link GL_DRAW_BUFFER0} is {@link GL_BACK} if there are back buffers, otherwise it is {@link GL_FRONT}. The initial values of draw buffers for all other output colors is {@link GL_NONE}.
 *
 * - {@link GL_DRAW_FRAMEBUFFER_BINDING}
 * **params** returns one value, the name of the framebuffer object currently bound to the {@link GL_DRAW_FRAMEBUFFER} target. If the default framebuffer is bound, this value will be zero. The initial value is zero. See {@link glBindFramebuffer}.
 *
 * - {@link GL_READ_FRAMEBUFFER_BINDING}
 * **params** returns one value, the name of the framebuffer object currently bound to the {@link GL_READ_FRAMEBUFFER} target. If the default framebuffer is bound, this value will be zero. The initial value is zero. See {@link glBindFramebuffer}.
 *
 * - {@link GL_ELEMENT_ARRAY_BUFFER_BINDING}
 * **params** returns a single value, the name of the buffer object currently bound to the target {@link GL_ELEMENT_ARRAY_BUFFER}. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See {@link glBindBuffer}.
 *
 * - {@link GL_RENDERBUFFER_BINDING}
 * **params** returns a single value, the name of the renderbuffer object currently bound to the target {@link GL_RENDERBUFFER}. If no renderbuffer object is bound to this target, 0 is returned. The initial value is 0. See {@link glBindRenderbuffer}.
 *
 * - {@link GL_FRAGMENT_SHADER_DERIVATIVE_HINT}
 * **params** returns one value, a symbolic constant indicating the mode of the derivative accuracy hint for fragment shaders. The initial value is {@link GL_DONT_CARE}. See {@link glHint}.
 *
 * - {@link GL_LINE_SMOOTH}
 * **params** returns a single boolean value indicating whether antialiasing of lines is enabled. The initial value is {@link GL_FALSE}. See {@link glLineWidth}.
 *
 * - {@link GL_LINE_SMOOTH_HINT}
 * **params** returns one value, a symbolic constant indicating the mode of the line antialiasing hint. The initial value is {@link GL_DONT_CARE}. See {@link glHint}.
 *
 * - {@link GL_LINE_WIDTH}
 * **params** returns one value, the line width as specified with {@link glLineWidth}. The initial value is 1.
 *
 * - {@link GL_LOGIC_OP_MODE}
 * **params** returns one value, a symbolic constant indicating the selected logic operation mode. The initial value is {@link GL_COPY}. See {@link glLogicOp}.
 *
 * - {@link GL_MAX_3D_TEXTURE_SIZE}
 * **params** returns one value, a rough estimate of the largest 3D texture that the GL can handle. The value must be at least 64. Use {@link GL_PROXY_TEXTURE_3D} to determine if a texture is too large. See {@link glTexImage3D}.
 *
 * - {@link GL_MAX_CLIP_DISTANCES}
 * **params** returns one value, the maximum number of application-defined clipping distances. The value must be at least 8.
 *
 * - {@link GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS}
 * **params** returns one value, the number of words for fragment shader uniform variables in all uniform blocks (including default). The value must be at least 1. See {@link glUniform}.
 *
 * - {@link GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS}
 * **params** returns one value, the maximum supported texture image units that can be used to access texture maps from the vertex shader and the fragment processor combined. If both the vertex shader and the fragment processing stage access the same texture image unit, then that counts as using two texture image units against this limit. The value must be at least 48. See {@link glActiveTexture}.
 *
 * - {@link GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS}
 * **params** returns one value, the number of words for vertex shader uniform variables in all uniform blocks (including default). The value must be at least 1. See {@link glUniform}.
 *
 * - {@link GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS}
 * **params** returns one value, the number of words for geometry shader uniform variables in all uniform blocks (including default). The value must be at least 1. See {@link glUniform}.
 *
 * - {@link GL_MAX_VARYING_COMPONENTS}
 * **params** returns one value, the number components for varying variables, which must be at least 60.
 *
 * - {@link GL_MAX_COMBINED_UNIFORM_BLOCKS}
 * **params** returns one value, the maximum number of uniform blocks per program. The value must be at least 36. See {@link glUniformBlockBinding}.
 *
 * - {@link GL_MAX_CUBE_MAP_TEXTURE_SIZE}
 * **params** returns one value. The value gives a rough estimate of the largest cube-map texture that the GL can handle. The value must be at least 1024. Use {@link GL_PROXY_TEXTURE_CUBE_MAP} to determine if a texture is too large. See {@link glTexImage2D}.
 *
 * - {@link GL_MAX_DRAW_BUFFERS}
 * **params** returns one value, the maximum number of simultaneous outputs that may be written in a fragment shader. The value must be at least 8. See {@link glDrawBuffers}.
 *
 * - {@link GL_MAX_DUAL_SOURCE_DRAW_BUFFERS}
 * **params** returns one value, the maximum number of active draw buffers when using dual-source blending. The value must be at least 1. See {@link glBlendFunc} and {@link glBlendFuncSeparate}.
 *
 * - {@link GL_MAX_ELEMENTS_INDICES}
 * **params** returns one value, the recommended maximum number of vertex array indices. See {@link glDrawRangeElements}.
 *
 * - {@link GL_MAX_ELEMENTS_VERTICES}
 * **params** returns one value, the recommended maximum number of vertex array vertices. See {@link glDrawRangeElements}.
 *
 * - {@link GL_MAX_FRAGMENT_UNIFORM_COMPONENTS}
 * **params** returns one value, the maximum number of individual floating-point, integer, or boolean values that can be held in uniform variable storage for a fragment shader. The value must be at least 1024. See {@link glUniform}.
 *
 * - {@link GL_MAX_FRAGMENT_UNIFORM_BLOCKS}
 * **params** returns one value, the maximum number of uniform blocks per fragment shader. The value must be at least 12. See {@link glUniformBlockBinding}.
 *
 * - {@link GL_MAX_FRAGMENT_INPUT_COMPONENTS}
 * **params** returns one value, the maximum number of components of the inputs read by the fragment shader, which must be at least 128.
 *
 * - {@link GL_MIN_PROGRAM_TEXEL_OFFSET}
 * **params** returns one value, the minimum texel offset allowed in a texture lookup, which must be at most -8.
 *
 * - {@link GL_MAX_PROGRAM_TEXEL_OFFSET}
 * **params** returns one value, the maximum texel offset allowed in a texture lookup, which must be at least 7.
 *
 * - {@link GL_MAX_RECTANGLE_TEXTURE_SIZE}
 * **params** returns one value. The value gives a rough estimate of the largest rectangular texture that the GL can handle. The value must be at least 1024. Use {@link GL_PROXY_TEXTURE_RECTANGLE} to determine if a texture is too large. See {@link glTexImage2D}.
 *
 * - {@link GL_MAX_TEXTURE_IMAGE_UNITS}
 * **params** returns one value, the maximum supported texture image units that can be used to access texture maps from the fragment shader. The value must be at least 16. See {@link glActiveTexture}.
 *
 * - {@link GL_MAX_TEXTURE_LOD_BIAS}
 * **params** returns one value, the maximum, absolute value of the texture level-of-detail bias. The value must be at least 2.0.
 *
 * - {@link GL_MAX_TEXTURE_SIZE}
 * **params** returns one value. The value gives a rough estimate of the largest texture that the GL can handle. The value must be at least 1024. Use a proxy texture target such as {@link GL_PROXY_TEXTURE_1D} or {@link GL_PROXY_TEXTURE_2D} to determine if a texture is too large. See {@link glTexImage1D} and {@link glTexImage2D}.
 *
 * - {@link GL_MAX_RENDERBUFFER_SIZE}
 * **params** returns one value. The value indicates the maximum supported size for renderbuffers. See {@link glFramebufferRenderbuffer}.
 *
 * - {@link GL_MAX_ARRAY_TEXTURE_LAYERS}
 * **params** returns one value. The value indicates the maximum number of layers allowed in an array texture, and must be at least 256. See {@link glTexImage2D}.
 *
 * - {@link GL_MAX_TEXTURE_BUFFER_SIZE}
 * **params** returns one value. The value gives the maximum number of texels allowed in the texel array of a texture buffer object. Value must be at least 65536.
 *
 * - {@link GL_MAX_UNIFORM_BLOCK_SIZE}
 * **params** returns one value, the maximum size in basic machine units of a uniform block. The value must be at least 16384. See {@link glUniformBlockBinding}.
 *
 * - {@link GL_MAX_VARYING_FLOATS}
 * **params** returns one value, the maximum number of interpolators available for processing varying variables used by vertex and fragment shaders. This value represents the number of individual floating-point values that can be interpolated; varying variables declared as vectors, matrices, and arrays will all consume multiple interpolators. The value must be at least 32.
 *
 * - {@link GL_MAX_VERTEX_ATTRIBS}
 * **params** returns one value, the maximum number of 4-component generic vertex attributes accessible to a vertex shader. The value must be at least 16. See {@link glVertexAttrib}.
 *
 * - {@link GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS}
 * **params** returns one value, the maximum supported texture image units that can be used to access texture maps from the vertex shader. The value may be at least 16. See {@link glActiveTexture}.
 *
 * - {@link GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS}
 * **params** returns one value, the maximum supported texture image units that can be used to access texture maps from the geometry shader. The value must be at least 16. See {@link glActiveTexture}.
 *
 * - {@link GL_MAX_VERTEX_UNIFORM_COMPONENTS}
 * **params** returns one value, the maximum number of individual floating-point, integer, or boolean values that can be held in uniform variable storage for a vertex shader. The value must be at least 1024. See {@link glUniform}.
 *
 * - {@link GL_MAX_VERTEX_OUTPUT_COMPONENTS}
 * **params** returns one value, the maximum number of components of output written by a vertex shader, which must be at least 64.
 *
 * - {@link GL_MAX_GEOMETRY_UNIFORM_COMPONENTS}
 * **params** returns one value, the maximum number of individual floating-point, integer, or boolean values that can be held in uniform variable storage for a geometry shader. The value must be at least 1024. See {@link glUniform}.
 *
 * - {@link GL_MAX_SAMPLE_MASK_WORDS}
 * **params** returns one value, the maximum number of sample mask words.
 *
 * - {@link GL_MAX_COLOR_TEXTURE_SAMPLES}
 * **params** returns one value, the maximum number of samples in a color multisample texture.
 *
 * - {@link GL_MAX_DEPTH_TEXTURE_SAMPLES}
 * **params** returns one value, the maximum number of samples in a multisample depth or depth-stencil texture.
 *
 * - {@link GL_MAX_DEPTH_TEXTURE_SAMPLES}
 * **params** returns one value, the maximum number of samples in a multisample depth or depth-stencil texture.
 *
 * - {@link GL_MAX_INTEGER_SAMPLES}
 * **params** returns one value, the maximum number of samples supported in integer format multisample buffers.
 *
 * - {@link GL_MAX_SERVER_WAIT_TIMEOUT}
 * **params** returns one value, the maximum {@link glWaitSync} timeout interval.
 *
 * - {@link GL_MAX_UNIFORM_BUFFER_BINDINGS}
 * **params** returns one value, the maximum number of uniform buffer binding points on the context, which must be at least 36.
 *
 * - {@link GL_MAX_UNIFORM_BLOCK_SIZE}
 * **params** returns one value, the maximum size in basic machine units of a uniform block, which must be at least 16384.
 *
 * - {@link GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT}
 * **params** returns one value, the minimum required alignment for uniform buffer sizes and offsets.
 *
 * - {@link GL_MAX_VERTEX_UNIFORM_BLOCKS}
 * **params** returns one value, the maximum number of uniform blocks per vertex shader. The value must be at least 12. See {@link glUniformBlockBinding}.
 *
 * - {@link GL_MAX_GEOMETRY_UNIFORM_BLOCKS}
 * **params** returns one value, the maximum number of uniform blocks per geometry shader. The value must be at least 12. See {@link glUniformBlockBinding}.
 *
 * - {@link GL_MAX_GEOMETRY_INPUT_COMPONENTS}
 * **params** returns one value, the maximum number of components of inputs read by a geometry shader, which must be at least 64.
 *
 * - {@link GL_MAX_GEOMETRY_OUTPUT_COMPONENTS}
 * **params** returns one value, the maximum number of components of outputs written by a geometry shader, which must be at least 128.
 *
 * - {@link GL_MAX_VIEWPORT_DIMS}
 * **params** returns two values: the maximum supported width and height of the viewport. These must be at least as large as the visible dimensions of the display being rendered to. See {@link glViewport}.
 *
 * - {@link GL_NUM_COMPRESSED_TEXTURE_FORMATS}
 * **params** returns a single integer value indicating the number of available compressed texture formats. The minimum value is 4. See {@link glCompressedTexImage2D}.
 *
 * - {@link GL_PACK_ALIGNMENT}
 * **params** returns one value, the byte alignment used for writing pixel data to memory. The initial value is 4. See {@link glPixelStore}.
 *
 * - {@link GL_PACK_IMAGE_HEIGHT}
 * **params** returns one value, the image height used for writing pixel data to memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_PACK_LSB_FIRST}
 * **params** returns a single boolean value indicating whether single-bit pixels being written to memory are written first to the least significant bit of each unsigned byte. The initial value is {@link GL_FALSE}. See {@link glPixelStore}.
 *
 * - {@link GL_PACK_ROW_LENGTH}
 * **params** returns one value, the row length used for writing pixel data to memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_PACK_SKIP_IMAGES}
 * **params** returns one value, the number of pixel images skipped before the first pixel is written into memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_PACK_SKIP_PIXELS}
 * **params** returns one value, the number of pixel locations skipped before the first pixel is written into memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_PACK_SKIP_ROWS}
 * **params** returns one value, the number of rows of pixel locations skipped before the first pixel is written into memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_PACK_SWAP_BYTES}
 * **params** returns a single boolean value indicating whether the bytes of two-byte and four-byte pixel indices and components are swapped before being written to memory. The initial value is {@link GL_FALSE}. See {@link glPixelStore}.
 *
 * - {@link GL_PIXEL_PACK_BUFFER_BINDING}
 * **params** returns a single value, the name of the buffer object currently bound to the target {@link GL_PIXEL_PACK_BUFFER}. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See {@link glBindBuffer}.
 *
 * - {@link GL_PIXEL_UNPACK_BUFFER_BINDING}
 * **params** returns a single value, the name of the buffer object currently bound to the target {@link GL_PIXEL_UNPACK_BUFFER}. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See {@link glBindBuffer}.
 *
 * - {@link GL_POINT_FADE_THRESHOLD_SIZE}
 * **params** returns one value, the point size threshold for determining the point size. See {@link glPointParameter}.
 *
 * - {@link GL_PRIMITIVE_RESTART_INDEX}
 * **params** returns one value, the current primitive restart index. The initial value is 0. See {@link glPrimitiveRestartIndex}.
 *
 * - {@link GL_PROGRAM_POINT_SIZE}
 * **params** returns a single boolean value indicating whether vertex program point size mode is enabled. If enabled, then the point size is taken from the shader built-in gl_PointSize. If disabled, then the point size is taken from the point state as specified by {@link glPointSize}. The initial value is {@link GL_FALSE}.
 *
 * - {@link GL_PROVOKING_VERTEX}
 * **params** returns one value, the currently selected provoking vertex convention. The initial value is {@link GL_LAST_VERTEX_CONVENTION}. See {@link glProvokingVertex}.
 *
 * - {@link GL_POINT_SIZE}
 * **params** returns one value, the point size as specified by {@link glPointSize}. The initial value is 1.
 *
 * - {@link GL_POINT_SIZE_GRANULARITY}
 * **params** returns one value, the size difference between adjacent supported sizes for antialiased points. See {@link glPointSize}.
 *
 * - {@link GL_POINT_SIZE_RANGE}
 * **params** returns two values: the smallest and largest supported sizes for antialiased points. The smallest size must be at most 1, and the largest size must be at least 1. See {@link glPointSize}.
 *
 * - {@link GL_POLYGON_OFFSET_FACTOR}
 * **params** returns one value, the scaling factor used to determine the variable offset that is added to the depth value of each fragment generated when a polygon is rasterized. The initial value is 0. See {@link glPolygonOffset}.
 *
 * - {@link GL_POLYGON_OFFSET_UNITS}
 * **params** returns one value. This value is multiplied by an implementation-specific value and then added to the depth value of each fragment generated when a polygon is rasterized. The initial value is 0. See {@link glPolygonOffset}.
 *
 * - {@link GL_POLYGON_OFFSET_FILL}
 * **params** returns a single boolean value indicating whether polygon offset is enabled for polygons in fill mode. The initial value is {@link GL_FALSE}. See {@link glPolygonOffset}.
 *
 * - {@link GL_POLYGON_OFFSET_LINE}
 * **params** returns a single boolean value indicating whether polygon offset is enabled for polygons in line mode. The initial value is {@link GL_FALSE}. See {@link glPolygonOffset}.
 *
 * - {@link GL_POLYGON_OFFSET_POINT}
 * **params** returns a single boolean value indicating whether polygon offset is enabled for polygons in point mode. The initial value is {@link GL_FALSE}. See {@link glPolygonOffset}.
 *
 * - {@link GL_POLYGON_SMOOTH}
 * **params** returns a single boolean value indicating whether antialiasing of polygons is enabled. The initial value is {@link GL_FALSE}. See {@link glPolygonMode}.
 *
 * - {@link GL_POLYGON_SMOOTH_HINT}
 * **params** returns one value, a symbolic constant indicating the mode of the polygon antialiasing hint. The initial value is {@link GL_DONT_CARE}. See {@link glHint}.
 *
 * - {@link GL_READ_BUFFER}
 * **params** returns one value, a symbolic constant indicating which color buffer is selected for reading. The initial value is {@link GL_BACK} if there is a back buffer, otherwise it is {@link GL_FRONT}. See {@link glReadPixels}.
 *
 * - {@link GL_SAMPLE_BUFFERS}
 * **params** returns a single integer value indicating the number of sample buffers associated with the framebuffer. See {@link glSampleCoverage}.
 *
 * - {@link GL_SAMPLE_COVERAGE_VALUE}
 * **params** returns a single positive floating-point value indicating the current sample coverage value. See {@link glSampleCoverage}.
 *
 * - {@link GL_SAMPLE_COVERAGE_INVERT}
 * **params** returns a single boolean value indicating if the temporary coverage value should be inverted. See {@link glSampleCoverage}.
 *
 * - {@link GL_SAMPLER_BINDING}
 * **params** returns a single value, the name of the sampler object currently bound to the active texture unit. The initial value is 0. See {@link glBindSampler}.
 *
 * - {@link GL_SAMPLES}
 * **params** returns a single integer value indicating the coverage mask size. See {@link glSampleCoverage}.
 *
 * - {@link GL_SCISSOR_BOX}
 * **params** returns four values: the 𝐱 and 𝐲 window coordinates of the scissor box, followed by its width and height. Initially the 𝐱 and 𝐲 window coordinates are both 0 and the *width* and *height* are set to the size of the window. See {@link glScissor}.
 *
 * - {@link GL_SCISSOR_TEST}
 * **params** returns a single boolean value indicating whether scissoring is enabled. The initial value is {@link GL_FALSE}. See {@link glScissor}.
 *
 * - {@link GL_STENCIL_BACK_FAIL}
 * **params** returns one value, a symbolic constant indicating what action is taken for back-facing polygons when the stencil test fails. The initial value is {@link GL_KEEP}. See {@link glStencilOpSeparate}.
 *
 * - {@link GL_STENCIL_BACK_FUNC}
 * **params** returns one value, a symbolic constant indicating what function is used for back-facing polygons to compare the stencil reference value with the stencil buffer value. The initial value is {@link GL_ALWAYS}. See {@link glStencilFuncSeparate}.
 *
 * - {@link GL_STENCIL_BACK_PASS_DEPTH_FAIL}
 * **params** returns one value, a symbolic constant indicating what action is taken for back-facing polygons when the stencil test passes, but the depth test fails. The initial value is {@link GL_KEEP}. See {@link glStencilOpSeparate}.
 *
 * - {@link GL_STENCIL_BACK_PASS_DEPTH_PASS}
 * **params** returns one value, a symbolic constant indicating what action is taken for back-facing polygons when the stencil test passes and the depth test passes. The initial value is {@link GL_KEEP}. See {@link glStencilOpSeparate}.
 *
 * - {@link GL_STENCIL_BACK_REF}
 * **params** returns one value, the reference value that is compared with the contents of the stencil buffer for back-facing polygons. The initial value is 0. See {@link glStencilFuncSeparate}.
 *
 * - {@link GL_STENCIL_BACK_VALUE_MASK}
 * **params** returns one value, the mask that is used for back-facing polygons to mask both the stencil reference value and the stencil buffer value before they are compared. The initial value is all 1's. See {@link glStencilFuncSeparate}.
 *
 * - {@link GL_STENCIL_BACK_WRITEMASK}
 * **params** returns one value, the mask that controls writing of the stencil bitplanes for back-facing polygons. The initial value is all 1's. See {@link glStencilMaskSeparate}.
 *
 * - {@link GL_STENCIL_CLEAR_VALUE}
 * **params** returns one value, the index to which the stencil bitplanes are cleared. The initial value is 0. See {@link glClearStencil}.
 *
 * - {@link GL_STENCIL_FAIL}
 * **params** returns one value, a symbolic constant indicating what action is taken when the stencil test fails. The initial value is {@link GL_KEEP}. See {@link glStencilOp}. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See {@link glStencilOpSeparate}.
 *
 * - {@link GL_STENCIL_FUNC}
 * **params** returns one value, a symbolic constant indicating what function is used to compare the stencil reference value with the stencil buffer value. The initial value is {@link GL_ALWAYS}. See {@link glStencilFunc}. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See {@link glStencilFuncSeparate}.
 *
 * - {@link GL_STENCIL_PASS_DEPTH_FAIL}
 * **params** returns one value, a symbolic constant indicating what action is taken when the stencil test passes, but the depth test fails. The initial value is {@link GL_KEEP}. See {@link glStencilOp}. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See {@link glStencilOpSeparate}.
 *
 * - {@link GL_STENCIL_PASS_DEPTH_PASS}
 * **params** returns one value, a symbolic constant indicating what action is taken when the stencil test passes and the depth test passes. The initial value is {@link GL_KEEP}. See {@link glStencilOp}. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See {@link glStencilOpSeparate}.
 *
 * - {@link GL_STENCIL_REF}
 * **params** returns one value, the reference value that is compared with the contents of the stencil buffer. The initial value is 0. See {@link glStencilFunc}. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See {@link glStencilFuncSeparate}.
 *
 * - {@link GL_STENCIL_TEST}
 * **params** returns a single boolean value indicating whether stencil testing of fragments is enabled. The initial value is {@link GL_FALSE}. See {@link glStencilFunc} and {@link glStencilOp}.
 *
 * - {@link GL_STENCIL_VALUE_MASK}
 * **params** returns one value, the mask that is used to mask both the stencil reference value and the stencil buffer value before they are compared. The initial value is all 1's. See {@link glStencilFunc}. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See {@link glStencilFuncSeparate}.
 *
 * - {@link GL_STENCIL_WRITEMASK}
 * **params** returns one value, the mask that controls writing of the stencil bitplanes. The initial value is all 1's. See {@link glStencilMask}. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See {@link glStencilMaskSeparate}.
 *
 * - {@link GL_STEREO}
 * **params** returns a single boolean value indicating whether stereo buffers (left and right) are supported.
 *
 * - {@link GL_SUBPIXEL_BITS}
 * **params** returns one value, an estimate of the number of bits of subpixel resolution that are used to position rasterized geometry in window coordinates. The value must be at least 4.
 *
 * - {@link GL_TEXTURE_BINDING_1D}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_1D}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_1D_ARRAY}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_1D_ARRAY}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_2D}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_2D}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_2D_ARRAY}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_2D_ARRAY}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_2D_MULTISAMPLE}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_2D_MULTISAMPLE}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_2D_MULTISAMPLE_ARRAY}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_3D}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_3D}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_BUFFER}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_BUFFER}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_CUBE_MAP}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_CUBE_MAP}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_RECTANGLE}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_RECTANGLE}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_COMPRESSION_HINT}
 * **params** returns a single value indicating the mode of the texture compression hint. The initial value is {@link GL_DONT_CARE}.
 *
 * - {@link GL_TEXTURE_BINDING_BUFFER}
 * **params** returns a single value, the name of the texture buffer object currently bound. The initial value is 0. See {@link glBindBuffer}.
 *
 * - {@link GL_TIMESTAMP}
 * **params** returns a single value, the 64-bit value of the current GL time. See {@link glQueryCounter}.
 *
 * - {@link GL_TRANSFORM_FEEDBACK_BUFFER_BINDING}
 * When used with non-indexed variants of `glGet` (such as `glGetIntegerv`), **params** returns a single value, the name of the buffer object currently bound to the target {@link GL_TRANSFORM_FEEDBACK_BUFFER}. If no buffer object is bound to this target, 0 is returned. When used with indexed variants of `glGet` (such as `glGetIntegeri_v`), **params** returns a single value, the name of the buffer object bound to the indexed transform feedback attribute stream. The initial value is 0 for all targets. See {@link glBindBuffer}, {@link glBindBufferBase}, and {@link glBindBufferRange}.
 *
 * - {@link GL_TRANSFORM_FEEDBACK_BUFFER_START}
 * When used with indexed variants of `glGet` (such as `glGetInteger64i_v`), **params** returns a single value, the start offset of the binding range for each transform feedback attribute stream. The initial value is 0 for all streams. See {@link glBindBufferRange}.
 *
 * - {@link GL_TRANSFORM_FEEDBACK_BUFFER_SIZE}
 * When used with indexed variants of `glGet` (such as `glGetInteger64i_v`), **params** returns a single value, the size of the binding range for each transform feedback attribute stream. The initial value is 0 for all streams. See {@link glBindBufferRange}.
 *
 * - {@link GL_UNIFORM_BUFFER_BINDING}
 * When used with non-indexed variants of `glGet` (such as `glGetIntegerv`), **params** returns a single value, the name of the buffer object currently bound to the target {@link GL_UNIFORM_BUFFER}. If no buffer object is bound to this target, 0 is returned. When used with indexed variants of `glGet` (such as `glGetIntegeri_v`), **params** returns a single value, the name of the buffer object bound to the indexed uniform buffer binding point. The initial value is 0 for all targets. See {@link glBindBuffer}, {@link glBindBufferBase}, and {@link glBindBufferRange}.
 *
 * - {@link GL_UNIFORM_BUFFER_START}
 * When used with indexed variants of `glGet` (such as `glGetInteger64i_v`), **params** returns a single value, the start offset of the binding range for each indexed uniform buffer binding. The initial value is 0 for all bindings. See {@link glBindBufferRange}.
 *
 * - {@link GL_UNIFORM_BUFFER_SIZE}
 * When used with indexed variants of `glGet` (such as `glGetInteger64i_v`), **params** returns a single value, the size of the binding range for each indexed uniform buffer binding. The initial value is 0 for all bindings. See {@link glBindBufferRange}.
 *
 * - {@link GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT}
 * **params** returns a single value, the minimum required alignment for uniform buffer sizes and offset. The initial value is 1. See {@link glUniformBlockBinding}.
 *
 * - {@link GL_UNPACK_ALIGNMENT}
 * **params** returns one value, the byte alignment used for reading pixel data from memory. The initial value is 4. See {@link glPixelStore}.
 *
 * - {@link GL_UNPACK_IMAGE_HEIGHT}
 * **params** returns one value, the image height used for reading pixel data from memory. The initial is 0. See {@link glPixelStore}.
 *
 * - {@link GL_UNPACK_LSB_FIRST}
 * **params** returns a single boolean value indicating whether single-bit pixels being read from memory are read first from the least significant bit of each unsigned byte. The initial value is {@link GL_FALSE}. See {@link glPixelStore}.
 *
 * - {@link GL_UNPACK_ROW_LENGTH}
 * **params** returns one value, the row length used for reading pixel data from memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_UNPACK_SKIP_IMAGES}
 * **params** returns one value, the number of pixel images skipped before the first pixel is read from memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_UNPACK_SKIP_PIXELS}
 * **params** returns one value, the number of pixel locations skipped before the first pixel is read from memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_UNPACK_SKIP_ROWS}
 * **params** returns one value, the number of rows of pixel locations skipped before the first pixel is read from memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_UNPACK_SWAP_BYTES}
 * **params** returns a single boolean value indicating whether the bytes of two-byte and four-byte pixel indices and components are swapped after being read from memory. The initial value is {@link GL_FALSE}. See {@link glPixelStore}.
 *
 * - {@link GL_NUM_EXTENSIONS}
 * **params** returns one value, the number of extensions supported by the GL implementation for the current context. See {@link glGetString}.
 *
 * - {@link GL_MAJOR_VERSION}
 * **params** returns one value, the major version number of the OpenGL API supported by the current context.
 *
 * - {@link GL_MINOR_VERSION}
 * **params** returns one value, the minor version number of the OpenGL API supported by the current context.
 *
 * - {@link GL_CONTEXT_FLAGS}
 * **params** returns one value, the flags with which the context was created (such as debugging functionality).
 *
 * - {@link GL_VIEWPORT}
 * **params** returns four values: the 𝐱 and 𝐲 window coordinates of the viewport, followed by its width and height. Initially the 𝐱 and 𝐲 window coordinates are both set to 0, and the *width* and *height* are set to the width and height of the window into which the GL will do its rendering. See {@link glViewport}.
 *
 * Many of the boolean parameters can also be queried more easily using {@link glIsEnabled}.
 *
 * @summary return the value or values of a selected parameter
 * @param pname Specifies the parameter value to be returned. The symbolic constants in the list below are accepted.
 * @param params Returns the value or values of the specified parameter.
 * @see [glGet](https://docs.gl/gl3/glGet)
 */
export function glGetFloatv(pname: GLenum, params: GLfloat): void;

/**
 * These four commands return values for simple state variables in GL. **pname** is a symbolic constant indicating the state variable to be returned, and **params** is a pointer to an array of the indicated type in which to place the returned data.
 *
 * Type conversion is performed if **params** has a different type than the state variable value being requested. If `glGetBooleanv` is called, a floating-point (or integer) value is converted to {@link GL_FALSE} if and only if it is 0.0 (or 0). Otherwise, it is converted to {@link GL_TRUE}. If `glGetIntegerv` is called, boolean values are returned as {@link GL_TRUE} or {@link GL_FALSE}, and most floating-point values are rounded to the nearest integer value. Floating-point colors and normals, however, are returned with a linear mapping that maps 1.0 to the most positive representable integer value and −1.0 to the most negative representable integer value. If `glGetFloatv` or `glGetDoublev` is called, boolean values are returned as {@link GL_TRUE} or {@link GL_FALSE}, and integer values are converted to floating-point values.
 *
 * The following symbolic constants are accepted by **pname**:
 *
 * - {@link GL_ACTIVE_TEXTURE}
 * **params** returns a single value indicating the active multitexture unit. The initial value is {@link GL_TEXTURE0}. See {@link glActiveTexture}.
 *
 * - {@link GL_ALIASED_LINE_WIDTH_RANGE}
 * **params** returns a pair of values indicating the range of widths supported for aliased lines. See {@link glLineWidth}.
 *
 * - {@link GL_SMOOTH_LINE_WIDTH_RANGE}
 * **params** returns a pair of values indicating the range of widths supported for smooth (antialiased) lines. See {@link glLineWidth}.
 *
 * - {@link GL_SMOOTH_LINE_WIDTH_GRANULARITY}
 * **params** returns a single value indicating the level of quantization applied to smooth line width parameters.
 *
 * - {@link GL_ARRAY_BUFFER_BINDING}
 * **params** returns a single value, the name of the buffer object currently bound to the target {@link GL_ARRAY_BUFFER}. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See {@link glBindBuffer}.
 *
 * - {@link GL_BLEND}
 * **params** returns a single boolean value indicating whether blending is enabled. The initial value is {@link GL_FALSE}. See {@link glBlendFunc}.
 *
 * - {@link GL_BLEND_COLOR}
 * **params** returns four values, the red, green, blue, and alpha values which are the components of the blend color. See {@link glBlendColor}.
 *
 * - {@link GL_BLEND_DST_ALPHA}
 * **params** returns one value, the symbolic constant identifying the alpha destination blend function. The initial value is {@link GL_ZERO}. See {@link glBlendFunc} and {@link glBlendFuncSeparate}.
 *
 * - {@link GL_BLEND_DST_RGB}
 * **params** returns one value, the symbolic constant identifying the RGB destination blend function. The initial value is {@link GL_ZERO}. See {@link glBlendFunc} and {@link glBlendFuncSeparate}.
 *
 * - {@link GL_BLEND_EQUATION_RGB}
 * **params** returns one value, a symbolic constant indicating whether the RGB blend equation is {@link GL_FUNC_ADD}, {@link GL_FUNC_SUBTRACT}, {@link GL_FUNC_REVERSE_SUBTRACT}, {@link GL_MIN} or {@link GL_MAX}. See {@link glBlendEquationSeparate}.
 *
 * - {@link GL_BLEND_EQUATION_ALPHA}
 * **params** returns one value, a symbolic constant indicating whether the Alpha blend equation is {@link GL_FUNC_ADD}, {@link GL_FUNC_SUBTRACT}, {@link GL_FUNC_REVERSE_SUBTRACT}, {@link GL_MIN} or {@link GL_MAX}. See {@link glBlendEquationSeparate}.
 *
 * - {@link GL_BLEND_SRC_ALPHA}
 * **params** returns one value, the symbolic constant identifying the alpha source blend function. The initial value is {@link GL_ONE}. See {@link glBlendFunc} and {@link glBlendFuncSeparate}.
 *
 * - {@link GL_BLEND_SRC_RGB}
 * **params** returns one value, the symbolic constant identifying the RGB source blend function. The initial value is {@link GL_ONE}. See {@link glBlendFunc} and {@link glBlendFuncSeparate}.
 *
 * - {@link GL_COLOR_CLEAR_VALUE}
 * **params** returns four values: the red, green, blue, and alpha values used to clear the color buffers. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and −1.0 returns the most negative representable integer value. The initial value is (0, 0, 0, 0). See {@link glClearColor}.
 *
 * - {@link GL_COLOR_LOGIC_OP}
 * **params** returns a single boolean value indicating whether a fragment's RGBA color values are merged into the framebuffer using a logical operation. The initial value is {@link GL_FALSE}. See {@link glLogicOp}.
 *
 * - {@link GL_COLOR_WRITEMASK}
 * **params** returns four boolean values: the red, green, blue, and alpha write enables for the color buffers. The initial value is ({@link GL_TRUE}, {@link GL_TRUE}, {@link GL_TRUE}, {@link GL_TRUE}). See {@link glColorMask}.
 *
 * - {@link GL_COMPRESSED_TEXTURE_FORMATS}
 * **params** returns a list of symbolic constants of length {@link GL_NUM_COMPRESSED_TEXTURE_FORMATS} indicating which compressed texture formats are available. See {@link glCompressedTexImage2D}.
 *
 * - {@link GL_CULL_FACE}
 * **params** returns a single boolean value indicating whether polygon culling is enabled. The initial value is {@link GL_FALSE}. See {@link glCullFace}.
 *
 * - {@link GL_CURRENT_PROGRAM}
 * **params** returns one value, the name of the program object that is currently active, or 0 if no program object is active. See {@link glUseProgram}.
 *
 * - {@link GL_DEPTH_CLEAR_VALUE}
 * **params** returns one value, the value that is used to clear the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and -1.0 returns the most negative representable integer value. The initial value is 1. See {@link glClearDepth}.
 *
 * - {@link GL_DEPTH_FUNC}
 * **params** returns one value, the symbolic constant that indicates the depth comparison function. The initial value is {@link GL_LESS}. See {@link glDepthFunc}.
 *
 * - {@link GL_DEPTH_RANGE}
 * **params** returns two values: the near and far mapping limits for the depth buffer. Integer values, if requested, are linearly mapped from the internal floating-point representation such that 1.0 returns the most positive representable integer value, and −1.0 returns the most negative representable integer value. The initial value is (0, 1). See {@link glDepthRange}.
 *
 * - {@link GL_DEPTH_TEST}
 * **params** returns a single boolean value indicating whether depth testing of fragments is enabled. The initial value is {@link GL_FALSE}. See {@link glDepthFunc} and {@link glDepthRange}.
 *
 * - {@link GL_DEPTH_WRITEMASK}
 * **params** returns a single boolean value indicating if the depth buffer is enabled for writing. The initial value is {@link GL_TRUE}. See {@link glDepthMask}.
 *
 * - {@link GL_DITHER}
 * **params** returns a single boolean value indicating whether dithering of fragment colors and indices is enabled. The initial value is {@link GL_TRUE}.
 *
 * - {@link GL_DOUBLEBUFFER}
 * **params** returns a single boolean value indicating whether double buffering is supported.
 *
 * - {@link GL_DRAW_BUFFER}
 * **params** returns one value, a symbolic constant indicating which buffers are being drawn to. See {@link glDrawBuffer}. The initial value is {@link GL_BACK} if there are back buffers, otherwise it is {@link GL_FRONT}.
 *
 * - {@link GL_DRAW_BUFFER}**i**
 * **params** returns one value, a symbolic constant indicating which buffers are being drawn to by the corresponding output color. See {@link glDrawBuffers}. The initial value of {@link GL_DRAW_BUFFER0} is {@link GL_BACK} if there are back buffers, otherwise it is {@link GL_FRONT}. The initial values of draw buffers for all other output colors is {@link GL_NONE}.
 *
 * - {@link GL_DRAW_FRAMEBUFFER_BINDING}
 * **params** returns one value, the name of the framebuffer object currently bound to the {@link GL_DRAW_FRAMEBUFFER} target. If the default framebuffer is bound, this value will be zero. The initial value is zero. See {@link glBindFramebuffer}.
 *
 * - {@link GL_READ_FRAMEBUFFER_BINDING}
 * **params** returns one value, the name of the framebuffer object currently bound to the {@link GL_READ_FRAMEBUFFER} target. If the default framebuffer is bound, this value will be zero. The initial value is zero. See {@link glBindFramebuffer}.
 *
 * - {@link GL_ELEMENT_ARRAY_BUFFER_BINDING}
 * **params** returns a single value, the name of the buffer object currently bound to the target {@link GL_ELEMENT_ARRAY_BUFFER}. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See {@link glBindBuffer}.
 *
 * - {@link GL_RENDERBUFFER_BINDING}
 * **params** returns a single value, the name of the renderbuffer object currently bound to the target {@link GL_RENDERBUFFER}. If no renderbuffer object is bound to this target, 0 is returned. The initial value is 0. See {@link glBindRenderbuffer}.
 *
 * - {@link GL_FRAGMENT_SHADER_DERIVATIVE_HINT}
 * **params** returns one value, a symbolic constant indicating the mode of the derivative accuracy hint for fragment shaders. The initial value is {@link GL_DONT_CARE}. See {@link glHint}.
 *
 * - {@link GL_LINE_SMOOTH}
 * **params** returns a single boolean value indicating whether antialiasing of lines is enabled. The initial value is {@link GL_FALSE}. See {@link glLineWidth}.
 *
 * - {@link GL_LINE_SMOOTH_HINT}
 * **params** returns one value, a symbolic constant indicating the mode of the line antialiasing hint. The initial value is {@link GL_DONT_CARE}. See {@link glHint}.
 *
 * - {@link GL_LINE_WIDTH}
 * **params** returns one value, the line width as specified with {@link glLineWidth}. The initial value is 1.
 *
 * - {@link GL_LOGIC_OP_MODE}
 * **params** returns one value, a symbolic constant indicating the selected logic operation mode. The initial value is {@link GL_COPY}. See {@link glLogicOp}.
 *
 * - {@link GL_MAX_3D_TEXTURE_SIZE}
 * **params** returns one value, a rough estimate of the largest 3D texture that the GL can handle. The value must be at least 64. Use {@link GL_PROXY_TEXTURE_3D} to determine if a texture is too large. See {@link glTexImage3D}.
 *
 * - {@link GL_MAX_CLIP_DISTANCES}
 * **params** returns one value, the maximum number of application-defined clipping distances. The value must be at least 8.
 *
 * - {@link GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS}
 * **params** returns one value, the number of words for fragment shader uniform variables in all uniform blocks (including default). The value must be at least 1. See {@link glUniform}.
 *
 * - {@link GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS}
 * **params** returns one value, the maximum supported texture image units that can be used to access texture maps from the vertex shader and the fragment processor combined. If both the vertex shader and the fragment processing stage access the same texture image unit, then that counts as using two texture image units against this limit. The value must be at least 48. See {@link glActiveTexture}.
 *
 * - {@link GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS}
 * **params** returns one value, the number of words for vertex shader uniform variables in all uniform blocks (including default). The value must be at least 1. See {@link glUniform}.
 *
 * - {@link GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS}
 * **params** returns one value, the number of words for geometry shader uniform variables in all uniform blocks (including default). The value must be at least 1. See {@link glUniform}.
 *
 * - {@link GL_MAX_VARYING_COMPONENTS}
 * **params** returns one value, the number components for varying variables, which must be at least 60.
 *
 * - {@link GL_MAX_COMBINED_UNIFORM_BLOCKS}
 * **params** returns one value, the maximum number of uniform blocks per program. The value must be at least 36. See {@link glUniformBlockBinding}.
 *
 * - {@link GL_MAX_CUBE_MAP_TEXTURE_SIZE}
 * **params** returns one value. The value gives a rough estimate of the largest cube-map texture that the GL can handle. The value must be at least 1024. Use {@link GL_PROXY_TEXTURE_CUBE_MAP} to determine if a texture is too large. See {@link glTexImage2D}.
 *
 * - {@link GL_MAX_DRAW_BUFFERS}
 * **params** returns one value, the maximum number of simultaneous outputs that may be written in a fragment shader. The value must be at least 8. See {@link glDrawBuffers}.
 *
 * - {@link GL_MAX_DUAL_SOURCE_DRAW_BUFFERS}
 * **params** returns one value, the maximum number of active draw buffers when using dual-source blending. The value must be at least 1. See {@link glBlendFunc} and {@link glBlendFuncSeparate}.
 *
 * - {@link GL_MAX_ELEMENTS_INDICES}
 * **params** returns one value, the recommended maximum number of vertex array indices. See {@link glDrawRangeElements}.
 *
 * - {@link GL_MAX_ELEMENTS_VERTICES}
 * **params** returns one value, the recommended maximum number of vertex array vertices. See {@link glDrawRangeElements}.
 *
 * - {@link GL_MAX_FRAGMENT_UNIFORM_COMPONENTS}
 * **params** returns one value, the maximum number of individual floating-point, integer, or boolean values that can be held in uniform variable storage for a fragment shader. The value must be at least 1024. See {@link glUniform}.
 *
 * - {@link GL_MAX_FRAGMENT_UNIFORM_BLOCKS}
 * **params** returns one value, the maximum number of uniform blocks per fragment shader. The value must be at least 12. See {@link glUniformBlockBinding}.
 *
 * - {@link GL_MAX_FRAGMENT_INPUT_COMPONENTS}
 * **params** returns one value, the maximum number of components of the inputs read by the fragment shader, which must be at least 128.
 *
 * - {@link GL_MIN_PROGRAM_TEXEL_OFFSET}
 * **params** returns one value, the minimum texel offset allowed in a texture lookup, which must be at most -8.
 *
 * - {@link GL_MAX_PROGRAM_TEXEL_OFFSET}
 * **params** returns one value, the maximum texel offset allowed in a texture lookup, which must be at least 7.
 *
 * - {@link GL_MAX_RECTANGLE_TEXTURE_SIZE}
 * **params** returns one value. The value gives a rough estimate of the largest rectangular texture that the GL can handle. The value must be at least 1024. Use {@link GL_PROXY_TEXTURE_RECTANGLE} to determine if a texture is too large. See {@link glTexImage2D}.
 *
 * - {@link GL_MAX_TEXTURE_IMAGE_UNITS}
 * **params** returns one value, the maximum supported texture image units that can be used to access texture maps from the fragment shader. The value must be at least 16. See {@link glActiveTexture}.
 *
 * - {@link GL_MAX_TEXTURE_LOD_BIAS}
 * **params** returns one value, the maximum, absolute value of the texture level-of-detail bias. The value must be at least 2.0.
 *
 * - {@link GL_MAX_TEXTURE_SIZE}
 * **params** returns one value. The value gives a rough estimate of the largest texture that the GL can handle. The value must be at least 1024. Use a proxy texture target such as {@link GL_PROXY_TEXTURE_1D} or {@link GL_PROXY_TEXTURE_2D} to determine if a texture is too large. See {@link glTexImage1D} and {@link glTexImage2D}.
 *
 * - {@link GL_MAX_RENDERBUFFER_SIZE}
 * **params** returns one value. The value indicates the maximum supported size for renderbuffers. See {@link glFramebufferRenderbuffer}.
 *
 * - {@link GL_MAX_ARRAY_TEXTURE_LAYERS}
 * **params** returns one value. The value indicates the maximum number of layers allowed in an array texture, and must be at least 256. See {@link glTexImage2D}.
 *
 * - {@link GL_MAX_TEXTURE_BUFFER_SIZE}
 * **params** returns one value. The value gives the maximum number of texels allowed in the texel array of a texture buffer object. Value must be at least 65536.
 *
 * - {@link GL_MAX_UNIFORM_BLOCK_SIZE}
 * **params** returns one value, the maximum size in basic machine units of a uniform block. The value must be at least 16384. See {@link glUniformBlockBinding}.
 *
 * - {@link GL_MAX_VARYING_FLOATS}
 * **params** returns one value, the maximum number of interpolators available for processing varying variables used by vertex and fragment shaders. This value represents the number of individual floating-point values that can be interpolated; varying variables declared as vectors, matrices, and arrays will all consume multiple interpolators. The value must be at least 32.
 *
 * - {@link GL_MAX_VERTEX_ATTRIBS}
 * **params** returns one value, the maximum number of 4-component generic vertex attributes accessible to a vertex shader. The value must be at least 16. See {@link glVertexAttrib}.
 *
 * - {@link GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS}
 * **params** returns one value, the maximum supported texture image units that can be used to access texture maps from the vertex shader. The value may be at least 16. See {@link glActiveTexture}.
 *
 * - {@link GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS}
 * **params** returns one value, the maximum supported texture image units that can be used to access texture maps from the geometry shader. The value must be at least 16. See {@link glActiveTexture}.
 *
 * - {@link GL_MAX_VERTEX_UNIFORM_COMPONENTS}
 * **params** returns one value, the maximum number of individual floating-point, integer, or boolean values that can be held in uniform variable storage for a vertex shader. The value must be at least 1024. See {@link glUniform}.
 *
 * - {@link GL_MAX_VERTEX_OUTPUT_COMPONENTS}
 * **params** returns one value, the maximum number of components of output written by a vertex shader, which must be at least 64.
 *
 * - {@link GL_MAX_GEOMETRY_UNIFORM_COMPONENTS}
 * **params** returns one value, the maximum number of individual floating-point, integer, or boolean values that can be held in uniform variable storage for a geometry shader. The value must be at least 1024. See {@link glUniform}.
 *
 * - {@link GL_MAX_SAMPLE_MASK_WORDS}
 * **params** returns one value, the maximum number of sample mask words.
 *
 * - {@link GL_MAX_COLOR_TEXTURE_SAMPLES}
 * **params** returns one value, the maximum number of samples in a color multisample texture.
 *
 * - {@link GL_MAX_DEPTH_TEXTURE_SAMPLES}
 * **params** returns one value, the maximum number of samples in a multisample depth or depth-stencil texture.
 *
 * - {@link GL_MAX_DEPTH_TEXTURE_SAMPLES}
 * **params** returns one value, the maximum number of samples in a multisample depth or depth-stencil texture.
 *
 * - {@link GL_MAX_INTEGER_SAMPLES}
 * **params** returns one value, the maximum number of samples supported in integer format multisample buffers.
 *
 * - {@link GL_MAX_SERVER_WAIT_TIMEOUT}
 * **params** returns one value, the maximum {@link glWaitSync} timeout interval.
 *
 * - {@link GL_MAX_UNIFORM_BUFFER_BINDINGS}
 * **params** returns one value, the maximum number of uniform buffer binding points on the context, which must be at least 36.
 *
 * - {@link GL_MAX_UNIFORM_BLOCK_SIZE}
 * **params** returns one value, the maximum size in basic machine units of a uniform block, which must be at least 16384.
 *
 * - {@link GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT}
 * **params** returns one value, the minimum required alignment for uniform buffer sizes and offsets.
 *
 * - {@link GL_MAX_VERTEX_UNIFORM_BLOCKS}
 * **params** returns one value, the maximum number of uniform blocks per vertex shader. The value must be at least 12. See {@link glUniformBlockBinding}.
 *
 * - {@link GL_MAX_GEOMETRY_UNIFORM_BLOCKS}
 * **params** returns one value, the maximum number of uniform blocks per geometry shader. The value must be at least 12. See {@link glUniformBlockBinding}.
 *
 * - {@link GL_MAX_GEOMETRY_INPUT_COMPONENTS}
 * **params** returns one value, the maximum number of components of inputs read by a geometry shader, which must be at least 64.
 *
 * - {@link GL_MAX_GEOMETRY_OUTPUT_COMPONENTS}
 * **params** returns one value, the maximum number of components of outputs written by a geometry shader, which must be at least 128.
 *
 * - {@link GL_MAX_VIEWPORT_DIMS}
 * **params** returns two values: the maximum supported width and height of the viewport. These must be at least as large as the visible dimensions of the display being rendered to. See {@link glViewport}.
 *
 * - {@link GL_NUM_COMPRESSED_TEXTURE_FORMATS}
 * **params** returns a single integer value indicating the number of available compressed texture formats. The minimum value is 4. See {@link glCompressedTexImage2D}.
 *
 * - {@link GL_PACK_ALIGNMENT}
 * **params** returns one value, the byte alignment used for writing pixel data to memory. The initial value is 4. See {@link glPixelStore}.
 *
 * - {@link GL_PACK_IMAGE_HEIGHT}
 * **params** returns one value, the image height used for writing pixel data to memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_PACK_LSB_FIRST}
 * **params** returns a single boolean value indicating whether single-bit pixels being written to memory are written first to the least significant bit of each unsigned byte. The initial value is {@link GL_FALSE}. See {@link glPixelStore}.
 *
 * - {@link GL_PACK_ROW_LENGTH}
 * **params** returns one value, the row length used for writing pixel data to memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_PACK_SKIP_IMAGES}
 * **params** returns one value, the number of pixel images skipped before the first pixel is written into memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_PACK_SKIP_PIXELS}
 * **params** returns one value, the number of pixel locations skipped before the first pixel is written into memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_PACK_SKIP_ROWS}
 * **params** returns one value, the number of rows of pixel locations skipped before the first pixel is written into memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_PACK_SWAP_BYTES}
 * **params** returns a single boolean value indicating whether the bytes of two-byte and four-byte pixel indices and components are swapped before being written to memory. The initial value is {@link GL_FALSE}. See {@link glPixelStore}.
 *
 * - {@link GL_PIXEL_PACK_BUFFER_BINDING}
 * **params** returns a single value, the name of the buffer object currently bound to the target {@link GL_PIXEL_PACK_BUFFER}. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See {@link glBindBuffer}.
 *
 * - {@link GL_PIXEL_UNPACK_BUFFER_BINDING}
 * **params** returns a single value, the name of the buffer object currently bound to the target {@link GL_PIXEL_UNPACK_BUFFER}. If no buffer object is bound to this target, 0 is returned. The initial value is 0. See {@link glBindBuffer}.
 *
 * - {@link GL_POINT_FADE_THRESHOLD_SIZE}
 * **params** returns one value, the point size threshold for determining the point size. See {@link glPointParameter}.
 *
 * - {@link GL_PRIMITIVE_RESTART_INDEX}
 * **params** returns one value, the current primitive restart index. The initial value is 0. See {@link glPrimitiveRestartIndex}.
 *
 * - {@link GL_PROGRAM_POINT_SIZE}
 * **params** returns a single boolean value indicating whether vertex program point size mode is enabled. If enabled, then the point size is taken from the shader built-in gl_PointSize. If disabled, then the point size is taken from the point state as specified by {@link glPointSize}. The initial value is {@link GL_FALSE}.
 *
 * - {@link GL_PROVOKING_VERTEX}
 * **params** returns one value, the currently selected provoking vertex convention. The initial value is {@link GL_LAST_VERTEX_CONVENTION}. See {@link glProvokingVertex}.
 *
 * - {@link GL_POINT_SIZE}
 * **params** returns one value, the point size as specified by {@link glPointSize}. The initial value is 1.
 *
 * - {@link GL_POINT_SIZE_GRANULARITY}
 * **params** returns one value, the size difference between adjacent supported sizes for antialiased points. See {@link glPointSize}.
 *
 * - {@link GL_POINT_SIZE_RANGE}
 * **params** returns two values: the smallest and largest supported sizes for antialiased points. The smallest size must be at most 1, and the largest size must be at least 1. See {@link glPointSize}.
 *
 * - {@link GL_POLYGON_OFFSET_FACTOR}
 * **params** returns one value, the scaling factor used to determine the variable offset that is added to the depth value of each fragment generated when a polygon is rasterized. The initial value is 0. See {@link glPolygonOffset}.
 *
 * - {@link GL_POLYGON_OFFSET_UNITS}
 * **params** returns one value. This value is multiplied by an implementation-specific value and then added to the depth value of each fragment generated when a polygon is rasterized. The initial value is 0. See {@link glPolygonOffset}.
 *
 * - {@link GL_POLYGON_OFFSET_FILL}
 * **params** returns a single boolean value indicating whether polygon offset is enabled for polygons in fill mode. The initial value is {@link GL_FALSE}. See {@link glPolygonOffset}.
 *
 * - {@link GL_POLYGON_OFFSET_LINE}
 * **params** returns a single boolean value indicating whether polygon offset is enabled for polygons in line mode. The initial value is {@link GL_FALSE}. See {@link glPolygonOffset}.
 *
 * - {@link GL_POLYGON_OFFSET_POINT}
 * **params** returns a single boolean value indicating whether polygon offset is enabled for polygons in point mode. The initial value is {@link GL_FALSE}. See {@link glPolygonOffset}.
 *
 * - {@link GL_POLYGON_SMOOTH}
 * **params** returns a single boolean value indicating whether antialiasing of polygons is enabled. The initial value is {@link GL_FALSE}. See {@link glPolygonMode}.
 *
 * - {@link GL_POLYGON_SMOOTH_HINT}
 * **params** returns one value, a symbolic constant indicating the mode of the polygon antialiasing hint. The initial value is {@link GL_DONT_CARE}. See {@link glHint}.
 *
 * - {@link GL_READ_BUFFER}
 * **params** returns one value, a symbolic constant indicating which color buffer is selected for reading. The initial value is {@link GL_BACK} if there is a back buffer, otherwise it is {@link GL_FRONT}. See {@link glReadPixels}.
 *
 * - {@link GL_SAMPLE_BUFFERS}
 * **params** returns a single integer value indicating the number of sample buffers associated with the framebuffer. See {@link glSampleCoverage}.
 *
 * - {@link GL_SAMPLE_COVERAGE_VALUE}
 * **params** returns a single positive floating-point value indicating the current sample coverage value. See {@link glSampleCoverage}.
 *
 * - {@link GL_SAMPLE_COVERAGE_INVERT}
 * **params** returns a single boolean value indicating if the temporary coverage value should be inverted. See {@link glSampleCoverage}.
 *
 * - {@link GL_SAMPLER_BINDING}
 * **params** returns a single value, the name of the sampler object currently bound to the active texture unit. The initial value is 0. See {@link glBindSampler}.
 *
 * - {@link GL_SAMPLES}
 * **params** returns a single integer value indicating the coverage mask size. See {@link glSampleCoverage}.
 *
 * - {@link GL_SCISSOR_BOX}
 * **params** returns four values: the 𝐱 and 𝐲 window coordinates of the scissor box, followed by its width and height. Initially the 𝐱 and 𝐲 window coordinates are both 0 and the *width* and *height* are set to the size of the window. See {@link glScissor}.
 *
 * - {@link GL_SCISSOR_TEST}
 * **params** returns a single boolean value indicating whether scissoring is enabled. The initial value is {@link GL_FALSE}. See {@link glScissor}.
 *
 * - {@link GL_STENCIL_BACK_FAIL}
 * **params** returns one value, a symbolic constant indicating what action is taken for back-facing polygons when the stencil test fails. The initial value is {@link GL_KEEP}. See {@link glStencilOpSeparate}.
 *
 * - {@link GL_STENCIL_BACK_FUNC}
 * **params** returns one value, a symbolic constant indicating what function is used for back-facing polygons to compare the stencil reference value with the stencil buffer value. The initial value is {@link GL_ALWAYS}. See {@link glStencilFuncSeparate}.
 *
 * - {@link GL_STENCIL_BACK_PASS_DEPTH_FAIL}
 * **params** returns one value, a symbolic constant indicating what action is taken for back-facing polygons when the stencil test passes, but the depth test fails. The initial value is {@link GL_KEEP}. See {@link glStencilOpSeparate}.
 *
 * - {@link GL_STENCIL_BACK_PASS_DEPTH_PASS}
 * **params** returns one value, a symbolic constant indicating what action is taken for back-facing polygons when the stencil test passes and the depth test passes. The initial value is {@link GL_KEEP}. See {@link glStencilOpSeparate}.
 *
 * - {@link GL_STENCIL_BACK_REF}
 * **params** returns one value, the reference value that is compared with the contents of the stencil buffer for back-facing polygons. The initial value is 0. See {@link glStencilFuncSeparate}.
 *
 * - {@link GL_STENCIL_BACK_VALUE_MASK}
 * **params** returns one value, the mask that is used for back-facing polygons to mask both the stencil reference value and the stencil buffer value before they are compared. The initial value is all 1's. See {@link glStencilFuncSeparate}.
 *
 * - {@link GL_STENCIL_BACK_WRITEMASK}
 * **params** returns one value, the mask that controls writing of the stencil bitplanes for back-facing polygons. The initial value is all 1's. See {@link glStencilMaskSeparate}.
 *
 * - {@link GL_STENCIL_CLEAR_VALUE}
 * **params** returns one value, the index to which the stencil bitplanes are cleared. The initial value is 0. See {@link glClearStencil}.
 *
 * - {@link GL_STENCIL_FAIL}
 * **params** returns one value, a symbolic constant indicating what action is taken when the stencil test fails. The initial value is {@link GL_KEEP}. See {@link glStencilOp}. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See {@link glStencilOpSeparate}.
 *
 * - {@link GL_STENCIL_FUNC}
 * **params** returns one value, a symbolic constant indicating what function is used to compare the stencil reference value with the stencil buffer value. The initial value is {@link GL_ALWAYS}. See {@link glStencilFunc}. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See {@link glStencilFuncSeparate}.
 *
 * - {@link GL_STENCIL_PASS_DEPTH_FAIL}
 * **params** returns one value, a symbolic constant indicating what action is taken when the stencil test passes, but the depth test fails. The initial value is {@link GL_KEEP}. See {@link glStencilOp}. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See {@link glStencilOpSeparate}.
 *
 * - {@link GL_STENCIL_PASS_DEPTH_PASS}
 * **params** returns one value, a symbolic constant indicating what action is taken when the stencil test passes and the depth test passes. The initial value is {@link GL_KEEP}. See {@link glStencilOp}. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See {@link glStencilOpSeparate}.
 *
 * - {@link GL_STENCIL_REF}
 * **params** returns one value, the reference value that is compared with the contents of the stencil buffer. The initial value is 0. See {@link glStencilFunc}. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See {@link glStencilFuncSeparate}.
 *
 * - {@link GL_STENCIL_TEST}
 * **params** returns a single boolean value indicating whether stencil testing of fragments is enabled. The initial value is {@link GL_FALSE}. See {@link glStencilFunc} and {@link glStencilOp}.
 *
 * - {@link GL_STENCIL_VALUE_MASK}
 * **params** returns one value, the mask that is used to mask both the stencil reference value and the stencil buffer value before they are compared. The initial value is all 1's. See {@link glStencilFunc}. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See {@link glStencilFuncSeparate}.
 *
 * - {@link GL_STENCIL_WRITEMASK}
 * **params** returns one value, the mask that controls writing of the stencil bitplanes. The initial value is all 1's. See {@link glStencilMask}. This stencil state only affects non-polygons and front-facing polygons. Back-facing polygons use separate stencil state. See {@link glStencilMaskSeparate}.
 *
 * - {@link GL_STEREO}
 * **params** returns a single boolean value indicating whether stereo buffers (left and right) are supported.
 *
 * - {@link GL_SUBPIXEL_BITS}
 * **params** returns one value, an estimate of the number of bits of subpixel resolution that are used to position rasterized geometry in window coordinates. The value must be at least 4.
 *
 * - {@link GL_TEXTURE_BINDING_1D}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_1D}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_1D_ARRAY}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_1D_ARRAY}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_2D}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_2D}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_2D_ARRAY}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_2D_ARRAY}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_2D_MULTISAMPLE}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_2D_MULTISAMPLE}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_2D_MULTISAMPLE_ARRAY}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_3D}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_3D}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_BUFFER}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_BUFFER}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_CUBE_MAP}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_CUBE_MAP}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_BINDING_RECTANGLE}
 * **params** returns a single value, the name of the texture currently bound to the target {@link GL_TEXTURE_RECTANGLE}. The initial value is 0. See {@link glBindTexture}.
 *
 * - {@link GL_TEXTURE_COMPRESSION_HINT}
 * **params** returns a single value indicating the mode of the texture compression hint. The initial value is {@link GL_DONT_CARE}.
 *
 * - {@link GL_TEXTURE_BINDING_BUFFER}
 * **params** returns a single value, the name of the texture buffer object currently bound. The initial value is 0. See {@link glBindBuffer}.
 *
 * - {@link GL_TIMESTAMP}
 * **params** returns a single value, the 64-bit value of the current GL time. See {@link glQueryCounter}.
 *
 * - {@link GL_TRANSFORM_FEEDBACK_BUFFER_BINDING}
 * When used with non-indexed variants of `glGet` (such as `glGetIntegerv`), **params** returns a single value, the name of the buffer object currently bound to the target {@link GL_TRANSFORM_FEEDBACK_BUFFER}. If no buffer object is bound to this target, 0 is returned. When used with indexed variants of `glGet` (such as `glGetIntegeri_v`), **params** returns a single value, the name of the buffer object bound to the indexed transform feedback attribute stream. The initial value is 0 for all targets. See {@link glBindBuffer}, {@link glBindBufferBase}, and {@link glBindBufferRange}.
 *
 * - {@link GL_TRANSFORM_FEEDBACK_BUFFER_START}
 * When used with indexed variants of `glGet` (such as `glGetInteger64i_v`), **params** returns a single value, the start offset of the binding range for each transform feedback attribute stream. The initial value is 0 for all streams. See {@link glBindBufferRange}.
 *
 * - {@link GL_TRANSFORM_FEEDBACK_BUFFER_SIZE}
 * When used with indexed variants of `glGet` (such as `glGetInteger64i_v`), **params** returns a single value, the size of the binding range for each transform feedback attribute stream. The initial value is 0 for all streams. See {@link glBindBufferRange}.
 *
 * - {@link GL_UNIFORM_BUFFER_BINDING}
 * When used with non-indexed variants of `glGet` (such as `glGetIntegerv`), **params** returns a single value, the name of the buffer object currently bound to the target {@link GL_UNIFORM_BUFFER}. If no buffer object is bound to this target, 0 is returned. When used with indexed variants of `glGet` (such as `glGetIntegeri_v`), **params** returns a single value, the name of the buffer object bound to the indexed uniform buffer binding point. The initial value is 0 for all targets. See {@link glBindBuffer}, {@link glBindBufferBase}, and {@link glBindBufferRange}.
 *
 * - {@link GL_UNIFORM_BUFFER_START}
 * When used with indexed variants of `glGet` (such as `glGetInteger64i_v`), **params** returns a single value, the start offset of the binding range for each indexed uniform buffer binding. The initial value is 0 for all bindings. See {@link glBindBufferRange}.
 *
 * - {@link GL_UNIFORM_BUFFER_SIZE}
 * When used with indexed variants of `glGet` (such as `glGetInteger64i_v`), **params** returns a single value, the size of the binding range for each indexed uniform buffer binding. The initial value is 0 for all bindings. See {@link glBindBufferRange}.
 *
 * - {@link GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT}
 * **params** returns a single value, the minimum required alignment for uniform buffer sizes and offset. The initial value is 1. See {@link glUniformBlockBinding}.
 *
 * - {@link GL_UNPACK_ALIGNMENT}
 * **params** returns one value, the byte alignment used for reading pixel data from memory. The initial value is 4. See {@link glPixelStore}.
 *
 * - {@link GL_UNPACK_IMAGE_HEIGHT}
 * **params** returns one value, the image height used for reading pixel data from memory. The initial is 0. See {@link glPixelStore}.
 *
 * - {@link GL_UNPACK_LSB_FIRST}
 * **params** returns a single boolean value indicating whether single-bit pixels being read from memory are read first from the least significant bit of each unsigned byte. The initial value is {@link GL_FALSE}. See {@link glPixelStore}.
 *
 * - {@link GL_UNPACK_ROW_LENGTH}
 * **params** returns one value, the row length used for reading pixel data from memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_UNPACK_SKIP_IMAGES}
 * **params** returns one value, the number of pixel images skipped before the first pixel is read from memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_UNPACK_SKIP_PIXELS}
 * **params** returns one value, the number of pixel locations skipped before the first pixel is read from memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_UNPACK_SKIP_ROWS}
 * **params** returns one value, the number of rows of pixel locations skipped before the first pixel is read from memory. The initial value is 0. See {@link glPixelStore}.
 *
 * - {@link GL_UNPACK_SWAP_BYTES}
 * **params** returns a single boolean value indicating whether the bytes of two-byte and four-byte pixel indices and components are swapped after being read from memory. The initial value is {@link GL_FALSE}. See {@link glPixelStore}.
 *
 * - {@link GL_NUM_EXTENSIONS}
 * **params** returns one value, the number of extensions supported by the GL implementation for the current context. See {@link glGetString}.
 *
 * - {@link GL_MAJOR_VERSION}
 * **params** returns one value, the major version number of the OpenGL API supported by the current context.
 *
 * - {@link GL_MINOR_VERSION}
 * **params** returns one value, the minor version number of the OpenGL API supported by the current context.
 *
 * - {@link GL_CONTEXT_FLAGS}
 * **params** returns one value, the flags with which the context was created (such as debugging functionality).
 *
 * - {@link GL_VIEWPORT}
 * **params** returns four values: the 𝐱 and 𝐲 window coordinates of the viewport, followed by its width and height. Initially the 𝐱 and 𝐲 window coordinates are both set to 0, and the *width* and *height* are set to the width and height of the window into which the GL will do its rendering. See {@link glViewport}.
 *
 * Many of the boolean parameters can also be queried more easily using {@link glIsEnabled}.
 *
 * @summary return the value or values of a selected parameter
 * @param pname Specifies the parameter value to be returned. The symbolic constants in the list below are accepted.
 * @param params Returns the value or values of the specified parameter.
 * @see [glGet](https://docs.gl/gl3/glGet)
 */
export function glGetIntegerv(pname: GLenum, params: GLint): void;

/**
 * `glGetClipPlane` returns in **equation** the four coefficients of the plane equation for **plane**.
 *
 * @summary return the coefficients of the specified clipping plane
 * @param plane Specifies a clipping plane. The number of clipping planes depends on the implementation, but at least six clipping planes are supported. They are identified by symbolic names of the form {@link GL_CLIP_PLANE} 𝐢 where i ranges from 0 to the value of {@link GL_MAX_CLIP_PLANES} - 1.
 * @param equation Returns four double-precision values that are the coefficients of the plane equation of **plane** in eye coordinates. The initial value is (0, 0, 0, 0).
 * @see [glGetClipPlane](https://docs.gl/gl3/glGetClipPlane)
 */
export function glGetClipPlane(plane: GLenum, equation: GLdouble): void;

/**
 * `glGetError` returns the value of the error flag. Each detectable error is assigned a numeric code and symbolic name. When an error occurs, the error flag is set to the appropriate error code value. No other errors are recorded until `glGetError` is called, the error code is returned, and the flag is reset to {@link GL_NO_ERROR}. If a call to `glGetError` returns {@link GL_NO_ERROR}, there has been no detectable error since the last call to `glGetError`, or since the GL was initialized.
 *
 * To allow for distributed implementations, there may be several error flags. If any single error flag has recorded an error, the value of that flag is returned and that flag is reset to {@link GL_NO_ERROR} when `glGetError` is called. If more than one flag has recorded an error, `glGetError` returns and clears an arbitrary error flag value. Thus, `glGetError` should always be called in a loop, until it returns {@link GL_NO_ERROR}, if all error flags are to be reset.
 *
 * Initially, all error flags are set to {@link GL_NO_ERROR}.
 *
 * The following errors are currently defined:
 *
 * - {@link GL_NO_ERROR}
 * No error has been recorded. The value of this symbolic constant is guaranteed to be 0.
 *
 * - {@link GL_INVALID_ENUM}
 * An unacceptable value is specified for an enumerated argument. The offending command is ignored and has no other side effect than to set the error flag.
 *
 * - {@link GL_INVALID_VALUE}
 * A numeric argument is out of range. The offending command is ignored and has no other side effect than to set the error flag.
 *
 * - {@link GL_INVALID_OPERATION}
 * The specified operation is not allowed in the current state. The offending command is ignored and has no other side effect than to set the error flag.
 *
 * - {@link GL_INVALID_FRAMEBUFFER_OPERATION}
 * The framebuffer object is not complete. The offending command is ignored and has no other side effect than to set the error flag.
 *
 * - {@link GL_OUT_OF_MEMORY}There is not enough memory left to execute the command. The state of the GL is undefined, except for the state of the error flags, after this error is recorded.
 *
 * When an error flag is set, results of a GL operation are undefined only if {@link GL_OUT_OF_MEMORY} has occurred. In all other cases, the command generating the error is ignored and has no effect on the GL state or frame buffer contents. If the generating command returns a value, it returns 0. If `glGetError` itself generates an error, it returns 0.
 *
 * @summary return error information
 * @see [glGetError](https://docs.gl/gl3/glGetError)
 */
export function glGetError(): void;

/**
 * `glGetLight` returns in **params** the value or values of a light source parameter. **light** names the light and is a symbolic name of the form {@link GL_LIGHT} 𝐢 where i ranges from 0 to the value of {@link GL_MAX_LIGHTS} - 1. {@link GL_MAX_LIGHTS} is an implementation dependent constant that is greater than or equal to eight. **pname** specifies one of ten light source parameters, again by symbolic name.
 *
 * The following parameters are defined:
 *
 * - {@link GL_AMBIENT}
 * **params** returns four integer or floating-point values representing the ambient intensity of the light source. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and −1.0 maps to the most negative representable integer value. If the internal value is outside the range [−1,1], the corresponding integer return value is undefined. The initial value is (0, 0, 0, 1).
 *
 * - {@link GL_DIFFUSE}
 * **params** returns four integer or floating-point values representing the diffuse intensity of the light source. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and −1.0 maps to the most negative representable integer value. If the internal value is outside the range [−1,1], the corresponding integer return value is undefined. The initial value for {@link GL_LIGHT0} is (1, 1, 1, 1); for other lights, the initial value is (0, 0, 0, 0).
 *
 * - {@link GL_SPECULAR}
 * **params** returns four integer or floating-point values representing the specular intensity of the light source. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and −1.0 maps to the most negative representable integer value. If the internal value is outside the range [−1,1], the corresponding integer return value is undefined. The initial value for {@link GL_LIGHT0} is (1, 1, 1, 1); for other lights, the initial value is (0, 0, 0, 0).
 *
 * - {@link GL_POSITION}
 * **params** returns four integer or floating-point values representing the position of the light source. Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer value. The returned values are those maintained in eye coordinates. They will not be equal to the values specified using {@link glLight}, unless the modelview matrix was identity at the time {@link glLight} was called. The initial value is (0, 0, 1, 0).
 *
 * - {@link GL_SPOT_DIRECTION}
 * **params** returns three integer or floating-point values representing the direction of the light source. Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer value. The returned values are those maintained in eye coordinates. They will not be equal to the values specified using {@link glLight}, unless the modelview matrix was identity at the time {@link glLight} was called. Although spot direction is normalized before being used in the lighting equation, the returned values are the transformed versions of the specified values prior to normalization. The initial value is (0,0,−1)
 *
 * - {@link GL_SPOT_EXPONENT}
 * **params** returns a single integer or floating-point value representing the spot exponent of the light. An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer. The initial value is 0.
 *
 * - {@link GL_SPOT_CUTOFF}
 * **params** returns a single integer or floating-point value representing the spot cutoff angle of the light. An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer. The initial value is 180.
 *
 * - {@link GL_CONSTANT_ATTENUATION}
 * **params** returns a single integer or floating-point value representing the constant (not distance-related) attenuation of the light. An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer. The initial value is 1.
 *
 * - {@link GL_LINEAR_ATTENUATION}
 * **params** returns a single integer or floating-point value representing the linear attenuation of the light. An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer. The initial value is 0.
 *
 * - {@link GL_QUADRATIC_ATTENUATION}
 * **params** returns a single integer or floating-point value representing the quadratic attenuation of the light. An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer. The initial value is 0.
 *
 * @summary return light source parameter values
 * @param light Specifies a light source. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form {@link GL_LIGHT} 𝐢 where i ranges from 0 to the value of {@link GL_MAX_LIGHTS} - 1.
 * @param pname Specifies a light source parameter for **light**. Accepted symbolic names are {@link GL_AMBIENT}, {@link GL_DIFFUSE}, {@link GL_SPECULAR}, {@link GL_POSITION}, {@link GL_SPOT_DIRECTION}, {@link GL_SPOT_EXPONENT}, {@link GL_SPOT_CUTOFF}, {@link GL_CONSTANT_ATTENUATION}, {@link GL_LINEAR_ATTENUATION}, and {@link GL_QUADRATIC_ATTENUATION}.
 * @param params Returns the requested data.
 * @see [glGetLight](https://docs.gl/gl3/glGetLight)
 */
export function glGetLightfv(
	light: GLenum,
	pname: GLenum,
	params: GLfloat
): void;

/**
 * `glGetLight` returns in **params** the value or values of a light source parameter. **light** names the light and is a symbolic name of the form {@link GL_LIGHT} 𝐢 where i ranges from 0 to the value of {@link GL_MAX_LIGHTS} - 1. {@link GL_MAX_LIGHTS} is an implementation dependent constant that is greater than or equal to eight. **pname** specifies one of ten light source parameters, again by symbolic name.
 *
 * The following parameters are defined:
 *
 * - {@link GL_AMBIENT}
 * **params** returns four integer or floating-point values representing the ambient intensity of the light source. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and −1.0 maps to the most negative representable integer value. If the internal value is outside the range [−1,1], the corresponding integer return value is undefined. The initial value is (0, 0, 0, 1).
 *
 * - {@link GL_DIFFUSE}
 * **params** returns four integer or floating-point values representing the diffuse intensity of the light source. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and −1.0 maps to the most negative representable integer value. If the internal value is outside the range [−1,1], the corresponding integer return value is undefined. The initial value for {@link GL_LIGHT0} is (1, 1, 1, 1); for other lights, the initial value is (0, 0, 0, 0).
 *
 * - {@link GL_SPECULAR}
 * **params** returns four integer or floating-point values representing the specular intensity of the light source. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and −1.0 maps to the most negative representable integer value. If the internal value is outside the range [−1,1], the corresponding integer return value is undefined. The initial value for {@link GL_LIGHT0} is (1, 1, 1, 1); for other lights, the initial value is (0, 0, 0, 0).
 *
 * - {@link GL_POSITION}
 * **params** returns four integer or floating-point values representing the position of the light source. Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer value. The returned values are those maintained in eye coordinates. They will not be equal to the values specified using {@link glLight}, unless the modelview matrix was identity at the time {@link glLight} was called. The initial value is (0, 0, 1, 0).
 *
 * - {@link GL_SPOT_DIRECTION}
 * **params** returns three integer or floating-point values representing the direction of the light source. Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer value. The returned values are those maintained in eye coordinates. They will not be equal to the values specified using {@link glLight}, unless the modelview matrix was identity at the time {@link glLight} was called. Although spot direction is normalized before being used in the lighting equation, the returned values are the transformed versions of the specified values prior to normalization. The initial value is (0,0,−1)
 *
 * - {@link GL_SPOT_EXPONENT}
 * **params** returns a single integer or floating-point value representing the spot exponent of the light. An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer. The initial value is 0.
 *
 * - {@link GL_SPOT_CUTOFF}
 * **params** returns a single integer or floating-point value representing the spot cutoff angle of the light. An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer. The initial value is 180.
 *
 * - {@link GL_CONSTANT_ATTENUATION}
 * **params** returns a single integer or floating-point value representing the constant (not distance-related) attenuation of the light. An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer. The initial value is 1.
 *
 * - {@link GL_LINEAR_ATTENUATION}
 * **params** returns a single integer or floating-point value representing the linear attenuation of the light. An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer. The initial value is 0.
 *
 * - {@link GL_QUADRATIC_ATTENUATION}
 * **params** returns a single integer or floating-point value representing the quadratic attenuation of the light. An integer value, when requested, is computed by rounding the internal floating-point representation to the nearest integer. The initial value is 0.
 *
 * @summary return light source parameter values
 * @param light Specifies a light source. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form {@link GL_LIGHT} 𝐢 where i ranges from 0 to the value of {@link GL_MAX_LIGHTS} - 1.
 * @param pname Specifies a light source parameter for **light**. Accepted symbolic names are {@link GL_AMBIENT}, {@link GL_DIFFUSE}, {@link GL_SPECULAR}, {@link GL_POSITION}, {@link GL_SPOT_DIRECTION}, {@link GL_SPOT_EXPONENT}, {@link GL_SPOT_CUTOFF}, {@link GL_CONSTANT_ATTENUATION}, {@link GL_LINEAR_ATTENUATION}, and {@link GL_QUADRATIC_ATTENUATION}.
 * @param params Returns the requested data.
 * @see [glGetLight](https://docs.gl/gl3/glGetLight)
 */
export function glGetLightiv(light: GLenum, pname: GLenum, params: GLint): void;

/**
 * {@link glMap1} and {@link glMap2} define evaluators. `glGetMap` returns evaluator parameters. **target** chooses a map, **query** selects a specific parameter, and **v** points to storage where the values will be returned.
 *
 * The acceptable values for the **target** parameter are described in the {@link glMap1} and {@link glMap2} reference pages.
 *
 * **query** can assume the following values:
 *
 * - {@link GL_COEFF}
 * **v** returns the control points for the evaluator function. One-dimensional evaluators return *order* control points, and two-dimensional evaluators return *uorder* × *vorder* control points. Each control point consists of one, two, three, or four integer, single-precision floating-point, or double-precision floating-point values, depending on the type of the evaluator. The GL returns two-dimensional control points in row-major order, incrementing the *uorder* index quickly and the *vorder* index after each row. Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer values.
 *
 * - {@link GL_ORDER}
 * **v** returns the order of the evaluator function. One-dimensional evaluators return a single value, *order*. The initial value is 1. Two-dimensional evaluators return two values, *uorder* and *vorder*. The initial value is 1,1.
 *
 * - {@link GL_DOMAIN}
 * **v** returns the linear 𝐮 and 𝐯 mapping parameters. One-dimensional evaluators return two values, 𝐮1 and 𝐮2, as specified by {@link glMap1}. Two-dimensional evaluators return four values (𝐮1, 𝐮2, 𝐯1 and 𝐯2)) as specified by {@link glMap2}. Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer values.
 *
 * @summary return evaluator parameters
 * @param target Specifies the symbolic name of a map. Accepted values are {@link GL_MAP1_COLOR_4}, {@link GL_MAP1_INDEX}, {@link GL_MAP1_NORMAL}, {@link GL_MAP1_TEXTURE_COORD_1}, {@link GL_MAP1_TEXTURE_COORD_2}, {@link GL_MAP1_TEXTURE_COORD_3}, {@link GL_MAP1_TEXTURE_COORD_4}, {@link GL_MAP1_VERTEX_3}, {@link GL_MAP1_VERTEX_4}, {@link GL_MAP2_COLOR_4}, {@link GL_MAP2_INDEX}, {@link GL_MAP2_NORMAL}, {@link GL_MAP2_TEXTURE_COORD_1}, {@link GL_MAP2_TEXTURE_COORD_2}, {@link GL_MAP2_TEXTURE_COORD_3}, {@link GL_MAP2_TEXTURE_COORD_4}, {@link GL_MAP2_VERTEX_3}, and {@link GL_MAP2_VERTEX_4}.
 * @param query Specifies which parameter to return. Symbolic names {@link GL_COEFF}, {@link GL_ORDER}, and {@link GL_DOMAIN} are accepted.
 * @param v Returns the requested data.
 * @see [glGetMap](https://docs.gl/gl3/glGetMap)
 */
export function glGetMapdv(target: GLenum, query: GLenum, v: GLdouble): void;

/**
 * {@link glMap1} and {@link glMap2} define evaluators. `glGetMap` returns evaluator parameters. **target** chooses a map, **query** selects a specific parameter, and **v** points to storage where the values will be returned.
 *
 * The acceptable values for the **target** parameter are described in the {@link glMap1} and {@link glMap2} reference pages.
 *
 * **query** can assume the following values:
 *
 * - {@link GL_COEFF}
 * **v** returns the control points for the evaluator function. One-dimensional evaluators return *order* control points, and two-dimensional evaluators return *uorder* × *vorder* control points. Each control point consists of one, two, three, or four integer, single-precision floating-point, or double-precision floating-point values, depending on the type of the evaluator. The GL returns two-dimensional control points in row-major order, incrementing the *uorder* index quickly and the *vorder* index after each row. Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer values.
 *
 * - {@link GL_ORDER}
 * **v** returns the order of the evaluator function. One-dimensional evaluators return a single value, *order*. The initial value is 1. Two-dimensional evaluators return two values, *uorder* and *vorder*. The initial value is 1,1.
 *
 * - {@link GL_DOMAIN}
 * **v** returns the linear 𝐮 and 𝐯 mapping parameters. One-dimensional evaluators return two values, 𝐮1 and 𝐮2, as specified by {@link glMap1}. Two-dimensional evaluators return four values (𝐮1, 𝐮2, 𝐯1 and 𝐯2)) as specified by {@link glMap2}. Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer values.
 *
 * @summary return evaluator parameters
 * @param target Specifies the symbolic name of a map. Accepted values are {@link GL_MAP1_COLOR_4}, {@link GL_MAP1_INDEX}, {@link GL_MAP1_NORMAL}, {@link GL_MAP1_TEXTURE_COORD_1}, {@link GL_MAP1_TEXTURE_COORD_2}, {@link GL_MAP1_TEXTURE_COORD_3}, {@link GL_MAP1_TEXTURE_COORD_4}, {@link GL_MAP1_VERTEX_3}, {@link GL_MAP1_VERTEX_4}, {@link GL_MAP2_COLOR_4}, {@link GL_MAP2_INDEX}, {@link GL_MAP2_NORMAL}, {@link GL_MAP2_TEXTURE_COORD_1}, {@link GL_MAP2_TEXTURE_COORD_2}, {@link GL_MAP2_TEXTURE_COORD_3}, {@link GL_MAP2_TEXTURE_COORD_4}, {@link GL_MAP2_VERTEX_3}, and {@link GL_MAP2_VERTEX_4}.
 * @param query Specifies which parameter to return. Symbolic names {@link GL_COEFF}, {@link GL_ORDER}, and {@link GL_DOMAIN} are accepted.
 * @param v Returns the requested data.
 * @see [glGetMap](https://docs.gl/gl3/glGetMap)
 */
export function glGetMapfv(target: GLenum, query: GLenum, v: GLfloat): void;

/**
 * {@link glMap1} and {@link glMap2} define evaluators. `glGetMap` returns evaluator parameters. **target** chooses a map, **query** selects a specific parameter, and **v** points to storage where the values will be returned.
 *
 * The acceptable values for the **target** parameter are described in the {@link glMap1} and {@link glMap2} reference pages.
 *
 * **query** can assume the following values:
 *
 * - {@link GL_COEFF}
 * **v** returns the control points for the evaluator function. One-dimensional evaluators return *order* control points, and two-dimensional evaluators return *uorder* × *vorder* control points. Each control point consists of one, two, three, or four integer, single-precision floating-point, or double-precision floating-point values, depending on the type of the evaluator. The GL returns two-dimensional control points in row-major order, incrementing the *uorder* index quickly and the *vorder* index after each row. Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer values.
 *
 * - {@link GL_ORDER}
 * **v** returns the order of the evaluator function. One-dimensional evaluators return a single value, *order*. The initial value is 1. Two-dimensional evaluators return two values, *uorder* and *vorder*. The initial value is 1,1.
 *
 * - {@link GL_DOMAIN}
 * **v** returns the linear 𝐮 and 𝐯 mapping parameters. One-dimensional evaluators return two values, 𝐮1 and 𝐮2, as specified by {@link glMap1}. Two-dimensional evaluators return four values (𝐮1, 𝐮2, 𝐯1 and 𝐯2)) as specified by {@link glMap2}. Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer values.
 *
 * @summary return evaluator parameters
 * @param target Specifies the symbolic name of a map. Accepted values are {@link GL_MAP1_COLOR_4}, {@link GL_MAP1_INDEX}, {@link GL_MAP1_NORMAL}, {@link GL_MAP1_TEXTURE_COORD_1}, {@link GL_MAP1_TEXTURE_COORD_2}, {@link GL_MAP1_TEXTURE_COORD_3}, {@link GL_MAP1_TEXTURE_COORD_4}, {@link GL_MAP1_VERTEX_3}, {@link GL_MAP1_VERTEX_4}, {@link GL_MAP2_COLOR_4}, {@link GL_MAP2_INDEX}, {@link GL_MAP2_NORMAL}, {@link GL_MAP2_TEXTURE_COORD_1}, {@link GL_MAP2_TEXTURE_COORD_2}, {@link GL_MAP2_TEXTURE_COORD_3}, {@link GL_MAP2_TEXTURE_COORD_4}, {@link GL_MAP2_VERTEX_3}, and {@link GL_MAP2_VERTEX_4}.
 * @param query Specifies which parameter to return. Symbolic names {@link GL_COEFF}, {@link GL_ORDER}, and {@link GL_DOMAIN} are accepted.
 * @param v Returns the requested data.
 * @see [glGetMap](https://docs.gl/gl3/glGetMap)
 */
export function glGetMapiv(target: GLenum, query: GLenum, v: GLint): void;

/**
 * `glGetMaterial` returns in **params** the value or values of parameter **pname** of material **face**. Six parameters are defined:
 *
 * - {@link GL_AMBIENT}
 * **params** returns four integer or floating-point values representing the ambient reflectance of the material. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and −1.0 maps to the most negative representable integer value. If the internal value is outside the range [−1,1], the corresponding integer return value is undefined. The initial value is (0.2, 0.2, 0.2, 1.0).
 *
 * - {@link GL_DIFFUSE}
 * **params** returns four integer or floating-point values representing the diffuse reflectance of the material. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and −1.0 maps to the most negative representable integer value. If the internal value is outside the range [−1,1], the corresponding integer return value is undefined. The initial value is (0.8, 0.8, 0.8, 1.0).
 *
 * - {@link GL_SPECULAR}
 * **params** returns four integer or floating-point values representing the specular reflectance of the material. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and −1.0 maps to the most negative representable integer value. If the internal value is outside the range [−1,1], the corresponding integer return value is undefined. The initial value is (0, 0, 0, 1).
 *
 * - {@link GL_EMISSION}
 * **params** returns four integer or floating-point values representing the emitted light intensity of the material. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and −1.0 maps to the most negative representable integer value. If the internal value is outside the range [−1,1], the corresponding integer return value is undefined. The initial value is (0, 0, 0, 1).
 *
 * - {@link GL_SHININESS}
 * **params** returns one integer or floating-point value representing the specular exponent of the material. Integer values, when requested, are computed by rounding the internal floating-point value to the nearest integer value. The initial value is 0.
 *
 * - {@link GL_COLOR_INDEXES}
 * **params** returns three integer or floating-point values representing the ambient, diffuse, and specular indices of the material. These indices are used only for color index lighting. (All the other parameters are used only for RGBA lighting.) Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer values.
 *
 * @summary return material parameters
 * @param face Specifies which of the two materials is being queried. {@link GL_FRONT} or {@link GL_BACK} are accepted, representing the front and back materials, respectively.
 * @param pname Specifies the material parameter to return. {@link GL_AMBIENT}, {@link GL_DIFFUSE}, {@link GL_SPECULAR}, {@link GL_EMISSION}, {@link GL_SHININESS}, and {@link GL_COLOR_INDEXES} are accepted.
 * @param params Returns the requested data.
 * @see [glGetMaterial](https://docs.gl/gl3/glGetMaterial)
 */
export function glGetMaterialfv(
	face: GLenum,
	pname: GLenum,
	params: GLfloat
): void;

/**
 * `glGetMaterial` returns in **params** the value or values of parameter **pname** of material **face**. Six parameters are defined:
 *
 * - {@link GL_AMBIENT}
 * **params** returns four integer or floating-point values representing the ambient reflectance of the material. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and −1.0 maps to the most negative representable integer value. If the internal value is outside the range [−1,1], the corresponding integer return value is undefined. The initial value is (0.2, 0.2, 0.2, 1.0).
 *
 * - {@link GL_DIFFUSE}
 * **params** returns four integer or floating-point values representing the diffuse reflectance of the material. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and −1.0 maps to the most negative representable integer value. If the internal value is outside the range [−1,1], the corresponding integer return value is undefined. The initial value is (0.8, 0.8, 0.8, 1.0).
 *
 * - {@link GL_SPECULAR}
 * **params** returns four integer or floating-point values representing the specular reflectance of the material. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and −1.0 maps to the most negative representable integer value. If the internal value is outside the range [−1,1], the corresponding integer return value is undefined. The initial value is (0, 0, 0, 1).
 *
 * - {@link GL_EMISSION}
 * **params** returns four integer or floating-point values representing the emitted light intensity of the material. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer value, and −1.0 maps to the most negative representable integer value. If the internal value is outside the range [−1,1], the corresponding integer return value is undefined. The initial value is (0, 0, 0, 1).
 *
 * - {@link GL_SHININESS}
 * **params** returns one integer or floating-point value representing the specular exponent of the material. Integer values, when requested, are computed by rounding the internal floating-point value to the nearest integer value. The initial value is 0.
 *
 * - {@link GL_COLOR_INDEXES}
 * **params** returns three integer or floating-point values representing the ambient, diffuse, and specular indices of the material. These indices are used only for color index lighting. (All the other parameters are used only for RGBA lighting.) Integer values, when requested, are computed by rounding the internal floating-point values to the nearest integer values.
 *
 * @summary return material parameters
 * @param face Specifies which of the two materials is being queried. {@link GL_FRONT} or {@link GL_BACK} are accepted, representing the front and back materials, respectively.
 * @param pname Specifies the material parameter to return. {@link GL_AMBIENT}, {@link GL_DIFFUSE}, {@link GL_SPECULAR}, {@link GL_EMISSION}, {@link GL_SHININESS}, and {@link GL_COLOR_INDEXES} are accepted.
 * @param params Returns the requested data.
 * @see [glGetMaterial](https://docs.gl/gl3/glGetMaterial)
 */
export function glGetMaterialiv(
	face: GLenum,
	pname: GLenum,
	params: GLint
): void;

/**
 * See the {@link glPixelMap} reference page for a description of the acceptable values for the **map** parameter. `glGetPixelMap` returns in **data** the contents of the pixel map specified in **map**. Pixel maps are used during the execution of {@link glReadPixels}, {@link glDrawPixels}, {@link glCopyPixels}, {@link glTexImage1D}, {@link glTexImage2D}, {@link glTexImage3D}, {@link glTexSubImage1D}, {@link glTexSubImage2D}, {@link glTexSubImage3D}, {@link glCopyTexImage1D}, {@link glCopyTexImage2D}, {@link glCopyTexSubImage1D}, {@link glCopyTexSubImage2D}, and {@link glCopyTexSubImage3D}. to map color indices, stencil indices, color components, and depth components to other values.
 *
 * If a non-zero named buffer object is bound to the {@link GL_PIXEL_PACK_BUFFER} target (see {@link glBindBuffer}) while a pixel map is requested, **data** is treated as a byte offset into the buffer object's data store.
 *
 * Unsigned integer values, if requested, are linearly mapped from the internal fixed or floating-point representation such that 1.0 maps to the largest representable integer value, and 0.0 maps to 0. Return unsigned integer values are undefined if the map value was not in the range [0,1].
 *
 * To determine the required size of **map**, call {@link glGet} with the appropriate symbolic constant.
 *
 * @summary return the specified pixel map
 * @param map Specifies the name of the pixel map to return. Accepted values are {@link GL_PIXEL_MAP_I_TO_I}, {@link GL_PIXEL_MAP_S_TO_S}, {@link GL_PIXEL_MAP_I_TO_R}, {@link GL_PIXEL_MAP_I_TO_G}, {@link GL_PIXEL_MAP_I_TO_B}, {@link GL_PIXEL_MAP_I_TO_A}, {@link GL_PIXEL_MAP_R_TO_R}, {@link GL_PIXEL_MAP_G_TO_G}, {@link GL_PIXEL_MAP_B_TO_B}, and {@link GL_PIXEL_MAP_A_TO_A}.
 * @param values Returns the pixel map contents.
 * @see [glGetPixelMap](https://docs.gl/gl3/glGetPixelMap)
 */
export function glGetPixelMapfv(map: GLenum, data: GLfloat): void;

/**
 * See the {@link glPixelMap} reference page for a description of the acceptable values for the **map** parameter. `glGetPixelMap` returns in **data** the contents of the pixel map specified in **map**. Pixel maps are used during the execution of {@link glReadPixels}, {@link glDrawPixels}, {@link glCopyPixels}, {@link glTexImage1D}, {@link glTexImage2D}, {@link glTexImage3D}, {@link glTexSubImage1D}, {@link glTexSubImage2D}, {@link glTexSubImage3D}, {@link glCopyTexImage1D}, {@link glCopyTexImage2D}, {@link glCopyTexSubImage1D}, {@link glCopyTexSubImage2D}, and {@link glCopyTexSubImage3D}. to map color indices, stencil indices, color components, and depth components to other values.
 *
 * If a non-zero named buffer object is bound to the {@link GL_PIXEL_PACK_BUFFER} target (see {@link glBindBuffer}) while a pixel map is requested, **data** is treated as a byte offset into the buffer object's data store.
 *
 * Unsigned integer values, if requested, are linearly mapped from the internal fixed or floating-point representation such that 1.0 maps to the largest representable integer value, and 0.0 maps to 0. Return unsigned integer values are undefined if the map value was not in the range [0,1].
 *
 * To determine the required size of **map**, call {@link glGet} with the appropriate symbolic constant.
 *
 * @summary return the specified pixel map
 * @param map Specifies the name of the pixel map to return. Accepted values are {@link GL_PIXEL_MAP_I_TO_I}, {@link GL_PIXEL_MAP_S_TO_S}, {@link GL_PIXEL_MAP_I_TO_R}, {@link GL_PIXEL_MAP_I_TO_G}, {@link GL_PIXEL_MAP_I_TO_B}, {@link GL_PIXEL_MAP_I_TO_A}, {@link GL_PIXEL_MAP_R_TO_R}, {@link GL_PIXEL_MAP_G_TO_G}, {@link GL_PIXEL_MAP_B_TO_B}, and {@link GL_PIXEL_MAP_A_TO_A}.
 * @param values Returns the pixel map contents.
 * @see [glGetPixelMap](https://docs.gl/gl3/glGetPixelMap)
 */
export function glGetPixelMapuiv(map: GLenum, data: GLuint): void;

/**
 * See the {@link glPixelMap} reference page for a description of the acceptable values for the **map** parameter. `glGetPixelMap` returns in **data** the contents of the pixel map specified in **map**. Pixel maps are used during the execution of {@link glReadPixels}, {@link glDrawPixels}, {@link glCopyPixels}, {@link glTexImage1D}, {@link glTexImage2D}, {@link glTexImage3D}, {@link glTexSubImage1D}, {@link glTexSubImage2D}, {@link glTexSubImage3D}, {@link glCopyTexImage1D}, {@link glCopyTexImage2D}, {@link glCopyTexSubImage1D}, {@link glCopyTexSubImage2D}, and {@link glCopyTexSubImage3D}. to map color indices, stencil indices, color components, and depth components to other values.
 *
 * If a non-zero named buffer object is bound to the {@link GL_PIXEL_PACK_BUFFER} target (see {@link glBindBuffer}) while a pixel map is requested, **data** is treated as a byte offset into the buffer object's data store.
 *
 * Unsigned integer values, if requested, are linearly mapped from the internal fixed or floating-point representation such that 1.0 maps to the largest representable integer value, and 0.0 maps to 0. Return unsigned integer values are undefined if the map value was not in the range [0,1].
 *
 * To determine the required size of **map**, call {@link glGet} with the appropriate symbolic constant.
 *
 * @summary return the specified pixel map
 * @param map Specifies the name of the pixel map to return. Accepted values are {@link GL_PIXEL_MAP_I_TO_I}, {@link GL_PIXEL_MAP_S_TO_S}, {@link GL_PIXEL_MAP_I_TO_R}, {@link GL_PIXEL_MAP_I_TO_G}, {@link GL_PIXEL_MAP_I_TO_B}, {@link GL_PIXEL_MAP_I_TO_A}, {@link GL_PIXEL_MAP_R_TO_R}, {@link GL_PIXEL_MAP_G_TO_G}, {@link GL_PIXEL_MAP_B_TO_B}, and {@link GL_PIXEL_MAP_A_TO_A}.
 * @param values Returns the pixel map contents.
 * @see [glGetPixelMap](https://docs.gl/gl3/glGetPixelMap)
 */
export function glGetPixelMapusv(map: GLenum, data: GLushort): void;

/**
 * `glGetPointerv` returns pointer information. **pname** is a symbolic constant indicating the pointer to be returned, and **params** is a pointer to a location in which to place the returned data.
 *
 * For all **pname** arguments except {@link GL_FEEDBACK_BUFFER_POINTER} and {@link GL_SELECTION_BUFFER_POINTER}, if a non-zero named buffer object was bound to the {@link GL_ARRAY_BUFFER} target (see {@link glBindBuffer}) when the desired pointer was previously specified, the pointer returned is a byte offset into the buffer object's data store. Buffer objects are only available in OpenGL versions 1.5 and greater.
 *
 * @summary return the address of the specified pointer
 * @param pname Specifies the array or buffer pointer to be returned. Symbolic constants {@link GL_COLOR_ARRAY_POINTER}, {@link GL_EDGE_FLAG_ARRAY_POINTER}, {@link GL_FOG_COORD_ARRAY_POINTER}, {@link GL_FEEDBACK_BUFFER_POINTER}, {@link GL_INDEX_ARRAY_POINTER}, {@link GL_NORMAL_ARRAY_POINTER}, {@link GL_SECONDARY_COLOR_ARRAY_POINTER}, {@link GL_SELECTION_BUFFER_POINTER}, {@link GL_TEXTURE_COORD_ARRAY_POINTER}, or {@link GL_VERTEX_ARRAY_POINTER} are accepted.
 * @param params Returns the pointer value specified by **pname**.
 * @see [glGetPointerv](https://docs.gl/gl3/glGetPointerv)
 */
export function glGetPointerv(pname: GLenum, params: GLvoid): void;

/**
 * `glGetPolygonStipple` returns to **pattern** a 32 × 32 polygon stipple pattern. The pattern is packed into memory as if {@link glReadPixels} with both **height** and **width** of 32, **type** of {@link GL_BITMAP}, and **format** of {@link GL_COLOR_INDEX} were called, and the stipple pattern were stored in an internal 32 × 32 color index buffer. Unlike {@link glReadPixels}, however, pixel transfer operations (shift, offset, pixel map) are not applied to the returned stipple image.
 *
 * If a non-zero named buffer object is bound to the {@link GL_PIXEL_PACK_BUFFER} target (see {@link glBindBuffer}) while a polygon stipple pattern is requested, **pattern** is treated as a byte offset into the buffer object's data store.
 *
 * @summary return the polygon stipple pattern
 * @param pattern Returns the stipple pattern. The initial value is all 1's.
 * @see [glGetPolygonStipple](https://docs.gl/gl3/glGetPolygonStipple)
 */
export function glGetPolygonStipple(pattern: GLubyte): void;

/**
 * `glGetString` returns a pointer to a static string describing some aspect of the current GL connection. **name** can be one of the following:
 *
 * - {@link GL_VENDOR}
 * Returns the company responsible for this GL implementation. This name does not change from release to release.
 *
 * - {@link GL_RENDERER}
 * Returns the name of the renderer. This name is typically specific to a particular configuration of a hardware platform. It does not change from release to release.
 *
 * - {@link GL_VERSION}
 * Returns a version or release number.
 *
 * - {@link GL_SHADING_LANGUAGE_VERSION}
 * Returns a version or release number for the shading language.
 *
 * `glGetStringi` returns a pointer to a static string indexed by **index**. **name** can be one of the following:
 *
 * - {@link GL_EXTENSIONS}
 * For `glGetStringi` only, returns the extension string supported by the implementation at **index**.
 *
 * Strings {@link GL_VENDOR} and {@link GL_RENDERER} together uniquely specify a platform. They do not change from release to release and should be used by platform-recognition algorithms.
 *
 * The {@link GL_VERSION} and {@link GL_SHADING_LANGUAGE_VERSION} strings begin with a version number. The version number uses one of these forms:
 *
 * `major_number.minor_number` `major_number.minor_number.release_number`
 *
 * Vendor-specific information may follow the version number. Its format depends on the implementation, but a space always separates the version number and the vendor-specific information.
 *
 * All strings are null-terminated.
 *
 * @summary return a string describing the current GL connection
 * @param name Specifies a symbolic constant, one of {@link GL_VENDOR}, {@link GL_RENDERER}, {@link GL_VERSION}, or {@link GL_SHADING_LANGUAGE_VERSION}. Additionally, `glGetStringi` accepts the {@link GL_EXTENSIONS} token.
 * @param index For `glGetStringi`, specifies the index of the string to return.
 * @see [glGetString](https://docs.gl/gl3/glGetString)
 */
export function glGetString(): void;

/**
 * `glGetTexEnv` returns in **params** selected values of a texture environment that was specified with {@link glTexEnv}. **target** specifies a texture environment.
 *
 * When **target** is {@link GL_TEXTURE_FILTER_CONTROL}, **pname** must be {@link GL_TEXTURE_LOD_BIAS}. When **target** is {@link GL_POINT_SPRITE}, **pname** must be {@link GL_COORD_REPLACE}. When **target** is {@link GL_TEXTURE_ENV}, **pname** can be {@link GL_TEXTURE_ENV_MODE}, {@link GL_TEXTURE_ENV_COLOR}, {@link GL_COMBINE_RGB}, {@link GL_COMBINE_ALPHA}, {@link GL_RGB_SCALE}, {@link GL_ALPHA_SCALE}, {@link GL_SRC0_RGB}, {@link GL_SRC1_RGB}, {@link GL_SRC2_RGB}, {@link GL_SRC0_ALPHA}, {@link GL_SRC1_ALPHA}, or {@link GL_SRC2_ALPHA}.
 *
 * **pname** names a specific texture environment parameter, as follows:
 *
 * - {@link GL_TEXTURE_ENV_MODE}
 * **params** returns the single-valued texture environment mode, a symbolic constant. The initial value is {@link GL_MODULATE}.
 *
 * - {@link GL_TEXTURE_ENV_COLOR}
 * **params** returns four integer or floating-point values that are the texture environment color. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer, and −1.0 maps to the most negative representable integer. The initial value is (0, 0, 0, 0).
 *
 * - {@link GL_TEXTURE_LOD_BIAS}
 * **params** returns a single floating-point value that is the texture level-of-detail bias. The initial value is 0.
 *
 * - {@link GL_COMBINE_RGB}
 * **params** returns a single symbolic constant value representing the current RGB combine mode. The initial value is {@link GL_MODULATE}.
 *
 * - {@link GL_COMBINE_ALPHA}
 * **params** returns a single symbolic constant value representing the current alpha combine mode. The initial value is {@link GL_MODULATE}.
 *
 * - {@link GL_SRC0_RGB}
 * **params** returns a single symbolic constant value representing the texture combiner zero's RGB source. The initial value is {@link GL_TEXTURE}.
 *
 * - {@link GL_SRC1_RGB}
 * **params** returns a single symbolic constant value representing the texture combiner one's RGB source. The initial value is {@link GL_PREVIOUS}.
 *
 * - {@link GL_SRC2_RGB}
 * **params** returns a single symbolic constant value representing the texture combiner two's RGB source. The initial value is {@link GL_CONSTANT}.
 *
 * - {@link GL_SRC0_ALPHA}
 * **params** returns a single symbolic constant value representing the texture combiner zero's alpha source. The initial value is {@link GL_TEXTURE}.
 *
 * - {@link GL_SRC1_ALPHA}
 * **params** returns a single symbolic constant value representing the texture combiner one's alpha source. The initial value is {@link GL_PREVIOUS}.
 *
 * - {@link GL_SRC2_ALPHA}
 * **params** returns a single symbolic constant value representing the texture combiner two's alpha source. The initial value is {@link GL_CONSTANT}.
 *
 * - {@link GL_OPERAND0_RGB}
 * **params** returns a single symbolic constant value representing the texture combiner zero's RGB operand. The initial value is {@link GL_SRC_COLOR}.
 *
 * - {@link GL_OPERAND1_RGB}
 * **params** returns a single symbolic constant value representing the texture combiner one's RGB operand. The initial value is {@link GL_SRC_COLOR}.
 *
 * - {@link GL_OPERAND2_RGB}
 * **params** returns a single symbolic constant value representing the texture combiner two's RGB operand. The initial value is {@link GL_SRC_ALPHA}.
 *
 * - {@link GL_OPERAND0_ALPHA}
 * **params** returns a single symbolic constant value representing the texture combiner zero's alpha operand. The initial value is {@link GL_SRC_ALPHA}.
 *
 * - {@link GL_OPERAND1_ALPHA}
 * **params** returns a single symbolic constant value representing the texture combiner one's alpha operand. The initial value is {@link GL_SRC_ALPHA}.
 *
 * - {@link GL_OPERAND2_ALPHA}
 * **params** returns a single symbolic constant value representing the texture combiner two's alpha operand. The initial value is {@link GL_SRC_ALPHA}.
 *
 * - {@link GL_RGB_SCALE}
 * **params** returns a single floating-point value representing the current RGB texture combiner scaling factor. The initial value is 1.0.
 *
 * - {@link GL_ALPHA_SCALE}
 * **params** returns a single floating-point value representing the current alpha texture combiner scaling factor. The initial value is 1.0.
 *
 * - {@link GL_COORD_REPLACE}
 * **params** returns a single boolean value representing the current point sprite texture coordinate replacement enable state. The initial value is {@link GL_FALSE}.
 *
 * @summary return texture environment parameters
 * @param target Specifies a texture environment. May be {@link GL_TEXTURE_ENV}, {@link GL_TEXTURE_FILTER_CONTROL}, or {@link GL_POINT_SPRITE}.
 * @param pname Specifies the symbolic name of a texture environment parameter. Accepted values are {@link GL_TEXTURE_ENV_MODE}, {@link GL_TEXTURE_ENV_COLOR}, {@link GL_TEXTURE_LOD_BIAS}, {@link GL_COMBINE_RGB}, {@link GL_COMBINE_ALPHA}, {@link GL_SRC0_RGB}, {@link GL_SRC1_RGB}, {@link GL_SRC2_RGB}, {@link GL_SRC0_ALPHA}, {@link GL_SRC1_ALPHA}, {@link GL_SRC2_ALPHA}, {@link GL_OPERAND0_RGB}, {@link GL_OPERAND1_RGB}, {@link GL_OPERAND2_RGB}, {@link GL_OPERAND0_ALPHA}, {@link GL_OPERAND1_ALPHA}, {@link GL_OPERAND2_ALPHA}, {@link GL_RGB_SCALE}, {@link GL_ALPHA_SCALE}, or {@link GL_COORD_REPLACE}.
 * @param params Returns the requested data.
 * @see [glGetTexEnv](https://docs.gl/gl3/glGetTexEnv)
 */
export function glGetTexEnvfv(
	target: GLenum,
	pname: GLenum,
	params: GLfloat
): void;

/**
 * `glGetTexEnv` returns in **params** selected values of a texture environment that was specified with {@link glTexEnv}. **target** specifies a texture environment.
 *
 * When **target** is {@link GL_TEXTURE_FILTER_CONTROL}, **pname** must be {@link GL_TEXTURE_LOD_BIAS}. When **target** is {@link GL_POINT_SPRITE}, **pname** must be {@link GL_COORD_REPLACE}. When **target** is {@link GL_TEXTURE_ENV}, **pname** can be {@link GL_TEXTURE_ENV_MODE}, {@link GL_TEXTURE_ENV_COLOR}, {@link GL_COMBINE_RGB}, {@link GL_COMBINE_ALPHA}, {@link GL_RGB_SCALE}, {@link GL_ALPHA_SCALE}, {@link GL_SRC0_RGB}, {@link GL_SRC1_RGB}, {@link GL_SRC2_RGB}, {@link GL_SRC0_ALPHA}, {@link GL_SRC1_ALPHA}, or {@link GL_SRC2_ALPHA}.
 *
 * **pname** names a specific texture environment parameter, as follows:
 *
 * - {@link GL_TEXTURE_ENV_MODE}
 * **params** returns the single-valued texture environment mode, a symbolic constant. The initial value is {@link GL_MODULATE}.
 *
 * - {@link GL_TEXTURE_ENV_COLOR}
 * **params** returns four integer or floating-point values that are the texture environment color. Integer values, when requested, are linearly mapped from the internal floating-point representation such that 1.0 maps to the most positive representable integer, and −1.0 maps to the most negative representable integer. The initial value is (0, 0, 0, 0).
 *
 * - {@link GL_TEXTURE_LOD_BIAS}
 * **params** returns a single floating-point value that is the texture level-of-detail bias. The initial value is 0.
 *
 * - {@link GL_COMBINE_RGB}
 * **params** returns a single symbolic constant value representing the current RGB combine mode. The initial value is {@link GL_MODULATE}.
 *
 * - {@link GL_COMBINE_ALPHA}
 * **params** returns a single symbolic constant value representing the current alpha combine mode. The initial value is {@link GL_MODULATE}.
 *
 * - {@link GL_SRC0_RGB}
 * **params** returns a single symbolic constant value representing the texture combiner zero's RGB source. The initial value is {@link GL_TEXTURE}.
 *
 * - {@link GL_SRC1_RGB}
 * **params** returns a single symbolic constant value representing the texture combiner one's RGB source. The initial value is {@link GL_PREVIOUS}.
 *
 * - {@link GL_SRC2_RGB}
 * **params** returns a single symbolic constant value representing the texture combiner two's RGB source. The initial value is {@link GL_CONSTANT}.
 *
 * - {@link GL_SRC0_ALPHA}
 * **params** returns a single symbolic constant value representing the texture combiner zero's alpha source. The initial value is {@link GL_TEXTURE}.
 *
 * - {@link GL_SRC1_ALPHA}
 * **params** returns a single symbolic constant value representing the texture combiner one's alpha source. The initial value is {@link GL_PREVIOUS}.
 *
 * - {@link GL_SRC2_ALPHA}
 * **params** returns a single symbolic constant value representing the texture combiner two's alpha source. The initial value is {@link GL_CONSTANT}.
 *
 * - {@link GL_OPERAND0_RGB}
 * **params** returns a single symbolic constant value representing the texture combiner zero's RGB operand. The initial value is {@link GL_SRC_COLOR}.
 *
 * - {@link GL_OPERAND1_RGB}
 * **params** returns a single symbolic constant value representing the texture combiner one's RGB operand. The initial value is {@link GL_SRC_COLOR}.
 *
 * - {@link GL_OPERAND2_RGB}
 * **params** returns a single symbolic constant value representing the texture combiner two's RGB operand. The initial value is {@link GL_SRC_ALPHA}.
 *
 * - {@link GL_OPERAND0_ALPHA}
 * **params** returns a single symbolic constant value representing the texture combiner zero's alpha operand. The initial value is {@link GL_SRC_ALPHA}.
 *
 * - {@link GL_OPERAND1_ALPHA}
 * **params** returns a single symbolic constant value representing the texture combiner one's alpha operand. The initial value is {@link GL_SRC_ALPHA}.
 *
 * - {@link GL_OPERAND2_ALPHA}
 * **params** returns a single symbolic constant value representing the texture combiner two's alpha operand. The initial value is {@link GL_SRC_ALPHA}.
 *
 * - {@link GL_RGB_SCALE}
 * **params** returns a single floating-point value representing the current RGB texture combiner scaling factor. The initial value is 1.0.
 *
 * - {@link GL_ALPHA_SCALE}
 * **params** returns a single floating-point value representing the current alpha texture combiner scaling factor. The initial value is 1.0.
 *
 * - {@link GL_COORD_REPLACE}
 * **params** returns a single boolean value representing the current point sprite texture coordinate replacement enable state. The initial value is {@link GL_FALSE}.
 *
 * @summary return texture environment parameters
 * @param target Specifies a texture environment. May be {@link GL_TEXTURE_ENV}, {@link GL_TEXTURE_FILTER_CONTROL}, or {@link GL_POINT_SPRITE}.
 * @param pname Specifies the symbolic name of a texture environment parameter. Accepted values are {@link GL_TEXTURE_ENV_MODE}, {@link GL_TEXTURE_ENV_COLOR}, {@link GL_TEXTURE_LOD_BIAS}, {@link GL_COMBINE_RGB}, {@link GL_COMBINE_ALPHA}, {@link GL_SRC0_RGB}, {@link GL_SRC1_RGB}, {@link GL_SRC2_RGB}, {@link GL_SRC0_ALPHA}, {@link GL_SRC1_ALPHA}, {@link GL_SRC2_ALPHA}, {@link GL_OPERAND0_RGB}, {@link GL_OPERAND1_RGB}, {@link GL_OPERAND2_RGB}, {@link GL_OPERAND0_ALPHA}, {@link GL_OPERAND1_ALPHA}, {@link GL_OPERAND2_ALPHA}, {@link GL_RGB_SCALE}, {@link GL_ALPHA_SCALE}, or {@link GL_COORD_REPLACE}.
 * @param params Returns the requested data.
 * @see [glGetTexEnv](https://docs.gl/gl3/glGetTexEnv)
 */
export function glGetTexEnviv(
	target: GLenum,
	pname: GLenum,
	params: GLint
): void;

/**
 * `glGetTexGen` returns in **params** selected parameters of a texture coordinate generation function that was specified using {@link glTexGen}. **coord** names one of the (**s**, **t**, **r**, **q**) texture coordinates, using the symbolic constant {@link GL_S}, {@link GL_T}, {@link GL_R}, or {@link GL_Q}.
 *
 * **pname** specifies one of three symbolic names:
 *
 * - {@link GL_TEXTURE_GEN_MODE}
 * **params** returns the single-valued texture generation function, a symbolic constant. The initial value is {@link GL_EYE_LINEAR}.
 *
 * - {@link GL_OBJECT_PLANE}
 * **params** returns the four plane equation coefficients that specify object linear-coordinate generation. Integer values, when requested, are mapped directly from the internal floating-point representation.
 *
 * - {@link GL_EYE_PLANE}
 * **params** returns the four plane equation coefficients that specify eye linear-coordinate generation. Integer values, when requested, are mapped directly from the internal floating-point representation. The returned values are those maintained in eye coordinates. They are not equal to the values specified using {@link glTexGen}, unless the modelview matrix was identity when {@link glTexGen} was called.
 *
 * @summary return texture coordinate generation parameters
 * @param coord Specifies a texture coordinate. Must be {@link GL_S}, {@link GL_T}, {@link GL_R}, or {@link GL_Q}.
 * @param pname Specifies the symbolic name of the value(s) to be returned. Must be either {@link GL_TEXTURE_GEN_MODE} or the name of one of the texture generation plane equations: {@link GL_OBJECT_PLANE} or {@link GL_EYE_PLANE}.
 * @param params Returns the requested data.
 * @see [glGetTexGen](https://docs.gl/gl3/glGetTexGen)
 */
export function glGetTexGendv(
	coord: GLenum,
	pname: GLenum,
	params: GLdouble
): void;

/**
 * `glGetTexGen` returns in **params** selected parameters of a texture coordinate generation function that was specified using {@link glTexGen}. **coord** names one of the (**s**, **t**, **r**, **q**) texture coordinates, using the symbolic constant {@link GL_S}, {@link GL_T}, {@link GL_R}, or {@link GL_Q}.
 *
 * **pname** specifies one of three symbolic names:
 *
 * - {@link GL_TEXTURE_GEN_MODE}
 * **params** returns the single-valued texture generation function, a symbolic constant. The initial value is {@link GL_EYE_LINEAR}.
 *
 * - {@link GL_OBJECT_PLANE}
 * **params** returns the four plane equation coefficients that specify object linear-coordinate generation. Integer values, when requested, are mapped directly from the internal floating-point representation.
 *
 * - {@link GL_EYE_PLANE}
 * **params** returns the four plane equation coefficients that specify eye linear-coordinate generation. Integer values, when requested, are mapped directly from the internal floating-point representation. The returned values are those maintained in eye coordinates. They are not equal to the values specified using {@link glTexGen}, unless the modelview matrix was identity when {@link glTexGen} was called.
 *
 * @summary return texture coordinate generation parameters
 * @param coord Specifies a texture coordinate. Must be {@link GL_S}, {@link GL_T}, {@link GL_R}, or {@link GL_Q}.
 * @param pname Specifies the symbolic name of the value(s) to be returned. Must be either {@link GL_TEXTURE_GEN_MODE} or the name of one of the texture generation plane equations: {@link GL_OBJECT_PLANE} or {@link GL_EYE_PLANE}.
 * @param params Returns the requested data.
 * @see [glGetTexGen](https://docs.gl/gl3/glGetTexGen)
 */
export function glGetTexGenfv(
	coord: GLenum,
	pname: GLenum,
	params: GLfloat
): void;

/**
 * `glGetTexGen` returns in **params** selected parameters of a texture coordinate generation function that was specified using {@link glTexGen}. **coord** names one of the (**s**, **t**, **r**, **q**) texture coordinates, using the symbolic constant {@link GL_S}, {@link GL_T}, {@link GL_R}, or {@link GL_Q}.
 *
 * **pname** specifies one of three symbolic names:
 *
 * - {@link GL_TEXTURE_GEN_MODE}
 * **params** returns the single-valued texture generation function, a symbolic constant. The initial value is {@link GL_EYE_LINEAR}.
 *
 * - {@link GL_OBJECT_PLANE}
 * **params** returns the four plane equation coefficients that specify object linear-coordinate generation. Integer values, when requested, are mapped directly from the internal floating-point representation.
 *
 * - {@link GL_EYE_PLANE}
 * **params** returns the four plane equation coefficients that specify eye linear-coordinate generation. Integer values, when requested, are mapped directly from the internal floating-point representation. The returned values are those maintained in eye coordinates. They are not equal to the values specified using {@link glTexGen}, unless the modelview matrix was identity when {@link glTexGen} was called.
 *
 * @summary return texture coordinate generation parameters
 * @param coord Specifies a texture coordinate. Must be {@link GL_S}, {@link GL_T}, {@link GL_R}, or {@link GL_Q}.
 * @param pname Specifies the symbolic name of the value(s) to be returned. Must be either {@link GL_TEXTURE_GEN_MODE} or the name of one of the texture generation plane equations: {@link GL_OBJECT_PLANE} or {@link GL_EYE_PLANE}.
 * @param params Returns the requested data.
 * @see [glGetTexGen](https://docs.gl/gl3/glGetTexGen)
 */
export function glGetTexGeniv(
	coord: GLenum,
	pname: GLenum,
	params: GLint
): void;

/**
 * `glGetTexImage` returns a texture image into **img**. **target** specifies whether the desired texture image is one specified by {@link glTexImage1D} ({@link GL_TEXTURE_1D}), {@link glTexImage2D} ({@link GL_TEXTURE_1D_ARRAY}, {@link GL_TEXTURE_RECTANGLE}, {@link GL_TEXTURE_2D} or any of {@link GL_TEXTURE_CUBE_MAP_*}), or {@link glTexImage3D} ({@link GL_TEXTURE_2D_ARRAY}, {@link GL_TEXTURE_3D}). **level** specifies the level-of-detail number of the desired image. **format** and **type** specify the format and type of the desired image array. See the reference page for {@link glTexImage1D} for a description of the acceptable values for the **format** and **type** parameters, respectively.
 *
 * If a non-zero named buffer object is bound to the {@link GL_PIXEL_PACK_BUFFER} target (see {@link glBindBuffer}) while a texture image is requested, **img** is treated as a byte offset into the buffer object's data store.
 *
 * To understand the operation of `glGetTexImage`, consider the selected internal four-component texture image to be an RGBA color buffer the size of the image. The semantics of `glGetTexImage` are then identical to those of {@link glReadPixels}, with the exception that no pixel transfer operations are performed, when called with the same **format** and **type**, with **x** and **y** set to 0, **width** set to the width of the texture image and **height** set to 1 for 1D images, or to the height of the texture image for 2D images.
 *
 * If the selected texture image does not contain four components, the following mappings are applied. Single-component textures are treated as RGBA buffers with red set to the single-component value, green set to 0, blue set to 0, and alpha set to 1. Two-component textures are treated as RGBA buffers with red set to the value of component zero, alpha set to the value of component one, and green and blue set to 0. Finally, three-component textures are treated as RGBA buffers with red set to component zero, green set to component one, blue set to component two, and alpha set to 1.
 *
 * To determine the required size of **img**, use {@link glGetTexLevelParameter} to determine the dimensions of the internal texture image, then scale the required number of pixels by the storage required for each pixel, based on **format** and **type**. Be sure to take the pixel storage parameters into account, especially {@link GL_PACK_ALIGNMENT}.
 *
 * @summary return a texture image
 * @param target Specifies which texture is to be obtained. {@link GL_TEXTURE_1D}, {@link GL_TEXTURE_2D}, {@link GL_TEXTURE_3D}, {@link GL_TEXTURE_1D_ARRAY}, {@link GL_TEXTURE_2D_ARRAY}, {@link GL_TEXTURE_RECTANGLE}, {@link GL_TEXTURE_CUBE_MAP_POSITIVE_X}, {@link GL_TEXTURE_CUBE_MAP_NEGATIVE_X}, {@link GL_TEXTURE_CUBE_MAP_POSITIVE_Y}, {@link GL_TEXTURE_CUBE_MAP_NEGATIVE_Y}, {@link GL_TEXTURE_CUBE_MAP_POSITIVE_Z}, and {@link GL_TEXTURE_CUBE_MAP_NEGATIVE_Z} are accepted.
 * @param level Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level 𝐧 is the 𝐧ᵗʰ mipmap reduction image.
 * @param format Specifies a pixel format for the returned data. The supported formats are {@link GL_STENCIL_INDEX}, {@link GL_DEPTH_COMPONENT}, {@link GL_DEPTH_STENCIL}, {@link GL_RED}, {@link GL_GREEN}, {@link GL_BLUE}, {@link GL_RG}, {@link GL_RGB}, {@link GL_RGBA}, {@link GL_BGR}, {@link GL_BGRA}, {@link GL_RED_INTEGER}, {@link GL_GREEN_INTEGER}, {@link GL_BLUE_INTEGER}, {@link GL_RG_INTEGER}, {@link GL_RGB_INTEGER}, {@link GL_RGBA_INTEGER}, {@link GL_BGR_INTEGER}, {@link GL_BGRA_INTEGER}.
 * @param type Specifies a pixel type for the returned data. The supported types are {@link GL_UNSIGNED_BYTE}, {@link GL_BYTE}, {@link GL_UNSIGNED_SHORT}, {@link GL_SHORT}, {@link GL_UNSIGNED_INT}, {@link GL_INT}, {@link GL_HALF_FLOAT}, {@link GL_FLOAT}, {@link GL_UNSIGNED_BYTE_3_3_2}, {@link GL_UNSIGNED_BYTE_2_3_3_REV}, {@link GL_UNSIGNED_SHORT_5_6_5}, {@link GL_UNSIGNED_SHORT_5_6_5_REV}, {@link GL_UNSIGNED_SHORT_4_4_4_4}, {@link GL_UNSIGNED_SHORT_4_4_4_4_REV}, {@link GL_UNSIGNED_SHORT_5_5_5_1}, {@link GL_UNSIGNED_SHORT_1_5_5_5_REV}, {@link GL_UNSIGNED_INT_8_8_8_8}, {@link GL_UNSIGNED_INT_8_8_8_8_REV}, {@link GL_UNSIGNED_INT_10_10_10_2}, {@link GL_UNSIGNED_INT_2_10_10_10_REV}, {@link GL_UNSIGNED_INT_24_8}, {@link GL_UNSIGNED_INT_10F_11F_11F_REV}, {@link GL_UNSIGNED_INT_5_9_9_9_REV}, and {@link GL_FLOAT_32_UNSIGNED_INT_24_8_REV}.
 * @param img Returns the texture image. Should be a pointer to an array of the type specified by **type**.
 * @example Read the texture from GPU memory into a buffer.
 * ```
 * glBindTexture(GL_TEXTURE_2D, texture_id); // texture_id was given by glGenTextures
 *
 * // texture_data must be large enough to hold the entire texture, in this case
 * // sizeof(float) * width * height * 3
 * glGetTexImage(GL_TEXTURE_2D, 0, GL_RGB, GL_FLOAT, texture_data);
 * ```
 * @see [glGetTexImage](https://docs.gl/gl3/glGetTexImage)
 */
export function glGetTexImage(
	target: GLenum,
	level: GLint,
	format: GLenum,
	type: GLenum,
	img: GLvoid
): void;

/**
 * `glGetTexLevelParameter` returns in **params** texture parameter values for a specific level-of-detail value, specified as **level**. **target** defines the target texture, either {@link GL_TEXTURE_1D}, {@link GL_TEXTURE_2D}, {@link GL_TEXTURE_3D}, {@link GL_PROXY_TEXTURE_1D}, {@link GL_PROXY_TEXTURE_2D}, {@link GL_PROXY_TEXTURE_3D}, {@link GL_TEXTURE_CUBE_MAP_POSITIVE_X}, {@link GL_TEXTURE_CUBE_MAP_NEGATIVE_X}, {@link GL_TEXTURE_CUBE_MAP_POSITIVE_Y}, {@link GL_TEXTURE_CUBE_MAP_NEGATIVE_Y}, {@link GL_TEXTURE_CUBE_MAP_POSITIVE_Z}, {@link GL_TEXTURE_CUBE_MAP_NEGATIVE_Z}, or {@link GL_PROXY_TEXTURE_CUBE_MAP}.
 *
 * {@link GL_MAX_TEXTURE_SIZE}, and {@link GL_MAX_3D_TEXTURE_SIZE} are not really descriptive enough. It has to report the largest square texture image that can be accommodated with mipmaps but a long skinny texture, or a texture without mipmaps may easily fit in texture memory. The proxy targets allow the user to more accurately query whether the GL can accommodate a texture of a given configuration. If the texture cannot be accommodated, the texture state variables, which may be queried with `glGetTexLevelParameter`, are set to 0. If the texture can be accommodated, the texture state values will be set as they would be set for a non-proxy target.
 *
 * **pname** specifies the texture parameter whose value or values will be returned.
 *
 * The accepted parameter names are as follows:
 *
 * - {@link GL_TEXTURE_WIDTH}
 * **params** returns a single value, the width of the texture image. The initial value is 0.
 *
 * - {@link GL_TEXTURE_HEIGHT}
 * **params** returns a single value, the height of the texture image. The initial value is 0.
 *
 * - {@link GL_TEXTURE_DEPTH}
 * **params** returns a single value, the depth of the texture image. The initial value is 0.
 *
 * - {@link GL_TEXTURE_INTERNAL_FORMAT}
 * **params** returns a single value, the internal format of the texture image.
 *
 * - {@link GL_TEXTURE_RED_TYPE}, {@link GL_TEXTURE_GREEN_TYPE}, {@link GL_TEXTURE_BLUE_TYPE}, {@link GL_TEXTURE_ALPHA_TYPE}, {@link GL_TEXTURE_DEPTH_TYPE}
 * The data type used to store the component. The types {@link GL_NONE}, {@link GL_SIGNED_NORMALIZED}, {@link GL_UNSIGNED_NORMALIZED}, {@link GL_FLOAT}, {@link GL_INT}, and {@link GL_UNSIGNED_INT} may be returned to indicate signed normalized fixed-point, unsigned normalized fixed-point, floating-point, integer unnormalized, and unsigned integer unnormalized components, respectively.
 *
 * - {@link GL_TEXTURE_RED_SIZE}, {@link GL_TEXTURE_GREEN_SIZE}, {@link GL_TEXTURE_BLUE_SIZE}, {@link GL_TEXTURE_ALPHA_SIZE}, {@link GL_TEXTURE_DEPTH_SIZE}
 * The internal storage resolution of an individual component. The resolution chosen by the GL will be a close match for the resolution requested by the user with the component argument of {@link glTexImage1D}, {@link glTexImage2D}, {@link glTexImage3D}, {@link glCopyTexImage1D}, and {@link glCopyTexImage2D}. The initial value is 0.
 *
 * - {@link GL_TEXTURE_COMPRESSED}
 * **params** returns a single boolean value indicating if the texture image is stored in a compressed internal format. The initiali value is {@link GL_FALSE}.
 *
 * - {@link GL_TEXTURE_COMPRESSED_IMAGE_SIZE}
 * **params** returns a single integer value, the number of unsigned bytes of the compressed texture image that would be returned from {@link glGetCompressedTexImage}.
 *
 * @summary return texture parameter values for a specific level of detail
 * @param target Specifies the symbolic name of the target texture, one of {@link GL_TEXTURE_1D}, {@link GL_TEXTURE_2D}, {@link GL_TEXTURE_3D}, {@link GL_TEXTURE_1D_ARRAY}, {@link GL_TEXTURE_2D_ARRAY}, {@link GL_TEXTURE_RECTANGLE}, {@link GL_TEXTURE_2D_MULTISAMPLE}, {@link GL_TEXTURE_2D_MULTISAMPLE_ARRAY}, {@link GL_TEXTURE_CUBE_MAP_POSITIVE_X}, {@link GL_TEXTURE_CUBE_MAP_NEGATIVE_X}, {@link GL_TEXTURE_CUBE_MAP_POSITIVE_Y}, {@link GL_TEXTURE_CUBE_MAP_NEGATIVE_Y}, {@link GL_TEXTURE_CUBE_MAP_POSITIVE_Z}, {@link GL_TEXTURE_CUBE_MAP_NEGATIVE_Z}, {@link GL_PROXY_TEXTURE_1D}, {@link GL_PROXY_TEXTURE_2D}, {@link GL_PROXY_TEXTURE_3D}, {@link GL_PROXY_TEXTURE_1D_ARRAY}, {@link GL_PROXY_TEXTURE_2D_ARRAY}, {@link GL_PROXY_TEXTURE_RECTANGLE}, {@link GL_PROXY_TEXTURE_2D_MULTISAMPLE}, {@link GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY}, {@link GL_PROXY_TEXTURE_CUBE_MAP}, or {@link GL_TEXTURE_BUFFER}.
 * @param level Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level 𝐧 is the 𝐧ᵗʰ mipmap reduction image.
 * @param pname Specifies the symbolic name of a texture parameter. {@link GL_TEXTURE_WIDTH}, {@link GL_TEXTURE_HEIGHT}, {@link GL_TEXTURE_DEPTH}, {@link GL_TEXTURE_INTERNAL_FORMAT}, {@link GL_TEXTURE_RED_SIZE}, {@link GL_TEXTURE_GREEN_SIZE}, {@link GL_TEXTURE_BLUE_SIZE}, {@link GL_TEXTURE_ALPHA_SIZE}, {@link GL_TEXTURE_DEPTH_SIZE}, {@link GL_TEXTURE_COMPRESSED}, and {@link GL_TEXTURE_COMPRESSED_IMAGE_SIZE} are accepted.
 * @param params Returns the requested data.
 * @tutorial [Sébastien Dominé - Using Texture Compression in OpenGL](https://www.oldunreal.com/editing/s3tc/ARB_texture_compression.pdf)
 * @see [glGetTexLevelParameter](https://docs.gl/gl3/glGetTexLevelParameter)
 */
export function glGetTexLevelParameterfv(
	target: GLenum,
	level: GLint,
	pname: GLenum,
	params: GLfloat
): void;

/**
 * `glGetTexLevelParameter` returns in **params** texture parameter values for a specific level-of-detail value, specified as **level**. **target** defines the target texture, either {@link GL_TEXTURE_1D}, {@link GL_TEXTURE_2D}, {@link GL_TEXTURE_3D}, {@link GL_PROXY_TEXTURE_1D}, {@link GL_PROXY_TEXTURE_2D}, {@link GL_PROXY_TEXTURE_3D}, {@link GL_TEXTURE_CUBE_MAP_POSITIVE_X}, {@link GL_TEXTURE_CUBE_MAP_NEGATIVE_X}, {@link GL_TEXTURE_CUBE_MAP_POSITIVE_Y}, {@link GL_TEXTURE_CUBE_MAP_NEGATIVE_Y}, {@link GL_TEXTURE_CUBE_MAP_POSITIVE_Z}, {@link GL_TEXTURE_CUBE_MAP_NEGATIVE_Z}, or {@link GL_PROXY_TEXTURE_CUBE_MAP}.
 *
 * {@link GL_MAX_TEXTURE_SIZE}, and {@link GL_MAX_3D_TEXTURE_SIZE} are not really descriptive enough. It has to report the largest square texture image that can be accommodated with mipmaps but a long skinny texture, or a texture without mipmaps may easily fit in texture memory. The proxy targets allow the user to more accurately query whether the GL can accommodate a texture of a given configuration. If the texture cannot be accommodated, the texture state variables, which may be queried with `glGetTexLevelParameter`, are set to 0. If the texture can be accommodated, the texture state values will be set as they would be set for a non-proxy target.
 *
 * **pname** specifies the texture parameter whose value or values will be returned.
 *
 * The accepted parameter names are as follows:
 *
 * - {@link GL_TEXTURE_WIDTH}
 * **params** returns a single value, the width of the texture image. The initial value is 0.
 *
 * - {@link GL_TEXTURE_HEIGHT}
 * **params** returns a single value, the height of the texture image. The initial value is 0.
 *
 * - {@link GL_TEXTURE_DEPTH}
 * **params** returns a single value, the depth of the texture image. The initial value is 0.
 *
 * - {@link GL_TEXTURE_INTERNAL_FORMAT}
 * **params** returns a single value, the internal format of the texture image.
 *
 * - {@link GL_TEXTURE_RED_TYPE}, {@link GL_TEXTURE_GREEN_TYPE}, {@link GL_TEXTURE_BLUE_TYPE}, {@link GL_TEXTURE_ALPHA_TYPE}, {@link GL_TEXTURE_DEPTH_TYPE}
 * The data type used to store the component. The types {@link GL_NONE}, {@link GL_SIGNED_NORMALIZED}, {@link GL_UNSIGNED_NORMALIZED}, {@link GL_FLOAT}, {@link GL_INT}, and {@link GL_UNSIGNED_INT} may be returned to indicate signed normalized fixed-point, unsigned normalized fixed-point, floating-point, integer unnormalized, and unsigned integer unnormalized components, respectively.
 *
 * - {@link GL_TEXTURE_RED_SIZE}, {@link GL_TEXTURE_GREEN_SIZE}, {@link GL_TEXTURE_BLUE_SIZE}, {@link GL_TEXTURE_ALPHA_SIZE}, {@link GL_TEXTURE_DEPTH_SIZE}
 * The internal storage resolution of an individual component. The resolution chosen by the GL will be a close match for the resolution requested by the user with the component argument of {@link glTexImage1D}, {@link glTexImage2D}, {@link glTexImage3D}, {@link glCopyTexImage1D}, and {@link glCopyTexImage2D}. The initial value is 0.
 *
 * - {@link GL_TEXTURE_COMPRESSED}
 * **params** returns a single boolean value indicating if the texture image is stored in a compressed internal format. The initiali value is {@link GL_FALSE}.
 *
 * - {@link GL_TEXTURE_COMPRESSED_IMAGE_SIZE}
 * **params** returns a single integer value, the number of unsigned bytes of the compressed texture image that would be returned from {@link glGetCompressedTexImage}.
 *
 * @summary return texture parameter values for a specific level of detail
 * @param target Specifies the symbolic name of the target texture, one of {@link GL_TEXTURE_1D}, {@link GL_TEXTURE_2D}, {@link GL_TEXTURE_3D}, {@link GL_TEXTURE_1D_ARRAY}, {@link GL_TEXTURE_2D_ARRAY}, {@link GL_TEXTURE_RECTANGLE}, {@link GL_TEXTURE_2D_MULTISAMPLE}, {@link GL_TEXTURE_2D_MULTISAMPLE_ARRAY}, {@link GL_TEXTURE_CUBE_MAP_POSITIVE_X}, {@link GL_TEXTURE_CUBE_MAP_NEGATIVE_X}, {@link GL_TEXTURE_CUBE_MAP_POSITIVE_Y}, {@link GL_TEXTURE_CUBE_MAP_NEGATIVE_Y}, {@link GL_TEXTURE_CUBE_MAP_POSITIVE_Z}, {@link GL_TEXTURE_CUBE_MAP_NEGATIVE_Z}, {@link GL_PROXY_TEXTURE_1D}, {@link GL_PROXY_TEXTURE_2D}, {@link GL_PROXY_TEXTURE_3D}, {@link GL_PROXY_TEXTURE_1D_ARRAY}, {@link GL_PROXY_TEXTURE_2D_ARRAY}, {@link GL_PROXY_TEXTURE_RECTANGLE}, {@link GL_PROXY_TEXTURE_2D_MULTISAMPLE}, {@link GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY}, {@link GL_PROXY_TEXTURE_CUBE_MAP}, or {@link GL_TEXTURE_BUFFER}.
 * @param level Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level 𝐧 is the 𝐧ᵗʰ mipmap reduction image.
 * @param pname Specifies the symbolic name of a texture parameter. {@link GL_TEXTURE_WIDTH}, {@link GL_TEXTURE_HEIGHT}, {@link GL_TEXTURE_DEPTH}, {@link GL_TEXTURE_INTERNAL_FORMAT}, {@link GL_TEXTURE_RED_SIZE}, {@link GL_TEXTURE_GREEN_SIZE}, {@link GL_TEXTURE_BLUE_SIZE}, {@link GL_TEXTURE_ALPHA_SIZE}, {@link GL_TEXTURE_DEPTH_SIZE}, {@link GL_TEXTURE_COMPRESSED}, and {@link GL_TEXTURE_COMPRESSED_IMAGE_SIZE} are accepted.
 * @param params Returns the requested data.
 * @tutorial [Sébastien Dominé - Using Texture Compression in OpenGL](https://www.oldunreal.com/editing/s3tc/ARB_texture_compression.pdf)
 * @see [glGetTexLevelParameter](https://docs.gl/gl3/glGetTexLevelParameter)
 */
export function glGetTexLevelParameteriv(
	target: GLenum,
	level: GLint,
	pname: GLenum,
	params: GLint
): void;

/**
 * `glGetTexParameter` returns in **params** the value or values of the texture parameter specified as **pname**. **target** defines the target texture. {@link GL_TEXTURE_1D}, {@link GL_TEXTURE_2D}, {@link GL_TEXTURE_3D}, {@link GL_TEXTURE_1D_ARRAY}, {@link GL_TEXTURE_2D_ARRAY}, {@link GL_TEXTURE_RECTANGLE}, and {@link GL_TEXTURE_CUBE_MAP} specify one-, two-, or three-dimensional, one-dimensional array, two-dimensional array, rectangle or cube-mapped texturing, respectively. **pname** accepts the same symbols as {@link glTexParameter}, with the same interpretations:
 *
 * - {@link GL_TEXTURE_MAG_FILTER}
 * Returns the single-valued texture magnification filter, a symbolic constant. The initial value is {@link GL_LINEAR}.
 *
 * - {@link GL_TEXTURE_MIN_FILTER}
 * Returns the single-valued texture minification filter, a symbolic constant. The initial value is {@link GL_NEAREST_MIPMAP_LINEAR}.
 *
 * - {@link GL_TEXTURE_MIN_LOD}
 * Returns the single-valued texture minimum level-of-detail value. The initial value is −1000.
 *
 * - {@link GL_TEXTURE_MAX_LOD}
 * Returns the single-valued texture maximum level-of-detail value. The initial value is 1000.
 *
 * - {@link GL_TEXTURE_BASE_LEVEL}
 * Returns the single-valued base texture mipmap level. The initial value is 0.
 *
 * - {@link GL_TEXTURE_MAX_LEVEL}
 * Returns the single-valued maximum texture mipmap array level. The initial value is 1000.
 *
 * - {@link GL_TEXTURE_SWIZZLE_R}
 * Returns the red component swizzle. The initial value is {@link GL_RED}.
 *
 * - {@link GL_TEXTURE_SWIZZLE_G}
 * Returns the green component swizzle. The initial value is {@link GL_GREEN}.
 *
 * - {@link GL_TEXTURE_SWIZZLE_B}
 * Returns the blue component swizzle. The initial value is {@link GL_BLUE}.
 *
 * - {@link GL_TEXTURE_SWIZZLE_A}
 * Returns the alpha component swizzle. The initial value is {@link GL_ALPHA}.
 *
 * - {@link GL_TEXTURE_SWIZZLE_RGBA}
 * Returns the component swizzle for all channels in a single query.
 *
 * - {@link GL_TEXTURE_WRAP_S}
 * Returns the single-valued wrapping function for texture coordinate 𝐬, a symbolic constant. The initial value is {@link GL_REPEAT}.
 *
 * - {@link GL_TEXTURE_WRAP_T}
 * Returns the single-valued wrapping function for texture coordinate 𝐭, a symbolic constant. The initial value is {@link GL_REPEAT}.
 *
 * - {@link GL_TEXTURE_WRAP_R}
 * Returns the single-valued wrapping function for texture coordinate 𝐫, a symbolic constant. The initial value is {@link GL_REPEAT}.
 *
 * - {@link GL_TEXTURE_BORDER_COLOR}
 * Returns four integer or floating-point numbers that comprise the RGBA color of the texture border. Floating-point values are returned in the range [0,1]. Integer values are returned as a linear mapping of the internal floating-point representation such that 1.0 maps to the most positive representable integer and −1.0 maps to the most negative representable integer. The initial value is (0, 0, 0, 0).
 *
 * - {@link GL_TEXTURE_COMPARE_MODE}
 * Returns a single-valued texture comparison mode, a symbolic constant. The initial value is {@link GL_NONE}. See {@link glTexParameter}.
 *
 * - {@link GL_TEXTURE_COMPARE_FUNC}
 * Returns a single-valued texture comparison function, a symbolic constant. The initial value is {@link GL_LEQUAL}. See {@link glTexParameter}.
 *
 * @summary return texture parameter values
 * @param target Specifies the symbolic name of the target texture. {@link GL_TEXTURE_1D}, {@link GL_TEXTURE_2D}, {@link GL_TEXTURE_1D_ARRAY}, {@link GL_TEXTURE_2D_ARRAY}, {@link GL_TEXTURE_3D}, {@link GL_TEXTURE_RECTANGLE}, and {@link GL_TEXTURE_CUBE_MAP} are accepted.
 * @param pname Specifies the symbolic name of a texture parameter. {@link GL_TEXTURE_BASE_LEVEL}, {@link GL_TEXTURE_BORDER_COLOR}, {@link GL_TEXTURE_COMPARE_MODE}, {@link GL_TEXTURE_COMPARE_FUNC}, {@link GL_TEXTURE_LOD_BIAS}, {@link GL_TEXTURE_MAG_FILTER}, {@link GL_TEXTURE_MAX_LEVEL}, {@link GL_TEXTURE_MAX_LOD}, {@link GL_TEXTURE_MIN_FILTER}, {@link GL_TEXTURE_MIN_LOD}, {@link GL_TEXTURE_SWIZZLE_R}, {@link GL_TEXTURE_SWIZZLE_G}, {@link GL_TEXTURE_SWIZZLE_B}, {@link GL_TEXTURE_SWIZZLE_A}, {@link GL_TEXTURE_SWIZZLE_RGBA}, {@link GL_TEXTURE_WRAP_S}, {@link GL_TEXTURE_WRAP_T}, and {@link GL_TEXTURE_WRAP_R} are accepted.
 * @param params Returns the texture parameters.
 * @see [glGetTexParameter](https://docs.gl/gl3/glGetTexParameter)
 */
export function glGetTexParameterfv(
	target: GLenum,
	pname: GLenum,
	params: GLfloat
): void;

/**
 * `glGetTexParameter` returns in **params** the value or values of the texture parameter specified as **pname**. **target** defines the target texture. {@link GL_TEXTURE_1D}, {@link GL_TEXTURE_2D}, {@link GL_TEXTURE_3D}, {@link GL_TEXTURE_1D_ARRAY}, {@link GL_TEXTURE_2D_ARRAY}, {@link GL_TEXTURE_RECTANGLE}, and {@link GL_TEXTURE_CUBE_MAP} specify one-, two-, or three-dimensional, one-dimensional array, two-dimensional array, rectangle or cube-mapped texturing, respectively. **pname** accepts the same symbols as {@link glTexParameter}, with the same interpretations:
 *
 * - {@link GL_TEXTURE_MAG_FILTER}
 * Returns the single-valued texture magnification filter, a symbolic constant. The initial value is {@link GL_LINEAR}.
 *
 * - {@link GL_TEXTURE_MIN_FILTER}
 * Returns the single-valued texture minification filter, a symbolic constant. The initial value is {@link GL_NEAREST_MIPMAP_LINEAR}.
 *
 * - {@link GL_TEXTURE_MIN_LOD}
 * Returns the single-valued texture minimum level-of-detail value. The initial value is −1000.
 *
 * - {@link GL_TEXTURE_MAX_LOD}
 * Returns the single-valued texture maximum level-of-detail value. The initial value is 1000.
 *
 * - {@link GL_TEXTURE_BASE_LEVEL}
 * Returns the single-valued base texture mipmap level. The initial value is 0.
 *
 * - {@link GL_TEXTURE_MAX_LEVEL}
 * Returns the single-valued maximum texture mipmap array level. The initial value is 1000.
 *
 * - {@link GL_TEXTURE_SWIZZLE_R}
 * Returns the red component swizzle. The initial value is {@link GL_RED}.
 *
 * - {@link GL_TEXTURE_SWIZZLE_G}
 * Returns the green component swizzle. The initial value is {@link GL_GREEN}.
 *
 * - {@link GL_TEXTURE_SWIZZLE_B}
 * Returns the blue component swizzle. The initial value is {@link GL_BLUE}.
 *
 * - {@link GL_TEXTURE_SWIZZLE_A}
 * Returns the alpha component swizzle. The initial value is {@link GL_ALPHA}.
 *
 * - {@link GL_TEXTURE_SWIZZLE_RGBA}
 * Returns the component swizzle for all channels in a single query.
 *
 * - {@link GL_TEXTURE_WRAP_S}
 * Returns the single-valued wrapping function for texture coordinate 𝐬, a symbolic constant. The initial value is {@link GL_REPEAT}.
 *
 * - {@link GL_TEXTURE_WRAP_T}
 * Returns the single-valued wrapping function for texture coordinate 𝐭, a symbolic constant. The initial value is {@link GL_REPEAT}.
 *
 * - {@link GL_TEXTURE_WRAP_R}
 * Returns the single-valued wrapping function for texture coordinate 𝐫, a symbolic constant. The initial value is {@link GL_REPEAT}.
 *
 * - {@link GL_TEXTURE_BORDER_COLOR}
 * Returns four integer or floating-point numbers that comprise the RGBA color of the texture border. Floating-point values are returned in the range [0,1]. Integer values are returned as a linear mapping of the internal floating-point representation such that 1.0 maps to the most positive representable integer and −1.0 maps to the most negative representable integer. The initial value is (0, 0, 0, 0).
 *
 * - {@link GL_TEXTURE_COMPARE_MODE}
 * Returns a single-valued texture comparison mode, a symbolic constant. The initial value is {@link GL_NONE}. See {@link glTexParameter}.
 *
 * - {@link GL_TEXTURE_COMPARE_FUNC}
 * Returns a single-valued texture comparison function, a symbolic constant. The initial value is {@link GL_LEQUAL}. See {@link glTexParameter}.
 *
 * @summary return texture parameter values
 * @param target Specifies the symbolic name of the target texture. {@link GL_TEXTURE_1D}, {@link GL_TEXTURE_2D}, {@link GL_TEXTURE_1D_ARRAY}, {@link GL_TEXTURE_2D_ARRAY}, {@link GL_TEXTURE_3D}, {@link GL_TEXTURE_RECTANGLE}, and {@link GL_TEXTURE_CUBE_MAP} are accepted.
 * @param pname Specifies the symbolic name of a texture parameter. {@link GL_TEXTURE_BASE_LEVEL}, {@link GL_TEXTURE_BORDER_COLOR}, {@link GL_TEXTURE_COMPARE_MODE}, {@link GL_TEXTURE_COMPARE_FUNC}, {@link GL_TEXTURE_LOD_BIAS}, {@link GL_TEXTURE_MAG_FILTER}, {@link GL_TEXTURE_MAX_LEVEL}, {@link GL_TEXTURE_MAX_LOD}, {@link GL_TEXTURE_MIN_FILTER}, {@link GL_TEXTURE_MIN_LOD}, {@link GL_TEXTURE_SWIZZLE_R}, {@link GL_TEXTURE_SWIZZLE_G}, {@link GL_TEXTURE_SWIZZLE_B}, {@link GL_TEXTURE_SWIZZLE_A}, {@link GL_TEXTURE_SWIZZLE_RGBA}, {@link GL_TEXTURE_WRAP_S}, {@link GL_TEXTURE_WRAP_T}, and {@link GL_TEXTURE_WRAP_R} are accepted.
 * @param params Returns the texture parameters.
 * @see [glGetTexParameter](https://docs.gl/gl3/glGetTexParameter)
 */
export function glGetTexParameteriv(
	target: GLenum,
	pname: GLenum,
	params: GLint
): void;

/**
 * Certain aspects of GL behavior, when there is room for interpretation, can be controlled with hints. A hint is specified with two arguments. **target** is a symbolic constant indicating the behavior to be controlled, and **mode** is another symbolic constant indicating the desired behavior. The initial value for each **target** is {@link GL_DONT_CARE}. **mode** can be one of the following:
 *
 * - {@link GL_FASTEST}
 * The most efficient option should be chosen.
 *
 * - {@link GL_NICEST}
 * The most correct, or highest quality, option should be chosen.
 *
 * - {@link GL_DONT_CARE}
 * No preference.
 *
 * Though the implementation aspects that can be hinted are well defined, the interpretation of the hints depends on the implementation. The hint aspects that can be specified with **target**, along with suggested semantics, are as follows:
 *
 * - {@link GL_FRAGMENT_SHADER_DERIVATIVE_HINT}
 * Indicates the accuracy of the derivative calculation for the GL shading language fragment processing built-in functions: {@link dFdx}, {@link dFdy}, and {@link fwidth}.
 *
 * - {@link GL_LINE_SMOOTH_HINT}
 * Indicates the sampling quality of antialiased lines. If a larger filter function is applied, hinting {@link GL_NICEST} can result in more pixel fragments being generated during rasterization.
 *
 * - {@link GL_POLYGON_SMOOTH_HINT}
 * Indicates the sampling quality of antialiased polygons. Hinting {@link GL_NICEST} can result in more pixel fragments being generated during rasterization, if a larger filter function is applied.
 *
 * - {@link GL_TEXTURE_COMPRESSION_HINT}
 * Indicates the quality and performance of the compressing texture images. Hinting {@link GL_FASTEST} indicates that texture images should be compressed as quickly as possible, while {@link GL_NICEST} indicates that texture images should be compressed with as little image quality loss as possible. {@link GL_NICEST} should be selected if the texture is to be retrieved by {@link glGetCompressedTexImage} for reuse.
 *
 * @summary specify implementation-specific hints
 * @param target Specifies a symbolic constant indicating the behavior to be controlled. {@link GL_LINE_SMOOTH_HINT}, {@link GL_POLYGON_SMOOTH_HINT}, {@link GL_TEXTURE_COMPRESSION_HINT}, and {@link GL_FRAGMENT_SHADER_DERIVATIVE_HINT} are accepted.
 * @param mode Specifies a symbolic constant indicating the desired behavior. {@link GL_FASTEST}, {@link GL_NICEST}, and {@link GL_DONT_CARE} are accepted.
 * @see [glHint](https://docs.gl/gl3/glHint)
 */
export function glHint(target: GLenum, mode: GLenum): void;

/**
 * `glIndex` updates the current (single-valued) color index. It takes one argument, the new value for the current color index.
 *
 * The current index is stored as a floating-point value. Integer values are converted directly to floating-point values, with no special mapping. The initial value is 1.
 *
 * Index values outside the representable range of the color index buffer are not clamped. However, before an index is dithered (if enabled) and written to the frame buffer, it is converted to fixed-point format. Any bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the frame buffer are masked out.
 *
 * @summary set the current color index
 * @param c Specifies the new value for the current color index.
 * @see [glIndex](https://docs.gl/gl3/glIndex)
 */
export function glIndexd(c: GLdouble): void;

/**
 * `glIndex` updates the current (single-valued) color index. It takes one argument, the new value for the current color index.
 *
 * The current index is stored as a floating-point value. Integer values are converted directly to floating-point values, with no special mapping. The initial value is 1.
 *
 * Index values outside the representable range of the color index buffer are not clamped. However, before an index is dithered (if enabled) and written to the frame buffer, it is converted to fixed-point format. Any bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the frame buffer are masked out.
 *
 * @summary set the current color index
 * @param c Specifies the new value for the current color index.
 * @see [glIndex](https://docs.gl/gl3/glIndex)
 */
export function glIndexf(c: GLfloat): void;

/**
 * `glIndex` updates the current (single-valued) color index. It takes one argument, the new value for the current color index.
 *
 * The current index is stored as a floating-point value. Integer values are converted directly to floating-point values, with no special mapping. The initial value is 1.
 *
 * Index values outside the representable range of the color index buffer are not clamped. However, before an index is dithered (if enabled) and written to the frame buffer, it is converted to fixed-point format. Any bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the frame buffer are masked out.
 *
 * @summary set the current color index
 * @param c Specifies the new value for the current color index.
 * @see [glIndex](https://docs.gl/gl3/glIndex)
 */
export function glIndexi(c: GLint): void;

/**
 * `glIndex` updates the current (single-valued) color index. It takes one argument, the new value for the current color index.
 *
 * The current index is stored as a floating-point value. Integer values are converted directly to floating-point values, with no special mapping. The initial value is 1.
 *
 * Index values outside the representable range of the color index buffer are not clamped. However, before an index is dithered (if enabled) and written to the frame buffer, it is converted to fixed-point format. Any bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the frame buffer are masked out.
 *
 * @summary set the current color index
 * @param c Specifies the new value for the current color index.
 * @see [glIndex](https://docs.gl/gl3/glIndex)
 */
export function glIndexs(c: GLshort): void;

/**
 * `glIndex` updates the current (single-valued) color index. It takes one argument, the new value for the current color index.
 *
 * The current index is stored as a floating-point value. Integer values are converted directly to floating-point values, with no special mapping. The initial value is 1.
 *
 * Index values outside the representable range of the color index buffer are not clamped. However, before an index is dithered (if enabled) and written to the frame buffer, it is converted to fixed-point format. Any bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the frame buffer are masked out.
 *
 * @summary set the current color index
 * @param c Specifies the new value for the current color index.
 * @see [glIndex](https://docs.gl/gl3/glIndex)
 */
export function glIndexub(c: GLubyte): void;

/**
 * `glIndex` updates the current (single-valued) color index. It takes one argument, the new value for the current color index.
 *
 * The current index is stored as a floating-point value. Integer values are converted directly to floating-point values, with no special mapping. The initial value is 1.
 *
 * Index values outside the representable range of the color index buffer are not clamped. However, before an index is dithered (if enabled) and written to the frame buffer, it is converted to fixed-point format. Any bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the frame buffer are masked out.
 *
 * @summary set the current color index
 * @param c Specifies a pointer to a one-element array that contains the new value for the current color index.
 * @see [glIndex](https://docs.gl/gl3/glIndex)
 */
export function glIndexdv(c: GLdouble): void;

/**
 * `glIndex` updates the current (single-valued) color index. It takes one argument, the new value for the current color index.
 *
 * The current index is stored as a floating-point value. Integer values are converted directly to floating-point values, with no special mapping. The initial value is 1.
 *
 * Index values outside the representable range of the color index buffer are not clamped. However, before an index is dithered (if enabled) and written to the frame buffer, it is converted to fixed-point format. Any bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the frame buffer are masked out.
 *
 * @summary set the current color index
 * @param c Specifies a pointer to a one-element array that contains the new value for the current color index.
 * @see [glIndex](https://docs.gl/gl3/glIndex)
 */
export function glIndexfv(c: GLfloat): void;

/**
 * `glIndex` updates the current (single-valued) color index. It takes one argument, the new value for the current color index.
 *
 * The current index is stored as a floating-point value. Integer values are converted directly to floating-point values, with no special mapping. The initial value is 1.
 *
 * Index values outside the representable range of the color index buffer are not clamped. However, before an index is dithered (if enabled) and written to the frame buffer, it is converted to fixed-point format. Any bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the frame buffer are masked out.
 *
 * @summary set the current color index
 * @param c Specifies a pointer to a one-element array that contains the new value for the current color index.
 * @see [glIndex](https://docs.gl/gl3/glIndex)
 */
export function glIndexiv(c: GLint): void;

/**
 * `glIndex` updates the current (single-valued) color index. It takes one argument, the new value for the current color index.
 *
 * The current index is stored as a floating-point value. Integer values are converted directly to floating-point values, with no special mapping. The initial value is 1.
 *
 * Index values outside the representable range of the color index buffer are not clamped. However, before an index is dithered (if enabled) and written to the frame buffer, it is converted to fixed-point format. Any bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the frame buffer are masked out.
 *
 * @summary set the current color index
 * @param c Specifies a pointer to a one-element array that contains the new value for the current color index.
 * @see [glIndex](https://docs.gl/gl3/glIndex)
 */
export function glIndexsv(c: GLshort): void;

/**
 * `glIndex` updates the current (single-valued) color index. It takes one argument, the new value for the current color index.
 *
 * The current index is stored as a floating-point value. Integer values are converted directly to floating-point values, with no special mapping. The initial value is 1.
 *
 * Index values outside the representable range of the color index buffer are not clamped. However, before an index is dithered (if enabled) and written to the frame buffer, it is converted to fixed-point format. Any bits in the integer portion of the resulting fixed-point value that do not correspond to bits in the frame buffer are masked out.
 *
 * @summary set the current color index
 * @param c Specifies a pointer to a one-element array that contains the new value for the current color index.
 * @see [glIndex](https://docs.gl/gl3/glIndex)
 */
export function glIndexubv(c: GLubyte): void;

/**
 * `glIndexMask` controls the writing of individual bits in the color index buffers. The least significant 𝐧 bits of **mask**, where 𝐧 is the number of bits in a color index buffer, specify a mask. Where a 1 (one) appears in the mask, it's possible to write to the corresponding bit in the color index buffer (or buffers). Where a 0 (zero) appears, the corresponding bit is write-protected.
 *
 * This mask is used only in color index mode, and it affects only the buffers currently selected for writing (see {@link glDrawBuffer}). Initially, all bits are enabled for writing.
 *
 * @summary control the writing of individual bits in the color index buffers
 * @param mask Specifies a bit mask to enable and disable the writing of individual bits in the color index buffers. Initially, the mask is all 1's.
 * @see [glIndexMask](https://docs.gl/gl3/glIndexMask)
 */
export function glIndexMask(mask: GLuint): void;

/**
 * `glIndexPointer` specifies the location and data format of an array of color indexes to use when rendering. **type** specifies the data type of each color index and **stride** specifies the byte stride from one color index to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays.
 *
 * If a non-zero named buffer object is bound to the {@link GL_ARRAY_BUFFER} target (see {@link glBindBuffer}) while a color index array is specified, **pointer** is treated as a byte offset into the buffer object's data store. Also, the buffer object binding ({@link GL_ARRAY_BUFFER_BINDING}) is saved as color index vertex array client-side state ({@link GL_INDEX_ARRAY_BUFFER_BINDING}).
 *
 * When a color index array is specified, **type**, **stride**, and **pointer** are saved as client-side state, in addition to the current vertex array buffer object binding.
 *
 * To enable and disable the color index array, call {@link glEnableClientState} and {@link glDisableClientState} with the argument {@link GL_INDEX_ARRAY}. If enabled, the color index array is used when {@link glDrawArrays}, {@link glMultiDrawArrays}, {@link glDrawElements}, {@link glMultiDrawElements}, {@link glDrawRangeElements}, or {@link glArrayElement} is called.
 *
 * @summary define an array of color indexes
 * @param type Specifies the data type of each color index in the array. Symbolic constants {@link GL_UNSIGNED_BYTE}, {@link GL_SHORT}, {@link GL_INT}, {@link GL_FLOAT}, and {@link GL_DOUBLE} are accepted. The initial value is {@link GL_FLOAT}.
 * @param stride Specifies the byte offset between consecutive color indexes. If **stride** is 0, the color indexes are understood to be tightly packed in the array. The initial value is 0.
 * @param pointer Specifies a pointer to the first index in the array. The initial value is 0.
 * @see [glIndexPointer](https://docs.gl/gl3/glIndexPointer)
 */
export function glIndexPointer(
	type: GLenum,
	stride: GLsizei,
	pointer: GLvoid
): void;

/**
 * The name stack is used during selection mode to allow sets of rendering commands to be uniquely identified. It consists of an ordered set of unsigned integers. `glInitNames` causes the name stack to be initialized to its default empty state.
 *
 * The name stack is always empty while the render mode is not {@link GL_SELECT}. Calls to `glInitNames` while the render mode is not {@link GL_SELECT} are ignored.
 *
 * @summary initialize the name stack
 * @see [glInitNames](https://docs.gl/gl3/glInitNames)
 */
export function glInitNames(): void;

/**
 * `glInterleavedArrays` lets you specify and enable individual color, normal, texture and vertex arrays whose elements are part of a larger aggregate array element. For some implementations, this is more efficient than specifying the arrays separately.
 *
 * If **stride** is 0, the aggregate elements are stored consecutively. Otherwise, **stride** bytes occur between the beginning of one aggregate array element and the beginning of the next aggregate array element.
 *
 * **format** serves as a ``key'' describing the extraction of individual arrays from the aggregate array. If **format** contains a T, then texture coordinates are extracted from the interleaved array. If C is present, color values are extracted. If N is present, normal coordinates are extracted. Vertex coordinates are always extracted.
 *
 * The digits 2, 3, and 4 denote how many values are extracted. F indicates that values are extracted as floating-point values. Colors may also be extracted as 4 unsigned bytes if 4UB follows the C. If a color is extracted as 4 unsigned bytes, the vertex array element which follows is located at the first possible floating-point aligned address.
 *
 * @summary simultaneously specify and enable several interleaved arrays
 * @param format Specifies the type of array to enable. Symbolic constants {@link GL_V2F}, {@link GL_V3F}, {@link GL_C4UB_V2F}, {@link GL_C4UB_V3F}, {@link GL_C3F_V3F}, {@link GL_N3F_V3F}, {@link GL_C4F_N3F_V3F}, {@link GL_T2F_V3F}, {@link GL_T4F_V4F}, {@link GL_T2F_C4UB_V3F}, {@link GL_T2F_C3F_V3F}, {@link GL_T2F_N3F_V3F}, {@link GL_T2F_C4F_N3F_V3F}, and {@link GL_T4F_C4F_N3F_V4F} are accepted.
 * @param stride Specifies the offset in bytes between each aggregate array element.
 * @see [glInterleavedArrays](https://docs.gl/gl3/glInterleavedArrays)
 */
export function glInterleavedArrays(
	format: GLenum,
	stride: GLsizei,
	pointer: GLvoid
): void;

/**
 * `glIsEnabled` returns {@link GL_TRUE} if **cap** is an enabled capability and returns {@link GL_FALSE} otherwise. Boolean states that are indexed may be tested with `glIsEnabledi`. For `glIsEnabledi`, **index** specifies the index of the capability to test. **index** must be between zero and the count of indexed capabilities for **cap**. Initially all capabilities except {@link GL_DITHER} are disabled; {@link GL_DITHER} is initially enabled.
 *
 * The following capabilities are accepted for **cap**:
 *
 * | **Constant**                         | **See**                                           |
 * | :----------------------------------- | :------------------------------------------------ |
 * | {@link GL_BLEND}                     | {@link glBlendFunc}, {@link glLogicOp}            |
 * | {@link GL_CLIP_DISTANCE} **i**       | {@link glEnable}                                  |
 * | {@link GL_COLOR_LOGIC_OP}            | {@link glLogicOp}                                 |
 * | {@link GL_CULL_FACE}                 | {@link glCullFace}                                |
 * | {@link GL_DEPTH_CLAMP}               | {@link glEnable}                                  |
 * | {@link GL_DEPTH_TEST}                | {@link glDepthFunc}, {@link glDepthRange}         |
 * | {@link GL_DITHER}                    | {@link glEnable}                                  |
 * | {@link GL_FRAMEBUFFER_SRGB}          | {@link glEnable}                                  |
 * | {@link GL_LINE_SMOOTH}               | {@link glLineWidth}                               |
 * | {@link GL_MULTISAMPLE}               | {@link glSampleCoverage}                          |
 * | {@link GL_POLYGON_SMOOTH}            | {@link glPolygonMode}                             |
 * | {@link GL_POLYGON_OFFSET_FILL}       | {@link glPolygonOffset}                           |
 * | {@link GL_POLYGON_OFFSET_LINE}       | {@link glPolygonOffset}                           |
 * | {@link GL_POLYGON_OFFSET_POINT}      | {@link glPolygonOffset}                           |
 * | {@link GL_PROGRAM_POINT_SIZE}        | {@link glEnable}                                  |
 * | {@link GL_PRIMITIVE_RESTART}         | {@link glEnable}, {@link glPrimitiveRestartIndex} |
 * | {@link GL_SAMPLE_ALPHA_TO_COVERAGE}  | {@link glSampleCoverage}                          |
 * | {@link GL_SAMPLE_ALPHA_TO_ONE}       | {@link glSampleCoverage}                          |
 * | {@link GL_SAMPLE_COVERAGE}           | {@link glSampleCoverage}                          |
 * | {@link GL_SAMPLE_MASK}               | {@link glEnable}                                  |
 * | {@link GL_SCISSOR_TEST}              | {@link glScissor}                                 |
 * | {@link GL_STENCIL_TEST}              | {@link glStencilFunc}, {@link glStencilOp}        |
 * | {@link GL_TEXTURE_CUBE_MAP_SEAMLESS} | {@link glEnable}                                  |
 *
 * @summary test whether a capability is enabled
 * @param cap Specifies a symbolic constant indicating a GL capability.
 * @param index Specifies the index of the capability.
 * @tutorial [Songho - OpenGL Display List](https://www.songho.ca/opengl/gl_displaylist.html)
 * @tutorial [Songho - OpenGL Rendering Pipeline](https://www.songho.ca/opengl/gl_pipeline.html)
 * @see [glIsEnabled](https://docs.gl/gl3/glIsEnabled)
 */
export function glIsEnabled(cap: GLenum, index?: GLuint): GLboolean;

/**
 * `glIsList` returns {@link GL_TRUE} if **list** is the name of a display list and returns {@link GL_FALSE} if it is not, or if an error occurs.
 *
 * A name returned by {@link glGenLists}, but not yet associated with a display list by calling {@link glNewList}, is not the name of a display list.
 *
 * @summary determine if a name corresponds to a display list
 * @param list Specifies a potential display list name.
 * @see [glIsList](https://docs.gl/gl3/glIsList)
 */
export function glIsList(list: GLuint): GLboolean;

/**
 * `glIsTexture` returns {@link GL_TRUE} if **texture** is currently the name of a texture. If **texture** is zero, or is a non-zero value that is not currently the name of a texture, or if an error occurs, `glIsTexture` returns {@link GL_FALSE}.
 *
 * A name returned by {@link glGenTextures}, but not yet associated with a texture by calling {@link glBindTexture}, is not the name of a texture.
 *
 * @summary determine if a name corresponds to a texture
 * @param texture Specifies a value that may be the name of a texture.
 * @see [glIsTexture](https://docs.gl/gl3/glIsTexture)
 */
export function glIsTexture(texture: GLuint): GLboolean;

/**
 * `glLight` sets the values of individual light source parameters. **light** names the light and is a symbolic name of the form {@link GL_LIGHT} 𝐢, where i ranges from 0 to the value of {@link GL_MAX_LIGHTS} - 1. **pname** specifies one of ten light source parameters, again by symbolic name. **params** is either a single value or a pointer to an array that contains the new values.
 *
 * To enable and disable lighting calculation, call {@link glEnable} and {@link glDisable} with argument {@link GL_LIGHTING}. Lighting is initially disabled. When it is enabled, light sources that are enabled contribute to the lighting calculation. Light source 𝐢 is enabled and disabled using {@link glEnable} and {@link glDisable} with argument {@link GL_LIGHT} 𝐢.
 *
 * The ten light parameters are as follows:
 *
 * - {@link GL_AMBIENT}
 * **params** contains four integer or floating-point values that specify the ambient RGBA intensity of the light. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial ambient light intensity is (0, 0, 0, 1).
 *
 * - {@link GL_DIFFUSE}
 * **params** contains four integer or floating-point values that specify the diffuse RGBA intensity of the light. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial value for {@link GL_LIGHT0} is (1, 1, 1, 1); for other lights, the initial value is (0, 0, 0, 1).
 *
 * - {@link GL_SPECULAR}
 * **params** contains four integer or floating-point values that specify the specular RGBA intensity of the light. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial value for {@link GL_LIGHT0} is (1, 1, 1, 1); for other lights, the initial value is (0, 0, 0, 1).
 *
 * - {@link GL_POSITION}
 * **params** contains four integer or floating-point values that specify the position of the light in homogeneous object coordinates. Both integer and floating-point values are mapped directly. Neither integer nor floating-point values are clamped.
 * The position is transformed by the modelview matrix when `glLight` is called (just as if it were a point), and it is stored in eye coordinates. If the 𝐰 component of the position is 0, the light is treated as a directional source. Diffuse and specular lighting calculations take the light's direction, but not its actual position, into account, and attenuation is disabled. Otherwise, diffuse and specular lighting calculations are based on the actual location of the light in eye coordinates, and attenuation is enabled. The initial position is (0, 0, 1, 0); thus, the initial light source is directional, parallel to, and in the direction of the −𝐳 axis.
 *
 * - {@link GL_SPOT_DIRECTION}
 * **params** contains three integer or floating-point values that specify the direction of the light in homogeneous object coordinates. Both integer and floating-point values are mapped directly. Neither integer nor floating-point values are clamped.
 * The spot direction is transformed by the upper 3x3 of the modelview matrix when `glLight` is called, and it is stored in eye coordinates. It is significant only when {@link GL_SPOT_CUTOFF} is not 180, which it is initially. The initial direction is (0,0,−1).
 *
 * - {@link GL_SPOT_EXPONENT}
 * **params** is a single integer or floating-point value that specifies the intensity distribution of the light. Integer and floating-point values are mapped directly. Only values in the range [0,128] are accepted.
 * Effective light intensity is attenuated by the cosine of the angle between the direction of the light and the direction from the light to the vertex being lighted, raised to the power of the spot exponent. Thus, higher spot exponents result in a more focused light source, regardless of the spot cutoff angle (see {@link GL_SPOT_CUTOFF}, next paragraph). The initial spot exponent is 0, resulting in uniform light distribution.
 *
 * - {@link GL_SPOT_CUTOFF}
 * **params** is a single integer or floating-point value that specifies the maximum spread angle of a light source. Integer and floating-point values are mapped directly. Only values in the range [0,90] and the special value 180 are accepted. If the angle between the direction of the light and the direction from the light to the vertex being lighted is greater than the spot cutoff angle, the light is completely masked. Otherwise, its intensity is controlled by the spot exponent and the attenuation factors. The initial spot cutoff is 180, resulting in uniform light distribution.
 *
 * - {@link GL_CONSTANT_ATTENUATION}, {@link GL_LINEAR_ATTENUATION}, {@link GL_QUADRATIC_ATTENUATION}
 *     **params** is a single integer or floating-point value that specifies one of the three light attenuation factors. Integer and floating-point values are mapped directly. Only nonnegative values are accepted. If the light is positional, rather than directional, its intensity is attenuated by the reciprocal of the sum of the constant factor, the linear factor times the distance between the light and the vertex being lighted, and the quadratic factor times the square of the same distance. The initial attenuation factors are (1, 0, 0), resulting in no attenuation.
 *
 * @summary set light source parameters
 * @param light Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form {@link GL_LIGHT} 𝐢, where i ranges from 0 to the value of {@link GL_MAX_LIGHTS} - 1.
 * @param pname Specifies a single-valued light source parameter for **light**. {@link GL_SPOT_EXPONENT}, {@link GL_SPOT_CUTOFF}, {@link GL_CONSTANT_ATTENUATION}, {@link GL_LINEAR_ATTENUATION}, and {@link GL_QUADRATIC_ATTENUATION} are accepted.
 * @param param Specifies the value that parameter **pname** of light source **light** will be set to.
 * @see [glLight](https://docs.gl/gl3/glLight)
 */
export function glLightf(light: GLenum, pname: GLenum, param: GLfloat): void;

/**
 * `glLight` sets the values of individual light source parameters. **light** names the light and is a symbolic name of the form {@link GL_LIGHT} 𝐢, where i ranges from 0 to the value of {@link GL_MAX_LIGHTS} - 1. **pname** specifies one of ten light source parameters, again by symbolic name. **params** is either a single value or a pointer to an array that contains the new values.
 *
 * To enable and disable lighting calculation, call {@link glEnable} and {@link glDisable} with argument {@link GL_LIGHTING}. Lighting is initially disabled. When it is enabled, light sources that are enabled contribute to the lighting calculation. Light source 𝐢 is enabled and disabled using {@link glEnable} and {@link glDisable} with argument {@link GL_LIGHT} 𝐢.
 *
 * The ten light parameters are as follows:
 *
 * - {@link GL_AMBIENT}
 * **params** contains four integer or floating-point values that specify the ambient RGBA intensity of the light. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial ambient light intensity is (0, 0, 0, 1).
 *
 * - {@link GL_DIFFUSE}
 * **params** contains four integer or floating-point values that specify the diffuse RGBA intensity of the light. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial value for {@link GL_LIGHT0} is (1, 1, 1, 1); for other lights, the initial value is (0, 0, 0, 1).
 *
 * - {@link GL_SPECULAR}
 * **params** contains four integer or floating-point values that specify the specular RGBA intensity of the light. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial value for {@link GL_LIGHT0} is (1, 1, 1, 1); for other lights, the initial value is (0, 0, 0, 1).
 *
 * - {@link GL_POSITION}
 * **params** contains four integer or floating-point values that specify the position of the light in homogeneous object coordinates. Both integer and floating-point values are mapped directly. Neither integer nor floating-point values are clamped.
 * The position is transformed by the modelview matrix when `glLight` is called (just as if it were a point), and it is stored in eye coordinates. If the 𝐰 component of the position is 0, the light is treated as a directional source. Diffuse and specular lighting calculations take the light's direction, but not its actual position, into account, and attenuation is disabled. Otherwise, diffuse and specular lighting calculations are based on the actual location of the light in eye coordinates, and attenuation is enabled. The initial position is (0, 0, 1, 0); thus, the initial light source is directional, parallel to, and in the direction of the −𝐳 axis.
 *
 * - {@link GL_SPOT_DIRECTION}
 * **params** contains three integer or floating-point values that specify the direction of the light in homogeneous object coordinates. Both integer and floating-point values are mapped directly. Neither integer nor floating-point values are clamped.
 * The spot direction is transformed by the upper 3x3 of the modelview matrix when `glLight` is called, and it is stored in eye coordinates. It is significant only when {@link GL_SPOT_CUTOFF} is not 180, which it is initially. The initial direction is (0,0,−1).
 *
 * - {@link GL_SPOT_EXPONENT}
 * **params** is a single integer or floating-point value that specifies the intensity distribution of the light. Integer and floating-point values are mapped directly. Only values in the range [0,128] are accepted.
 * Effective light intensity is attenuated by the cosine of the angle between the direction of the light and the direction from the light to the vertex being lighted, raised to the power of the spot exponent. Thus, higher spot exponents result in a more focused light source, regardless of the spot cutoff angle (see {@link GL_SPOT_CUTOFF}, next paragraph). The initial spot exponent is 0, resulting in uniform light distribution.
 *
 * - {@link GL_SPOT_CUTOFF}
 * **params** is a single integer or floating-point value that specifies the maximum spread angle of a light source. Integer and floating-point values are mapped directly. Only values in the range [0,90] and the special value 180 are accepted. If the angle between the direction of the light and the direction from the light to the vertex being lighted is greater than the spot cutoff angle, the light is completely masked. Otherwise, its intensity is controlled by the spot exponent and the attenuation factors. The initial spot cutoff is 180, resulting in uniform light distribution.
 *
 * - {@link GL_CONSTANT_ATTENUATION}, {@link GL_LINEAR_ATTENUATION}, {@link GL_QUADRATIC_ATTENUATION}
 *     **params** is a single integer or floating-point value that specifies one of the three light attenuation factors. Integer and floating-point values are mapped directly. Only nonnegative values are accepted. If the light is positional, rather than directional, its intensity is attenuated by the reciprocal of the sum of the constant factor, the linear factor times the distance between the light and the vertex being lighted, and the quadratic factor times the square of the same distance. The initial attenuation factors are (1, 0, 0), resulting in no attenuation.
 *
 * @summary set light source parameters
 * @param light Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form {@link GL_LIGHT} 𝐢, where i ranges from 0 to the value of {@link GL_MAX_LIGHTS} - 1.
 * @param pname Specifies a single-valued light source parameter for **light**. {@link GL_SPOT_EXPONENT}, {@link GL_SPOT_CUTOFF}, {@link GL_CONSTANT_ATTENUATION}, {@link GL_LINEAR_ATTENUATION}, and {@link GL_QUADRATIC_ATTENUATION} are accepted.
 * @param param Specifies the value that parameter **pname** of light source **light** will be set to.
 * @see [glLight](https://docs.gl/gl3/glLight)
 */
export function glLighti(light: GLenum, pname: GLenum, param: GLint): void;

/**
 * `glLight` sets the values of individual light source parameters. **light** names the light and is a symbolic name of the form {@link GL_LIGHT} 𝐢, where i ranges from 0 to the value of {@link GL_MAX_LIGHTS} - 1. **pname** specifies one of ten light source parameters, again by symbolic name. **params** is either a single value or a pointer to an array that contains the new values.
 *
 * To enable and disable lighting calculation, call {@link glEnable} and {@link glDisable} with argument {@link GL_LIGHTING}. Lighting is initially disabled. When it is enabled, light sources that are enabled contribute to the lighting calculation. Light source 𝐢 is enabled and disabled using {@link glEnable} and {@link glDisable} with argument {@link GL_LIGHT} 𝐢.
 *
 * The ten light parameters are as follows:
 *
 * - {@link GL_AMBIENT}
 * **params** contains four integer or floating-point values that specify the ambient RGBA intensity of the light. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial ambient light intensity is (0, 0, 0, 1).
 *
 * - {@link GL_DIFFUSE}
 * **params** contains four integer or floating-point values that specify the diffuse RGBA intensity of the light. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial value for {@link GL_LIGHT0} is (1, 1, 1, 1); for other lights, the initial value is (0, 0, 0, 1).
 *
 * - {@link GL_SPECULAR}
 * **params** contains four integer or floating-point values that specify the specular RGBA intensity of the light. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial value for {@link GL_LIGHT0} is (1, 1, 1, 1); for other lights, the initial value is (0, 0, 0, 1).
 *
 * - {@link GL_POSITION}
 * **params** contains four integer or floating-point values that specify the position of the light in homogeneous object coordinates. Both integer and floating-point values are mapped directly. Neither integer nor floating-point values are clamped.
 * The position is transformed by the modelview matrix when `glLight` is called (just as if it were a point), and it is stored in eye coordinates. If the 𝐰 component of the position is 0, the light is treated as a directional source. Diffuse and specular lighting calculations take the light's direction, but not its actual position, into account, and attenuation is disabled. Otherwise, diffuse and specular lighting calculations are based on the actual location of the light in eye coordinates, and attenuation is enabled. The initial position is (0, 0, 1, 0); thus, the initial light source is directional, parallel to, and in the direction of the −𝐳 axis.
 *
 * - {@link GL_SPOT_DIRECTION}
 * **params** contains three integer or floating-point values that specify the direction of the light in homogeneous object coordinates. Both integer and floating-point values are mapped directly. Neither integer nor floating-point values are clamped.
 * The spot direction is transformed by the upper 3x3 of the modelview matrix when `glLight` is called, and it is stored in eye coordinates. It is significant only when {@link GL_SPOT_CUTOFF} is not 180, which it is initially. The initial direction is (0,0,−1).
 *
 * - {@link GL_SPOT_EXPONENT}
 * **params** is a single integer or floating-point value that specifies the intensity distribution of the light. Integer and floating-point values are mapped directly. Only values in the range [0,128] are accepted.
 * Effective light intensity is attenuated by the cosine of the angle between the direction of the light and the direction from the light to the vertex being lighted, raised to the power of the spot exponent. Thus, higher spot exponents result in a more focused light source, regardless of the spot cutoff angle (see {@link GL_SPOT_CUTOFF}, next paragraph). The initial spot exponent is 0, resulting in uniform light distribution.
 *
 * - {@link GL_SPOT_CUTOFF}
 * **params** is a single integer or floating-point value that specifies the maximum spread angle of a light source. Integer and floating-point values are mapped directly. Only values in the range [0,90] and the special value 180 are accepted. If the angle between the direction of the light and the direction from the light to the vertex being lighted is greater than the spot cutoff angle, the light is completely masked. Otherwise, its intensity is controlled by the spot exponent and the attenuation factors. The initial spot cutoff is 180, resulting in uniform light distribution.
 *
 * - {@link GL_CONSTANT_ATTENUATION}, {@link GL_LINEAR_ATTENUATION}, {@link GL_QUADRATIC_ATTENUATION}
 *     **params** is a single integer or floating-point value that specifies one of the three light attenuation factors. Integer and floating-point values are mapped directly. Only nonnegative values are accepted. If the light is positional, rather than directional, its intensity is attenuated by the reciprocal of the sum of the constant factor, the linear factor times the distance between the light and the vertex being lighted, and the quadratic factor times the square of the same distance. The initial attenuation factors are (1, 0, 0), resulting in no attenuation.
 *
 * @summary set light source parameters
 * @param light Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form {@link GL_LIGHT} 𝐢, where i ranges from 0 to the value of {@link GL_MAX_LIGHTS} - 1.
 * @param pname Specifies a light source parameter for **light**. {@link GL_AMBIENT}, {@link GL_DIFFUSE}, {@link GL_SPECULAR}, {@link GL_POSITION}, {@link GL_SPOT_CUTOFF}, {@link GL_SPOT_DIRECTION}, {@link GL_SPOT_EXPONENT}, {@link GL_CONSTANT_ATTENUATION}, {@link GL_LINEAR_ATTENUATION}, and {@link GL_QUADRATIC_ATTENUATION} are accepted.
 * @param params Specifies a pointer to the value or values that parameter **pname** of light source **light** will be set to.
 * @see [glLight](https://docs.gl/gl3/glLight)
 */
export function glLightfv(
	light: GLenum,
	pname: GLenum,
	params: GLfloat | GLfloat[]
): void;

/**
 * `glLight` sets the values of individual light source parameters. **light** names the light and is a symbolic name of the form {@link GL_LIGHT} 𝐢, where i ranges from 0 to the value of {@link GL_MAX_LIGHTS} - 1. **pname** specifies one of ten light source parameters, again by symbolic name. **params** is either a single value or a pointer to an array that contains the new values.
 *
 * To enable and disable lighting calculation, call {@link glEnable} and {@link glDisable} with argument {@link GL_LIGHTING}. Lighting is initially disabled. When it is enabled, light sources that are enabled contribute to the lighting calculation. Light source 𝐢 is enabled and disabled using {@link glEnable} and {@link glDisable} with argument {@link GL_LIGHT} 𝐢.
 *
 * The ten light parameters are as follows:
 *
 * - {@link GL_AMBIENT}
 * **params** contains four integer or floating-point values that specify the ambient RGBA intensity of the light. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial ambient light intensity is (0, 0, 0, 1).
 *
 * - {@link GL_DIFFUSE}
 * **params** contains four integer or floating-point values that specify the diffuse RGBA intensity of the light. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial value for {@link GL_LIGHT0} is (1, 1, 1, 1); for other lights, the initial value is (0, 0, 0, 1).
 *
 * - {@link GL_SPECULAR}
 * **params** contains four integer or floating-point values that specify the specular RGBA intensity of the light. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial value for {@link GL_LIGHT0} is (1, 1, 1, 1); for other lights, the initial value is (0, 0, 0, 1).
 *
 * - {@link GL_POSITION}
 * **params** contains four integer or floating-point values that specify the position of the light in homogeneous object coordinates. Both integer and floating-point values are mapped directly. Neither integer nor floating-point values are clamped.
 * The position is transformed by the modelview matrix when `glLight` is called (just as if it were a point), and it is stored in eye coordinates. If the 𝐰 component of the position is 0, the light is treated as a directional source. Diffuse and specular lighting calculations take the light's direction, but not its actual position, into account, and attenuation is disabled. Otherwise, diffuse and specular lighting calculations are based on the actual location of the light in eye coordinates, and attenuation is enabled. The initial position is (0, 0, 1, 0); thus, the initial light source is directional, parallel to, and in the direction of the −𝐳 axis.
 *
 * - {@link GL_SPOT_DIRECTION}
 * **params** contains three integer or floating-point values that specify the direction of the light in homogeneous object coordinates. Both integer and floating-point values are mapped directly. Neither integer nor floating-point values are clamped.
 * The spot direction is transformed by the upper 3x3 of the modelview matrix when `glLight` is called, and it is stored in eye coordinates. It is significant only when {@link GL_SPOT_CUTOFF} is not 180, which it is initially. The initial direction is (0,0,−1).
 *
 * - {@link GL_SPOT_EXPONENT}
 * **params** is a single integer or floating-point value that specifies the intensity distribution of the light. Integer and floating-point values are mapped directly. Only values in the range [0,128] are accepted.
 * Effective light intensity is attenuated by the cosine of the angle between the direction of the light and the direction from the light to the vertex being lighted, raised to the power of the spot exponent. Thus, higher spot exponents result in a more focused light source, regardless of the spot cutoff angle (see {@link GL_SPOT_CUTOFF}, next paragraph). The initial spot exponent is 0, resulting in uniform light distribution.
 *
 * - {@link GL_SPOT_CUTOFF}
 * **params** is a single integer or floating-point value that specifies the maximum spread angle of a light source. Integer and floating-point values are mapped directly. Only values in the range [0,90] and the special value 180 are accepted. If the angle between the direction of the light and the direction from the light to the vertex being lighted is greater than the spot cutoff angle, the light is completely masked. Otherwise, its intensity is controlled by the spot exponent and the attenuation factors. The initial spot cutoff is 180, resulting in uniform light distribution.
 *
 * - {@link GL_CONSTANT_ATTENUATION}, {@link GL_LINEAR_ATTENUATION}, {@link GL_QUADRATIC_ATTENUATION}
 *     **params** is a single integer or floating-point value that specifies one of the three light attenuation factors. Integer and floating-point values are mapped directly. Only nonnegative values are accepted. If the light is positional, rather than directional, its intensity is attenuated by the reciprocal of the sum of the constant factor, the linear factor times the distance between the light and the vertex being lighted, and the quadratic factor times the square of the same distance. The initial attenuation factors are (1, 0, 0), resulting in no attenuation.
 *
 * @summary set light source parameters
 * @param light Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form {@link GL_LIGHT} 𝐢, where i ranges from 0 to the value of {@link GL_MAX_LIGHTS} - 1.
 * @param pname Specifies a light source parameter for **light**. {@link GL_AMBIENT}, {@link GL_DIFFUSE}, {@link GL_SPECULAR}, {@link GL_POSITION}, {@link GL_SPOT_CUTOFF}, {@link GL_SPOT_DIRECTION}, {@link GL_SPOT_EXPONENT}, {@link GL_CONSTANT_ATTENUATION}, {@link GL_LINEAR_ATTENUATION}, and {@link GL_QUADRATIC_ATTENUATION} are accepted.
 * @param params Specifies a pointer to the value or values that parameter **pname** of light source **light** will be set to.
 * @see [glLight](https://docs.gl/gl3/glLight)
 */
export function glLightiv(
	light: GLenum,
	pname: GLenum,
	params: GLint | GLint[]
): void;

/**
 * `glLightModel` sets the lighting model parameter. **pname** names a parameter and **params** gives the new value. There are three lighting model parameters:
 *
 * - {@link GL_LIGHT_MODEL_AMBIENT}
 * **params** contains four integer or floating-point values that specify the ambient RGBA intensity of the entire scene. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial ambient scene intensity is (0.2, 0.2, 0.2, 1.0).
 *
 * - {@link GL_LIGHT_MODEL_COLOR_CONTROL}
 * **params** must be either {@link GL_SEPARATE_SPECULAR_COLOR} or {@link GL_SINGLE_COLOR}. {@link GL_SINGLE_COLOR} specifies that a single color is generated from the lighting computation for a vertex. {@link GL_SEPARATE_SPECULAR_COLOR} specifies that the specular color computation of lighting be stored separately from the remainder of the lighting computation. The specular color is summed into the generated fragment's color after the application of texture mapping (if enabled). The initial value is {@link GL_SINGLE_COLOR}.
 *
 * - {@link GL_LIGHT_MODEL_LOCAL_VIEWER}
 * **params** is a single integer or floating-point value that specifies how specular reflection angles are computed. If **params** is 0 (or 0.0), specular reflection angles take the view direction to be parallel to and in the direction of the -**z** axis, regardless of the location of the vertex in eye coordinates. Otherwise, specular reflections are computed from the origin of the eye coordinate system. The initial value is 0.
 *
 * - {@link GL_LIGHT_MODEL_TWO_SIDE}
 * **params** is a single integer or floating-point value that specifies whether one- or two-sided lighting calculations are done for polygons. It has no effect on the lighting calculations for points, lines, or bitmaps. If **params** is 0 (or 0.0), one-sided lighting is specified, and only the **front** material parameters are used in the lighting equation. Otherwise, two-sided lighting is specified. In this case, vertices of back-facing polygons are lighted using the **back** material parameters and have their normals reversed before the lighting equation is evaluated. Vertices of front-facing polygons are always lighted using the **front** material parameters, with no change to their normals. The initial value is 0.
 *
 * In RGBA mode, the lighted color of a vertex is the sum of the material emission intensity, the product of the material ambient reflectance and the lighting model full-scene ambient intensity, and the contribution of each enabled light source. Each light source contributes the sum of three terms: ambient, diffuse, and specular. The ambient light source contribution is the product of the material ambient reflectance and the light's ambient intensity. The diffuse light source contribution is the product of the material diffuse reflectance, the light's diffuse intensity, and the dot product of the vertex's normal with the normalized vector from the vertex to the light source. The specular light source contribution is the product of the material specular reflectance, the light's specular intensity, and the dot product of the normalized vertex-to-eye and vertex-to-light vectors, raised to the power of the shininess of the material. All three light source contributions are attenuated equally based on the distance from the vertex to the light source and on light source direction, spread exponent, and spread cutoff angle. All dot products are replaced with 0 if they evaluate to a negative value.
 *
 * The alpha component of the resulting lighted color is set to the alpha value of the material diffuse reflectance.
 *
 * In color index mode, the value of the lighted index of a vertex ranges from the ambient to the specular values passed to {@link glMaterial} using {@link GL_COLOR_INDEXES}. Diffuse and specular coefficients, computed with a (.30, .59, .11) weighting of the lights' colors, the shininess of the material, and the same reflection and attenuation equations as in the RGBA case, determine how much above ambient the resulting index is.
 *
 * @summary set the lighting model parameters
 * @param pname Specifies a single-valued lighting model parameter. {@link GL_LIGHT_MODEL_LOCAL_VIEWER}, {@link GL_LIGHT_MODEL_COLOR_CONTROL}, and {@link GL_LIGHT_MODEL_TWO_SIDE} are accepted.
 * @param param Specifies the value that **param** will be set to.
 * @see [glLightModel](https://docs.gl/gl3/glLightModel)
 */
export function glLightModelf(pname: GLenum, param: GLfloat): void;

/**
 * `glLightModel` sets the lighting model parameter. **pname** names a parameter and **params** gives the new value. There are three lighting model parameters:
 *
 * - {@link GL_LIGHT_MODEL_AMBIENT}
 * **params** contains four integer or floating-point values that specify the ambient RGBA intensity of the entire scene. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial ambient scene intensity is (0.2, 0.2, 0.2, 1.0).
 *
 * - {@link GL_LIGHT_MODEL_COLOR_CONTROL}
 * **params** must be either {@link GL_SEPARATE_SPECULAR_COLOR} or {@link GL_SINGLE_COLOR}. {@link GL_SINGLE_COLOR} specifies that a single color is generated from the lighting computation for a vertex. {@link GL_SEPARATE_SPECULAR_COLOR} specifies that the specular color computation of lighting be stored separately from the remainder of the lighting computation. The specular color is summed into the generated fragment's color after the application of texture mapping (if enabled). The initial value is {@link GL_SINGLE_COLOR}.
 *
 * - {@link GL_LIGHT_MODEL_LOCAL_VIEWER}
 * **params** is a single integer or floating-point value that specifies how specular reflection angles are computed. If **params** is 0 (or 0.0), specular reflection angles take the view direction to be parallel to and in the direction of the -**z** axis, regardless of the location of the vertex in eye coordinates. Otherwise, specular reflections are computed from the origin of the eye coordinate system. The initial value is 0.
 *
 * - {@link GL_LIGHT_MODEL_TWO_SIDE}
 * **params** is a single integer or floating-point value that specifies whether one- or two-sided lighting calculations are done for polygons. It has no effect on the lighting calculations for points, lines, or bitmaps. If **params** is 0 (or 0.0), one-sided lighting is specified, and only the **front** material parameters are used in the lighting equation. Otherwise, two-sided lighting is specified. In this case, vertices of back-facing polygons are lighted using the **back** material parameters and have their normals reversed before the lighting equation is evaluated. Vertices of front-facing polygons are always lighted using the **front** material parameters, with no change to their normals. The initial value is 0.
 *
 * In RGBA mode, the lighted color of a vertex is the sum of the material emission intensity, the product of the material ambient reflectance and the lighting model full-scene ambient intensity, and the contribution of each enabled light source. Each light source contributes the sum of three terms: ambient, diffuse, and specular. The ambient light source contribution is the product of the material ambient reflectance and the light's ambient intensity. The diffuse light source contribution is the product of the material diffuse reflectance, the light's diffuse intensity, and the dot product of the vertex's normal with the normalized vector from the vertex to the light source. The specular light source contribution is the product of the material specular reflectance, the light's specular intensity, and the dot product of the normalized vertex-to-eye and vertex-to-light vectors, raised to the power of the shininess of the material. All three light source contributions are attenuated equally based on the distance from the vertex to the light source and on light source direction, spread exponent, and spread cutoff angle. All dot products are replaced with 0 if they evaluate to a negative value.
 *
 * The alpha component of the resulting lighted color is set to the alpha value of the material diffuse reflectance.
 *
 * In color index mode, the value of the lighted index of a vertex ranges from the ambient to the specular values passed to {@link glMaterial} using {@link GL_COLOR_INDEXES}. Diffuse and specular coefficients, computed with a (.30, .59, .11) weighting of the lights' colors, the shininess of the material, and the same reflection and attenuation equations as in the RGBA case, determine how much above ambient the resulting index is.
 *
 * @summary set the lighting model parameters
 * @param pname Specifies a single-valued lighting model parameter. {@link GL_LIGHT_MODEL_LOCAL_VIEWER}, {@link GL_LIGHT_MODEL_COLOR_CONTROL}, and {@link GL_LIGHT_MODEL_TWO_SIDE} are accepted.
 * @param param Specifies the value that **param** will be set to.
 * @see [glLightModel](https://docs.gl/gl3/glLightModel)
 */
export function glLightModeli(pname: GLenum, param: GLint): void;

/**
 * `glLightModel` sets the lighting model parameter. **pname** names a parameter and **params** gives the new value. There are three lighting model parameters:
 *
 * - {@link GL_LIGHT_MODEL_AMBIENT}
 * **params** contains four integer or floating-point values that specify the ambient RGBA intensity of the entire scene. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial ambient scene intensity is (0.2, 0.2, 0.2, 1.0).
 *
 * - {@link GL_LIGHT_MODEL_COLOR_CONTROL}
 * **params** must be either {@link GL_SEPARATE_SPECULAR_COLOR} or {@link GL_SINGLE_COLOR}. {@link GL_SINGLE_COLOR} specifies that a single color is generated from the lighting computation for a vertex. {@link GL_SEPARATE_SPECULAR_COLOR} specifies that the specular color computation of lighting be stored separately from the remainder of the lighting computation. The specular color is summed into the generated fragment's color after the application of texture mapping (if enabled). The initial value is {@link GL_SINGLE_COLOR}.
 *
 * - {@link GL_LIGHT_MODEL_LOCAL_VIEWER}
 * **params** is a single integer or floating-point value that specifies how specular reflection angles are computed. If **params** is 0 (or 0.0), specular reflection angles take the view direction to be parallel to and in the direction of the -**z** axis, regardless of the location of the vertex in eye coordinates. Otherwise, specular reflections are computed from the origin of the eye coordinate system. The initial value is 0.
 *
 * - {@link GL_LIGHT_MODEL_TWO_SIDE}
 * **params** is a single integer or floating-point value that specifies whether one- or two-sided lighting calculations are done for polygons. It has no effect on the lighting calculations for points, lines, or bitmaps. If **params** is 0 (or 0.0), one-sided lighting is specified, and only the **front** material parameters are used in the lighting equation. Otherwise, two-sided lighting is specified. In this case, vertices of back-facing polygons are lighted using the **back** material parameters and have their normals reversed before the lighting equation is evaluated. Vertices of front-facing polygons are always lighted using the **front** material parameters, with no change to their normals. The initial value is 0.
 *
 * In RGBA mode, the lighted color of a vertex is the sum of the material emission intensity, the product of the material ambient reflectance and the lighting model full-scene ambient intensity, and the contribution of each enabled light source. Each light source contributes the sum of three terms: ambient, diffuse, and specular. The ambient light source contribution is the product of the material ambient reflectance and the light's ambient intensity. The diffuse light source contribution is the product of the material diffuse reflectance, the light's diffuse intensity, and the dot product of the vertex's normal with the normalized vector from the vertex to the light source. The specular light source contribution is the product of the material specular reflectance, the light's specular intensity, and the dot product of the normalized vertex-to-eye and vertex-to-light vectors, raised to the power of the shininess of the material. All three light source contributions are attenuated equally based on the distance from the vertex to the light source and on light source direction, spread exponent, and spread cutoff angle. All dot products are replaced with 0 if they evaluate to a negative value.
 *
 * The alpha component of the resulting lighted color is set to the alpha value of the material diffuse reflectance.
 *
 * In color index mode, the value of the lighted index of a vertex ranges from the ambient to the specular values passed to {@link glMaterial} using {@link GL_COLOR_INDEXES}. Diffuse and specular coefficients, computed with a (.30, .59, .11) weighting of the lights' colors, the shininess of the material, and the same reflection and attenuation equations as in the RGBA case, determine how much above ambient the resulting index is.
 *
 * @summary set the lighting model parameters
 * @param pname Specifies a lighting model parameter. {@link GL_LIGHT_MODEL_AMBIENT}, {@link GL_LIGHT_MODEL_COLOR_CONTROL}, {@link GL_LIGHT_MODEL_LOCAL_VIEWER}, and {@link GL_LIGHT_MODEL_TWO_SIDE} are accepted.
 * @param params Specifies a pointer to the value or values that **params** will be set to.
 * @see [glLightModel](https://docs.gl/gl3/glLightModel)
 */
export function glLightModelfv(
	pname: GLenum,
	params: GLfloat | GLfloat[]
): void;

/**
 * `glLightModel` sets the lighting model parameter. **pname** names a parameter and **params** gives the new value. There are three lighting model parameters:
 *
 * - {@link GL_LIGHT_MODEL_AMBIENT}
 * **params** contains four integer or floating-point values that specify the ambient RGBA intensity of the entire scene. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial ambient scene intensity is (0.2, 0.2, 0.2, 1.0).
 *
 * - {@link GL_LIGHT_MODEL_COLOR_CONTROL}
 * **params** must be either {@link GL_SEPARATE_SPECULAR_COLOR} or {@link GL_SINGLE_COLOR}. {@link GL_SINGLE_COLOR} specifies that a single color is generated from the lighting computation for a vertex. {@link GL_SEPARATE_SPECULAR_COLOR} specifies that the specular color computation of lighting be stored separately from the remainder of the lighting computation. The specular color is summed into the generated fragment's color after the application of texture mapping (if enabled). The initial value is {@link GL_SINGLE_COLOR}.
 *
 * - {@link GL_LIGHT_MODEL_LOCAL_VIEWER}
 * **params** is a single integer or floating-point value that specifies how specular reflection angles are computed. If **params** is 0 (or 0.0), specular reflection angles take the view direction to be parallel to and in the direction of the -**z** axis, regardless of the location of the vertex in eye coordinates. Otherwise, specular reflections are computed from the origin of the eye coordinate system. The initial value is 0.
 *
 * - {@link GL_LIGHT_MODEL_TWO_SIDE}
 * **params** is a single integer or floating-point value that specifies whether one- or two-sided lighting calculations are done for polygons. It has no effect on the lighting calculations for points, lines, or bitmaps. If **params** is 0 (or 0.0), one-sided lighting is specified, and only the **front** material parameters are used in the lighting equation. Otherwise, two-sided lighting is specified. In this case, vertices of back-facing polygons are lighted using the **back** material parameters and have their normals reversed before the lighting equation is evaluated. Vertices of front-facing polygons are always lighted using the **front** material parameters, with no change to their normals. The initial value is 0.
 *
 * In RGBA mode, the lighted color of a vertex is the sum of the material emission intensity, the product of the material ambient reflectance and the lighting model full-scene ambient intensity, and the contribution of each enabled light source. Each light source contributes the sum of three terms: ambient, diffuse, and specular. The ambient light source contribution is the product of the material ambient reflectance and the light's ambient intensity. The diffuse light source contribution is the product of the material diffuse reflectance, the light's diffuse intensity, and the dot product of the vertex's normal with the normalized vector from the vertex to the light source. The specular light source contribution is the product of the material specular reflectance, the light's specular intensity, and the dot product of the normalized vertex-to-eye and vertex-to-light vectors, raised to the power of the shininess of the material. All three light source contributions are attenuated equally based on the distance from the vertex to the light source and on light source direction, spread exponent, and spread cutoff angle. All dot products are replaced with 0 if they evaluate to a negative value.
 *
 * The alpha component of the resulting lighted color is set to the alpha value of the material diffuse reflectance.
 *
 * In color index mode, the value of the lighted index of a vertex ranges from the ambient to the specular values passed to {@link glMaterial} using {@link GL_COLOR_INDEXES}. Diffuse and specular coefficients, computed with a (.30, .59, .11) weighting of the lights' colors, the shininess of the material, and the same reflection and attenuation equations as in the RGBA case, determine how much above ambient the resulting index is.
 *
 * @summary set the lighting model parameters
 * @param pname Specifies a lighting model parameter. {@link GL_LIGHT_MODEL_AMBIENT}, {@link GL_LIGHT_MODEL_COLOR_CONTROL}, {@link GL_LIGHT_MODEL_LOCAL_VIEWER}, and {@link GL_LIGHT_MODEL_TWO_SIDE} are accepted.
 * @param params Specifies a pointer to the value or values that **params** will be set to.
 * @see [glLightModel](https://docs.gl/gl3/glLightModel)
 */
export function glLightModeliv(pname: GLenum, params: GLint | GLint[]): void;

/**
 * Line stippling masks out certain fragments produced by rasterization; those fragments will not be drawn. The masking is achieved by using three parameters: the 16-bit line stipple pattern **pattern**, the repeat count **factor**, and an integer stipple counter 𝐬.
 *
 * Counter 𝐬 is reset to 0 whenever {@link glBegin} is called and before each line segment of a {@link glBegin}({@link GL_LINES})/{@link glEnd} sequence is generated. It is incremented after each fragment of a unit width aliased line segment is generated or after each 𝐢 fragments of an 𝐢 width line segment are generated. The 𝐢 fragments associated with count 𝐬 are masked out if
 *
 * **pattern** bit (𝐬 / factor)%16
 *
 * is 0, otherwise these fragments are sent to the frame buffer. Bit zero of **pattern** is the least significant bit.
 *
 * Antialiased lines are treated as a sequence of 1 × *width* rectangles for purposes of stippling. Whether rectangle 𝐬 is rasterized or not depends on the fragment rule described for aliased lines, counting rectangles rather than groups of fragments.
 *
 * To enable and disable line stippling, call {@link glEnable} and {@link glDisable} with argument {@link GL_LINE_STIPPLE}. When enabled, the line stipple pattern is applied as described above. When disabled, it is as if the pattern were all 1's. Initially, line stippling is disabled.
 *
 * @summary specify the line stipple pattern
 * @param factor Specifies a multiplier for each bit in the line stipple pattern. If **factor** is 3, for example, each bit in the pattern is used three times before the next bit in the pattern is used. **factor** is clamped to the range [1, 256] and defaults to 1.
 * @param pattern Specifies a 16-bit integer whose bit pattern determines which fragments of a line will be drawn when the line is rasterized. Bit zero is used first; the default pattern is all 1's.
 * @see [glLineStipple](https://docs.gl/gl3/glLineStipple)
 */
export function glLineStipple(factor: GLint, pattern: GLushort): void;

/**
 * `glLineWidth` specifies the rasterized width of both aliased and antialiased lines. Using a line width other than 1 has different effects, depending on whether line antialiasing is enabled. To enable and disable line antialiasing, call {@link glEnable} and {@link glDisable} with argument {@link GL_LINE_SMOOTH}. Line antialiasing is initially disabled.
 *
 * If line antialiasing is disabled, the actual width is determined by rounding the supplied width to the nearest integer. (If the rounding results in the value 0, it is as if the line width were 1.) If ∣Δ𝐱∣ >= ∣Δ𝐲∣, **i** pixels are filled in each column that is rasterized, where **i** is the rounded value of **width**. Otherwise, **i** pixels are filled in each row that is rasterized.
 *
 * If antialiasing is enabled, line rasterization produces a fragment for each pixel square that intersects the region lying within the rectangle having width equal to the current line width, length equal to the actual length of the line, and centered on the mathematical line segment. The coverage value for each fragment is the window coordinate area of the intersection of the rectangular region with the corresponding pixel square. This value is saved and used in the final rasterization step.
 *
 * Not all widths can be supported when line antialiasing is enabled. If an unsupported width is requested, the nearest supported width is used. Only width 1 is guaranteed to be supported; others depend on the implementation. Likewise, there is a range for aliased line widths as well. To query the range of supported widths and the size difference between supported widths within the range, call {@link glGet} with arguments {@link GL_ALIASED_LINE_WIDTH_RANGE}, {@link GL_SMOOTH_LINE_WIDTH_RANGE}, and {@link GL_SMOOTH_LINE_WIDTH_GRANULARITY}.
 *
 * @summary specify the width of rasterized lines
 * @param width Specifies the width of rasterized lines. The initial value is 1.
 * @see [glLineWidth](https://docs.gl/gl3/glLineWidth)
 */
export function glLineWidth(width: GLfloat): void;

/**
 * {@link glCallLists} specifies an array of offsets. Display-list names are generated by adding **base** to each offset. Names that reference valid display lists are executed; the others are ignored.
 *
 * @summary set the display-list base for {@link glCallLists}
 * @param base Specifies an integer offset that will be added to {@link glCallLists} offsets to generate display-list names. The initial value is 0.
 * @see [glListBase](https://docs.gl/gl3/glListBase)
 */
export function glListBase(base: GLuint): void;

/**
 * `glLoadIdentity` replaces the current matrix with the identity matrix. It is semantically equivalent to calling {@link glLoadMatrix} with the identity matrix
 *
 * ⎛1ㅤ0ㅤ0ㅤ0⎞
 *
 * ⎜0ㅤ1ㅤ0ㅤ0 ⎜
 *
 * ⎜0ㅤ0ㅤ1ㅤ0 ⎜
 *
 * ⎝0ㅤ0ㅤ0ㅤ1⎠
 *
 * but in some cases it is more efficient.
 *
 * @summary replace the current matrix with the identity matrix
 * @see [glLoadIdentity](https://docs.gl/gl3/glLoadIdentity)
 */
export function glLoadIdentity(): void;

/**
 * `glLoadMatrix` replaces the current matrix with the one whose elements are specified by **m**. The current matrix is the projection matrix, modelview matrix, or texture matrix, depending on the current matrix mode (see {@link glMatrixMode}).
 *
 * The current matrix, M, defines a transformation of coordinates. For instance, assume M refers to the modelview matrix. If 𝐯 = (𝐯[0], 𝐯[1], 𝐯[2], 𝐯[3]) is the set of object coordinates of a vertex, and **𝐦** points to an array of 16 single- or double-precision floating-point values 𝐦 = {𝐦[0], 𝐦[1], ..., 𝐦[15]}, then the modelview transformation M(𝐯) does the following:
 *
 *ㅤㅤㅤㅤ⎛𝐦[0]ㅤ𝐦[4]ㅤ𝐦[8]  ㅤ𝐦[12]⎞ㅤㅤㅤ⎛𝐯[0]⎞
 *
 * ㅤㅤㅤㅤ⎜𝐦[1]ㅤ𝐦[5]ㅤ𝐦[9]  ㅤ𝐦[13]⎟ㅤㅤㅤ⎜𝐯[1]⎟
 *
 * M(𝐯) =ㅤ⎜𝐦[2]ㅤ𝐦[6]ㅤ𝐦[10]ㅤ𝐦[14]⎟ㅤ× ㅤ⎜𝐯[2]⎟
 *
 * ㅤㅤㅤㅤ⎝𝐦[3]ㅤ𝐦[7]ㅤ𝐦[11]ㅤ𝐦[15]⎠ㅤㅤㅤ⎝𝐯[3]⎠
 *
 * Projection and texture transformations are similarly defined.
 *
 * @summary replace the current matrix with the specified matrix
 * @param m Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 × 4 column-major matrix.
 * @see [glLoadMatrix](https://docs.gl/gl3/glLoadMatrix)
 */
export function glLoadMatrixd(m: GLdouble | GLdouble[]): void;

/**
 * `glLoadMatrix` replaces the current matrix with the one whose elements are specified by **m**. The current matrix is the projection matrix, modelview matrix, or texture matrix, depending on the current matrix mode (see {@link glMatrixMode}).
 *
 * The current matrix, M, defines a transformation of coordinates. For instance, assume M refers to the modelview matrix. If 𝐯 = (𝐯[0], 𝐯[1], 𝐯[2], 𝐯[3]) is the set of object coordinates of a vertex, and **𝐦** points to an array of 16 single- or double-precision floating-point values 𝐦 = {𝐦[0], 𝐦[1], ..., 𝐦[15]}, then the modelview transformation M(𝐯) does the following:
 *
 *ㅤㅤㅤㅤ⎛𝐦[0]ㅤ𝐦[4]ㅤ𝐦[8]  ㅤ𝐦[12]⎞ㅤㅤㅤ⎛𝐯[0]⎞
 *
 * ㅤㅤㅤㅤ⎜𝐦[1]ㅤ𝐦[5]ㅤ𝐦[9]  ㅤ𝐦[13]⎟ㅤㅤㅤ⎜𝐯[1]⎟
 *
 * M(𝐯) =ㅤ⎜𝐦[2]ㅤ𝐦[6]ㅤ𝐦[10]ㅤ𝐦[14]⎟ㅤ× ㅤ⎜𝐯[2]⎟
 *
 * ㅤㅤㅤㅤ⎝𝐦[3]ㅤ𝐦[7]ㅤ𝐦[11]ㅤ𝐦[15]⎠ㅤㅤㅤ⎝𝐯[3]⎠
 *
 * Projection and texture transformations are similarly defined.
 *
 * @summary replace the current matrix with the specified matrix
 * @param m Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 × 4 column-major matrix.
 * @see [glLoadMatrix](https://docs.gl/gl3/glLoadMatrix)
 */
export function glLoadMatrixf(m: GLfloat | GLfloat[]): void;

/**
 * The name stack is used during selection mode to allow sets of rendering commands to be uniquely identified. It consists of an ordered set of unsigned integers and is initially empty.
 *
 * `glLoadName` causes **name** to replace the value on the top of the name stack.
 *
 * The name stack is always empty while the render mode is not {@link GL_SELECT}. Calls to `glLoadName` while the render mode is not {@link GL_SELECT} are ignored.
 *
 * @summary load a name onto the name stack
 * @param name Specifies a name that will replace the top value on the name stack.
 * @see [glLoadName](https://docs.gl/gl3/glLoadName)
 */
export function glLoadName(name: GLuint): void;

/**
 * `glLogicOp` specifies a logical operation that, when enabled, is applied between the incoming RGBA color and the RGBA color at the corresponding location in the frame buffer. To enable or disable the logical operation, call {@link glEnable} and {@link glDisable} using the symbolic constant {@link GL_COLOR_LOGIC_OP}. The initial value is disabled.
 *
 *  Opcode 	Resulting Operation
 * {@link GL_CLEAR} 	0
 * {@link GL_SET} 	1
 * {@link GL_COPY} 	s
 * {@link GL_COPY_INVERTED} 	~s
 * {@link GL_NOOP} 	d
 * {@link GL_INVERT} 	~d
 * {@link GL_AND} 	s & d
 * {@link GL_NAND} 	~(s & d)
 * {@link GL_OR} 	s | d
 * {@link GL_NOR} 	~(s | d)
 * {@link GL_XOR} 	s ^ d
 * {@link GL_EQUIV} 	~(s ^ d)
 * {@link GL_AND_REVERSE} 	s & ~d
 * {@link GL_AND_INVERTED} 	~s & d
 * {@link GL_OR_REVERSE} 	s | ~d
 * {@link GL_OR_INVERTED} 	~s | d
 *
 * | **Opcode**               | **Resulting Operation** |
 * | :----------------------- | :---------------------- |
 * | {@link GL_CLEAR}         | 0                       |
 * | {@link GL_SET}           | 1                       |
 * | {@link GL_COPY}          | s                       |
 * | {@link GL_COPY_INVERTED} | ~s                      |
 * | {@link GL_NOOP}          | d                       |
 * | {@link GL_INVERT}        | ~d                      |
 * | {@link GL_AND}           | s & d                   |
 * | {@link GL_NAND}          | ~(s & d)                |
 * | {@link GL_OR}            | s \| d                  |
 * | {@link GL_NOR}           | ~(s \| d)               |
 * | {@link GL_XOR}           | s ^ d                   |
 * | {@link GL_EQUIV}         | ~(s ^ d)                |
 * | {@link GL_AND_REVERSE}   | s & ~d                  |
 * | {@link GL_AND_INVERTED}  | ~s & d                  |
 * | {@link GL_OR_REVERSE}    | s \| ~d                 |
 * | {@link GL_OR_INVERTED}   | ~s \| d                 |
 *
 * **opcode** is a symbolic constant chosen from the list above. In the explanation of the logical operations, **s** represents the incoming color and **d** represents the color in the frame buffer. Standard C-language operators are used. As these bitwise operators suggest, the logical operation is applied independently to each bit pair of the source and destination colors.
 *
 * @summary specify a logical pixel operation for rendering
 * @param opcode Specifies a symbolic constant that selects a logical operation. The following symbols are accepted: {@link GL_CLEAR}, {@link GL_SET}, {@link GL_COPY}, {@link GL_COPY_INVERTED}, {@link GL_NOOP}, {@link GL_INVERT}, {@link GL_AND}, {@link GL_NAND}, {@link GL_OR}, {@link GL_NOR}, {@link GL_XOR}, {@link GL_EQUIV}, {@link GL_AND_REVERSE}, {@link GL_AND_INVERTED}, {@link GL_OR_REVERSE}, and {@link GL_OR_INVERTED}. The initial value is {@link GL_COPY}.
 * @see [glLogicOp](https://docs.gl/gl3/glLogicOp)
 */
export function glLogicOp(opcode: GLenum): void;

/**
 * Evaluators provide a way to use polynomial or rational polynomial mapping to produce vertices, normals, texture coordinates, and colors. The values produced by an evaluator are sent to further stages of GL processing just as if they had been presented using {@link glVertex}, {@link glNormal}, {@link glTexCoord}, and {@link glColor} commands, except that the generated values do not update the current normal, texture coordinates, or color.
 *
 * All polynomial or rational polynomial splines of any degree (up to the maximum degree supported by the GL implementation) can be described using evaluators. These include almost all splines used in computer graphics: B-splines, Bezier curves, Hermite splines, and so on.
 *
 * Evaluators define curves based on Bernstein polynomials. Define p(û) as
 *
 * p(û) = n∑i=0 𝐁ᵢⁿ(û) 𝐑ᵢ
 *
 * where 𝐑ᵢ is a control point and 𝐁ᵢⁿ(û) is the 𝐢ᵗʰ Bernstein polynomial of degree 𝐧 (**order** = 𝐧 + 1):
 *
 * 𝐁ᵢⁿ(û) = (𝐧ㅤㅤi)ûⁱ ( 1− û) ^ 𝐧−i
 *
 * Recall that
 *
 * 0⁰ == 1 and (𝐧ㅤㅤ0) == 1
 *
 * `glMap1` is used to define the basis and to specify what kind of values are produced. Once defined, a map can be enabled and disabled by calling {@link glEnable} and {@link glDisable} with the map name, one of the nine predefined values for **target** described below. {@link glEvalCoord1} evaluates the one-dimensional maps that are enabled. When {@link glEvalCoord1} presents a value 𝐮, the Bernstein functions are evaluated using û, where û = (𝐮 − 𝐮1 / 𝐮2 − 𝐮1)
 *
 * **target** is a symbolic constant that indicates what kind of control points are provided in **points**, and what output is generated when the map is evaluated. It can assume one of nine predefined values:
 *
 * - {@link GL_MAP1_VERTEX_3}
 * Each control point is three floating-point values representing 𝐱, 𝐲 and 𝐳. Internal {@link glVertex3} commands are generated when the map is evaluated.
 *
 * - {@link GL_MAP1_VERTEX_4}
 * Each control point is four floating-point values representing 𝐱, 𝐲, 𝐳 and 𝐰. Internal {@link glVertex4} commands are generated when the map is evaluated.
 *
 * - {@link GL_MAP1_INDEX}
 * Each control point is a single floating-point value representing a color index. Internal {@link glIndex} commands are generated when the map is evaluated but the current index is not updated with the value of these {@link glIndex} commands.
 *
 * - {@link GL_MAP1_COLOR_4}
 * Each control point is four floating-point values representing red, green, blue, and alpha. Internal {@link glColor4} commands are generated when the map is evaluated but the current color is not updated with the value of these {@link glColor4} commands.
 *
 * - {@link GL_MAP1_NORMAL}
 * Each control point is three floating-point values representing the 𝐱, 𝐲 and 𝐳 components of a normal vector. Internal {@link glNormal} commands are generated when the map is evaluated but the current normal is not updated with the value of these {@link glNormal} commands.
 *
 * - {@link GL_MAP1_TEXTURE_COORD_1}
 * Each control point is a single floating-point value representing the 𝐬 texture coordinate. Internal {@link glTexCoord1} commands are generated when the map is evaluated but the current texture coordinates are not updated with the value of these {@link glTexCoord} commands.
 *
 * - {@link GL_MAP1_TEXTURE_COORD_2}
 * Each control point is two floating-point values representing the 𝐬 and 𝐭 texture coordinates. Internal {@link glTexCoord2} commands are generated when the map is evaluated but the current texture coordinates are not updated with the value of these {@link glTexCoord} commands.
 *
 * - {@link GL_MAP1_TEXTURE_COORD_3}
 * Each control point is three floating-point values representing the 𝐬, 𝐭 and 𝐫 texture coordinates. Internal {@link glTexCoord3} commands are generated when the map is evaluated but the current texture coordinates are not updated with the value of these {@link glTexCoord} commands.
 *
 * - {@link GL_MAP1_TEXTURE_COORD_4}
 * Each control point is four floating-point values representing the 𝐬, 𝐭, 𝐫 and 𝐪 texture coordinates. Internal {@link glTexCoord4} commands are generated when the map is evaluated but the current texture coordinates are not updated with the value of these {@link glTexCoord} commands.
 *
 * **stride**, **order**, and **points** define the array addressing for accessing the control points. **points** is the location of the first control point, which occupies one, two, three, or four contiguous memory locations, depending on which map is being defined. **order** is the number of control points in the array. **stride** specifies how many float or double locations to advance the internal memory pointer to reach the next control point.
 *
 * @summary define a one-dimensional evaluator
 * @param target Specifies the kind of values that are generated by the evaluator. Symbolic constants {@link GL_MAP1_VERTEX_3}, {@link GL_MAP1_VERTEX_4}, {@link GL_MAP1_INDEX}, {@link GL_MAP1_COLOR_4}, {@link GL_MAP1_NORMAL}, {@link GL_MAP1_TEXTURE_COORD_1}, {@link GL_MAP1_TEXTURE_COORD_2}, {@link GL_MAP1_TEXTURE_COORD_3}, and {@link GL_MAP1_TEXTURE_COORD_4} are accepted.
 * @param u1 Specifies a linear mapping of 𝐮, as presented to {@link glEvalCoord1}, to *û*, the variable that is evaluated by the equations specified by this command.
 * @param u2 Specifies a linear mapping of 𝐮, as presented to {@link glEvalCoord1}, to *û*, the variable that is evaluated by the equations specified by this command.
 * @param stride Specifies the number of floats or doubles between the beginning of one control point and the beginning of the next one in the data structure referenced in **points**. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations.
 * @param order Specifies the number of control points. Must be positive.
 * @param points Specifies a pointer to the array of control points.
 * @see [glMap1](https://docs.gl/gl3/glMap1)
 */
export function glMap1d(
	target: GLenum,
	u1: GLdouble,
	u2: GLdouble,
	stride: GLint,
	order: GLint,
	points: GLdouble | GLdouble[]
): void;

/**
 * Evaluators provide a way to use polynomial or rational polynomial mapping to produce vertices, normals, texture coordinates, and colors. The values produced by an evaluator are sent to further stages of GL processing just as if they had been presented using {@link glVertex}, {@link glNormal}, {@link glTexCoord}, and {@link glColor} commands, except that the generated values do not update the current normal, texture coordinates, or color.
 *
 * All polynomial or rational polynomial splines of any degree (up to the maximum degree supported by the GL implementation) can be described using evaluators. These include almost all splines used in computer graphics: B-splines, Bezier curves, Hermite splines, and so on.
 *
 * Evaluators define curves based on Bernstein polynomials. Define p(û) as
 *
 * p(û) = n∑i=0 𝐁ᵢⁿ(û) 𝐑ᵢ
 *
 * where 𝐑ᵢ is a control point and 𝐁ᵢⁿ(û) is the 𝐢ᵗʰ Bernstein polynomial of degree 𝐧 (**order** = 𝐧 + 1):
 *
 * 𝐁ᵢⁿ(û) = (𝐧ㅤㅤi)ûⁱ ( 1− û) ^ 𝐧−i
 *
 * Recall that
 *
 * 0⁰ == 1 and (𝐧ㅤㅤ0) == 1
 *
 * `glMap1` is used to define the basis and to specify what kind of values are produced. Once defined, a map can be enabled and disabled by calling {@link glEnable} and {@link glDisable} with the map name, one of the nine predefined values for **target** described below. {@link glEvalCoord1} evaluates the one-dimensional maps that are enabled. When {@link glEvalCoord1} presents a value 𝐮, the Bernstein functions are evaluated using û, where û = (𝐮 − 𝐮1 / 𝐮2 − 𝐮1)
 *
 * **target** is a symbolic constant that indicates what kind of control points are provided in **points**, and what output is generated when the map is evaluated. It can assume one of nine predefined values:
 *
 * - {@link GL_MAP1_VERTEX_3}
 * Each control point is three floating-point values representing 𝐱, 𝐲 and 𝐳. Internal {@link glVertex3} commands are generated when the map is evaluated.
 *
 * - {@link GL_MAP1_VERTEX_4}
 * Each control point is four floating-point values representing 𝐱, 𝐲, 𝐳 and 𝐰. Internal {@link glVertex4} commands are generated when the map is evaluated.
 *
 * - {@link GL_MAP1_INDEX}
 * Each control point is a single floating-point value representing a color index. Internal {@link glIndex} commands are generated when the map is evaluated but the current index is not updated with the value of these {@link glIndex} commands.
 *
 * - {@link GL_MAP1_COLOR_4}
 * Each control point is four floating-point values representing red, green, blue, and alpha. Internal {@link glColor4} commands are generated when the map is evaluated but the current color is not updated with the value of these {@link glColor4} commands.
 *
 * - {@link GL_MAP1_NORMAL}
 * Each control point is three floating-point values representing the 𝐱, 𝐲 and 𝐳 components of a normal vector. Internal {@link glNormal} commands are generated when the map is evaluated but the current normal is not updated with the value of these {@link glNormal} commands.
 *
 * - {@link GL_MAP1_TEXTURE_COORD_1}
 * Each control point is a single floating-point value representing the 𝐬 texture coordinate. Internal {@link glTexCoord1} commands are generated when the map is evaluated but the current texture coordinates are not updated with the value of these {@link glTexCoord} commands.
 *
 * - {@link GL_MAP1_TEXTURE_COORD_2}
 * Each control point is two floating-point values representing the 𝐬 and 𝐭 texture coordinates. Internal {@link glTexCoord2} commands are generated when the map is evaluated but the current texture coordinates are not updated with the value of these {@link glTexCoord} commands.
 *
 * - {@link GL_MAP1_TEXTURE_COORD_3}
 * Each control point is three floating-point values representing the 𝐬, 𝐭 and 𝐫 texture coordinates. Internal {@link glTexCoord3} commands are generated when the map is evaluated but the current texture coordinates are not updated with the value of these {@link glTexCoord} commands.
 *
 * - {@link GL_MAP1_TEXTURE_COORD_4}
 * Each control point is four floating-point values representing the 𝐬, 𝐭, 𝐫 and 𝐪 texture coordinates. Internal {@link glTexCoord4} commands are generated when the map is evaluated but the current texture coordinates are not updated with the value of these {@link glTexCoord} commands.
 *
 * **stride**, **order**, and **points** define the array addressing for accessing the control points. **points** is the location of the first control point, which occupies one, two, three, or four contiguous memory locations, depending on which map is being defined. **order** is the number of control points in the array. **stride** specifies how many float or double locations to advance the internal memory pointer to reach the next control point.
 *
 * @summary define a one-dimensional evaluator
 * @param target Specifies the kind of values that are generated by the evaluator. Symbolic constants {@link GL_MAP1_VERTEX_3}, {@link GL_MAP1_VERTEX_4}, {@link GL_MAP1_INDEX}, {@link GL_MAP1_COLOR_4}, {@link GL_MAP1_NORMAL}, {@link GL_MAP1_TEXTURE_COORD_1}, {@link GL_MAP1_TEXTURE_COORD_2}, {@link GL_MAP1_TEXTURE_COORD_3}, and {@link GL_MAP1_TEXTURE_COORD_4} are accepted.
 * @param u1 Specifies a linear mapping of 𝐮, as presented to {@link glEvalCoord1}, to *û*, the variable that is evaluated by the equations specified by this command.
 * @param u2 Specifies a linear mapping of 𝐮, as presented to {@link glEvalCoord1}, to *û*, the variable that is evaluated by the equations specified by this command.
 * @param stride Specifies the number of floats or doubles between the beginning of one control point and the beginning of the next one in the data structure referenced in **points**. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations.
 * @param order Specifies the number of control points. Must be positive.
 * @param points Specifies a pointer to the array of control points.
 * @see [glMap1](https://docs.gl/gl3/glMap1)
 */
export function glMap1f(
	target: GLenum,
	u1: GLfloat,
	u2: GLfloat,
	stride: GLint,
	order: GLint,
	points: GLfloat | GLfloat[]
): void;

/**
 * Evaluators provide a way to use polynomial or rational polynomial mapping to produce vertices, normals, texture coordinates, and colors. The values produced by an evaluator are sent on to further stages of GL processing just as if they had been presented using {@link glVertex}, {@link glNormal}, {@link glTexCoord}, and {@link glColor} commands, except that the generated values do not update the current normal, texture coordinates, or color.
 *
 * All polynomial or rational polynomial splines of any degree (up to the maximum degree supported by the GL implementation) can be described using evaluators. These include almost all surfaces used in computer graphics, including B-spline surfaces, NURBS surfaces, Bezier surfaces, and so on.
 *
 * `glMap2` is used to define the basis and to specify what kind of values are produced. Once defined, a map can be enabled and disabled by calling {@link glEnable} and {@link glDisable} with the map name, one of the nine predefined values for **target**, described below. When {@link glEvalCoord2} presents values 𝐮 and 𝐯, the bivariate Bernstein polynomials are evaluated using û and v̂, where
 *
 * û = (𝐮 − 𝐮1 / 𝐮2 − 𝐮1)
 *
 * v̂ = (𝐯 − 𝐯1 / 𝐯2 − 𝐯1)
 *
 * **target** is a symbolic constant that indicates what kind of control points are provided in **points**, and what output is generated when the map is evaluated. It can assume one of nine predefined values:
 *
 * - {@link GL_MAP2_VERTEX_3}
 * Each control point is three floating-point values representing 𝐱, 𝐲 and 𝐳. Internal {@link glVertex3} commands are generated when the map is evaluated.
 *
 * - {@link GL_MAP2_VERTEX_4}
 * Each control point is four floating-point values representing 𝐱, 𝐲, 𝐳 and 𝐰. Internal {@link glVertex4} commands are generated when the map is evaluated.
 *
 * - {@link GL_MAP2_INDEX}
 * Each control point is a single floating-point value representing a color index. Internal {@link glIndex} commands are generated when the map is evaluated but the current index is not updated with the value of these {@link glIndex} commands.
 *
 * - {@link GL_MAP2_COLOR_4}
 * Each control point is four floating-point values representing red, green, blue, and alpha. Internal {@link glColor4} commands are generated when the map is evaluated but the current color is not updated with the value of these {@link glColor4} commands.
 *
 * - {@link GL_MAP2_NORMAL}
 * Each control point is three floating-point values representing the 𝐱, 𝐲 and 𝐳 components of a normal vector. Internal {@link glNormal} commands are generated when the map is evaluated but the current normal is not updated with the value of these {@link glNormal} commands.
 *
 * - {@link GL_MAP2_TEXTURE_COORD_1}
 * Each control point is a single floating-point value representing the 𝐬 texture coordinate. Internal {@link glTexCoord1} commands are generated when the map is evaluated but the current texture coordinates are not updated with the value of these {@link glTexCoord} commands.
 *
 * - {@link GL_MAP2_TEXTURE_COORD_2}
 * Each control point is two floating-point values representing the 𝐬 and 𝐭 texture coordinates. Internal {@link glTexCoord2} commands are generated when the map is evaluated but the current texture coordinates are not updated with the value of these {@link glTexCoord} commands.
 *
 * - {@link GL_MAP2_TEXTURE_COORD_3}
 * Each control point is three floating-point values representing the 𝐬, 𝐭 and 𝐫 texture coordinates. Internal {@link glTexCoord3} commands are generated when the map is evaluated but the current texture coordinates are not updated with the value of these {@link glTexCoord} commands.
 *
 * - {@link GL_MAP2_TEXTURE_COORD_4}
 * Each control point is four floating-point values representing the 𝐬, 𝐭, 𝐫 and 𝐪 texture coordinates. Internal {@link glTexCoord4} commands are generated when the map is evaluated but the current texture coordinates are not updated with the value of these {@link glTexCoord} commands.
 *
 * **ustride**, **uorder**, **vstride**, **vorder**, and **points** define the array addressing for accessing the control points. **points** is the location of the first control point, which occupies one, two, three, or four contiguous memory locations, depending on which map is being defined. There are *uorder* × *vorder* control points in the array. **ustride** specifies how many float or double locations are skipped to advance the internal memory pointer from control point 𝐑ᵢⱼ to control point 𝐑₍ᵢ₊₁₎ⱼ. **vstride** specifies how many float or double locations are skipped to advance the internal memory pointer from control point 𝐑ᵢⱼ to control point 𝐑ᵢ₍ⱼ₊₁₎.
 *
 * @summary define a two-dimensional evaluator
 * @param target Specifies the kind of values that are generated by the evaluator. Symbolic constants {@link GL_MAP2_VERTEX_3}, {@link GL_MAP2_VERTEX_4}, {@link GL_MAP2_INDEX}, {@link GL_MAP2_COLOR_4}, {@link GL_MAP2_NORMAL}, {@link GL_MAP2_TEXTURE_COORD_1}, {@link GL_MAP2_TEXTURE_COORD_2}, {@link GL_MAP2_TEXTURE_COORD_3}, and {@link GL_MAP2_TEXTURE_COORD_4} are accepted.
 * @param u1 Specifies a linear mapping of 𝐮, as presented to {@link glEvalCoord2}, to û, one of the two variables that are evaluated by the equations specified by this command. Initially, **u1** is 0.
 * @param u2 Specifies a linear mapping of 𝐮, as presented to {@link glEvalCoord2}, to û, one of the two variables that are evaluated by the equations specified by this command. Initially, **u2** is 1.
 * @param ustride Specifies the number of floats or doubles between the beginning of control point 𝐑ᵢⱼ and the beginning of control point 𝐑₍ᵢ₊₁₎ⱼ, where 𝐢 and 𝐣 are the 𝐮 and 𝐯 control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of **ustride** is 0.
 * @param uorder Specifies the dimension of the control point array in the 𝐮 axis. Must be positive. The initial value is 1.
 * @param v1 Specifies a linear mapping of 𝐯, as presented to {@link glEvalCoord2}, to v̂, one of the two variables that are evaluated by the equations specified by this command. Initially, **v1** is 0.
 * @param v2 Specifies a linear mapping of 𝐯, as presented to {@link glEvalCoord2}, to v̂, one of the two variables that are evaluated by the equations specified by this command. Initially, **v2** is 1.
 * @param vstride Specifies the number of floats or doubles between the beginning of control point 𝐑ᵢⱼ and the beginning of control point 𝐑ᵢ₍ⱼ₊₁₎, where 𝐢 and 𝐣 are the 𝐮 and 𝐯 control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of **vstride** is 0.
 * @param vorder Specifies the dimension of the control point array in the 𝐯 axis. Must be positive. The initial value is 1.
 * @param points Specifies a pointer to the array of control points.
 * @see [glMap2](https://docs.gl/gl3/glMap2)
 */
export function glMap2d(
	target: GLenum,
	u1: GLdouble,
	u2: GLdouble,
	ustride: GLint,
	uorder: GLint,
	v1: GLdouble,
	v2: GLdouble,
	vstride: GLint,
	vorder: GLint,
	points: GLdouble | GLdouble[]
): void;

/**
 * Evaluators provide a way to use polynomial or rational polynomial mapping to produce vertices, normals, texture coordinates, and colors. The values produced by an evaluator are sent on to further stages of GL processing just as if they had been presented using {@link glVertex}, {@link glNormal}, {@link glTexCoord}, and {@link glColor} commands, except that the generated values do not update the current normal, texture coordinates, or color.
 *
 * All polynomial or rational polynomial splines of any degree (up to the maximum degree supported by the GL implementation) can be described using evaluators. These include almost all surfaces used in computer graphics, including B-spline surfaces, NURBS surfaces, Bezier surfaces, and so on.
 *
 * `glMap2` is used to define the basis and to specify what kind of values are produced. Once defined, a map can be enabled and disabled by calling {@link glEnable} and {@link glDisable} with the map name, one of the nine predefined values for **target**, described below. When {@link glEvalCoord2} presents values 𝐮 and 𝐯, the bivariate Bernstein polynomials are evaluated using û and v̂, where
 *
 * û = (𝐮 − 𝐮1 / 𝐮2 − 𝐮1)
 *
 * v̂ = (𝐯 − 𝐯1 / 𝐯2 − 𝐯1)
 *
 * **target** is a symbolic constant that indicates what kind of control points are provided in **points**, and what output is generated when the map is evaluated. It can assume one of nine predefined values:
 *
 * - {@link GL_MAP2_VERTEX_3}
 * Each control point is three floating-point values representing 𝐱, 𝐲 and 𝐳. Internal {@link glVertex3} commands are generated when the map is evaluated.
 *
 * - {@link GL_MAP2_VERTEX_4}
 * Each control point is four floating-point values representing 𝐱, 𝐲, 𝐳 and 𝐰. Internal {@link glVertex4} commands are generated when the map is evaluated.
 *
 * - {@link GL_MAP2_INDEX}
 * Each control point is a single floating-point value representing a color index. Internal {@link glIndex} commands are generated when the map is evaluated but the current index is not updated with the value of these {@link glIndex} commands.
 *
 * - {@link GL_MAP2_COLOR_4}
 * Each control point is four floating-point values representing red, green, blue, and alpha. Internal {@link glColor4} commands are generated when the map is evaluated but the current color is not updated with the value of these {@link glColor4} commands.
 *
 * - {@link GL_MAP2_NORMAL}
 * Each control point is three floating-point values representing the 𝐱, 𝐲 and 𝐳 components of a normal vector. Internal {@link glNormal} commands are generated when the map is evaluated but the current normal is not updated with the value of these {@link glNormal} commands.
 *
 * - {@link GL_MAP2_TEXTURE_COORD_1}
 * Each control point is a single floating-point value representing the 𝐬 texture coordinate. Internal {@link glTexCoord1} commands are generated when the map is evaluated but the current texture coordinates are not updated with the value of these {@link glTexCoord} commands.
 *
 * - {@link GL_MAP2_TEXTURE_COORD_2}
 * Each control point is two floating-point values representing the 𝐬 and 𝐭 texture coordinates. Internal {@link glTexCoord2} commands are generated when the map is evaluated but the current texture coordinates are not updated with the value of these {@link glTexCoord} commands.
 *
 * - {@link GL_MAP2_TEXTURE_COORD_3}
 * Each control point is three floating-point values representing the 𝐬, 𝐭 and 𝐫 texture coordinates. Internal {@link glTexCoord3} commands are generated when the map is evaluated but the current texture coordinates are not updated with the value of these {@link glTexCoord} commands.
 *
 * - {@link GL_MAP2_TEXTURE_COORD_4}
 * Each control point is four floating-point values representing the 𝐬, 𝐭, 𝐫 and 𝐪 texture coordinates. Internal {@link glTexCoord4} commands are generated when the map is evaluated but the current texture coordinates are not updated with the value of these {@link glTexCoord} commands.
 *
 * **ustride**, **uorder**, **vstride**, **vorder**, and **points** define the array addressing for accessing the control points. **points** is the location of the first control point, which occupies one, two, three, or four contiguous memory locations, depending on which map is being defined. There are *uorder* × *vorder* control points in the array. **ustride** specifies how many float or double locations are skipped to advance the internal memory pointer from control point 𝐑ᵢⱼ to control point 𝐑₍ᵢ₊₁₎ⱼ. **vstride** specifies how many float or double locations are skipped to advance the internal memory pointer from control point 𝐑ᵢⱼ to control point 𝐑ᵢ₍ⱼ₊₁₎.
 *
 * @summary define a two-dimensional evaluator
 * @param target Specifies the kind of values that are generated by the evaluator. Symbolic constants {@link GL_MAP2_VERTEX_3}, {@link GL_MAP2_VERTEX_4}, {@link GL_MAP2_INDEX}, {@link GL_MAP2_COLOR_4}, {@link GL_MAP2_NORMAL}, {@link GL_MAP2_TEXTURE_COORD_1}, {@link GL_MAP2_TEXTURE_COORD_2}, {@link GL_MAP2_TEXTURE_COORD_3}, and {@link GL_MAP2_TEXTURE_COORD_4} are accepted.
 * @param u1 Specifies a linear mapping of 𝐮, as presented to {@link glEvalCoord2}, to û, one of the two variables that are evaluated by the equations specified by this command. Initially, **u1** is 0.
 * @param u2 Specifies a linear mapping of 𝐮, as presented to {@link glEvalCoord2}, to û, one of the two variables that are evaluated by the equations specified by this command. Initially, **u2** is 1.
 * @param ustride Specifies the number of floats or doubles between the beginning of control point 𝐑ᵢⱼ and the beginning of control point 𝐑₍ᵢ₊₁₎ⱼ, where 𝐢 and 𝐣 are the 𝐮 and 𝐯 control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of **ustride** is 0.
 * @param uorder Specifies the dimension of the control point array in the 𝐮 axis. Must be positive. The initial value is 1.
 * @param v1 Specifies a linear mapping of 𝐯, as presented to {@link glEvalCoord2}, to v̂, one of the two variables that are evaluated by the equations specified by this command. Initially, **v1** is 0.
 * @param v2 Specifies a linear mapping of 𝐯, as presented to {@link glEvalCoord2}, to v̂, one of the two variables that are evaluated by the equations specified by this command. Initially, **v2** is 1.
 * @param vstride Specifies the number of floats or doubles between the beginning of control point 𝐑ᵢⱼ and the beginning of control point 𝐑ᵢ₍ⱼ₊₁₎, where 𝐢 and 𝐣 are the 𝐮 and 𝐯 control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of **vstride** is 0.
 * @param vorder Specifies the dimension of the control point array in the 𝐯 axis. Must be positive. The initial value is 1.
 * @param points Specifies a pointer to the array of control points.
 * @see [glMap2](https://docs.gl/gl3/glMap2)
 */
export function glMap2f(
	target: GLenum,
	u1: GLfloat,
	u2: GLfloat,
	ustride: GLint,
	uorder: GLint,
	v1: GLfloat,
	v2: GLfloat,
	vstride: GLint,
	vorder: GLint,
	points: GLfloat | GLfloat[]
): void;

/**
 * `glMapGrid` and {@link glEvalMesh} are used together to efficiently generate and evaluate a series of evenly-spaced map domain values. {@link glEvalMesh} steps through the integer domain of a one- or two-dimensional grid, whose range is the domain of the evaluation maps specified by {@link glMap1} and {@link glMap2}.
 *
 * `glMapGrid1` and `glMapGrid2` specify the linear grid mappings between the 𝐢 (or 𝐢 and 𝐣) integer grid coordinates, to the 𝐮 (or 𝐮 and 𝐯) floating-point evaluation map coordinates. See {@link glMap1} and {@link glMap2} for details of how 𝐮 and 𝐯 coordinates are evaluated.
 *
 * `glMapGrid1` specifies a single linear mapping such that integer grid coordinate 0 maps exactly to **u1**, and integer grid coordinate **un** maps exactly to **u2**. All other integer grid coordinates 𝐢 are mapped so that
 *
 * 𝐮 = 𝐢(𝐮2 - 𝐮1) / 𝐮𝐧 + 𝐮1
 *
 * `glMapGrid2` specifies two such linear mappings. One maps integer grid coordinate 𝐢 = 0 exactly to **u1**, and integer grid coordinate 𝐢 = 𝐮𝐧 exactly to **u2**. The other maps integer grid coordinate 𝐣 = 0 exactly to **v1**, and integer grid coordinate 𝐣 = 𝐯𝐧 exactly to **v2**. Other integer grid coordinates 𝐢 and 𝐣 are mapped such that
 *
 * 𝐮 = 𝐢(𝐮2 - 𝐮1) / 𝐮𝐧 + 𝐮1
 *
 * 𝐯 = 𝐣(𝐯2 - 𝐯1) / 𝐯𝐧 + 𝐯1
 *
 * The mappings specified by `glMapGrid` are used identically by {@link glEvalMesh} and {@link glEvalPoint}.
 *
 * @summary define a one- or two-dimensional mesh
 * @param un Specifies the number of partitions in the grid range interval [**u1**, **u2**]. Must be positive.
 * @param u1 Specifies the mappings for integer grid domain values 𝐢 = 0 and 𝐢 = 𝐮𝐧.
 * @param u2 Specifies the mappings for integer grid domain values 𝐢 = 0 and 𝐢 = 𝐮𝐧.
 * @see [glMapGrid](https://docs.gl/gl3/glMapGrid)
 */
export function glMapGrid1d(un: GLint, u1: GLdouble, u2: GLdouble): void;

/**
 * `glMapGrid` and {@link glEvalMesh} are used together to efficiently generate and evaluate a series of evenly-spaced map domain values. {@link glEvalMesh} steps through the integer domain of a one- or two-dimensional grid, whose range is the domain of the evaluation maps specified by {@link glMap1} and {@link glMap2}.
 *
 * `glMapGrid1` and `glMapGrid2` specify the linear grid mappings between the 𝐢 (or 𝐢 and 𝐣) integer grid coordinates, to the 𝐮 (or 𝐮 and 𝐯) floating-point evaluation map coordinates. See {@link glMap1} and {@link glMap2} for details of how 𝐮 and 𝐯 coordinates are evaluated.
 *
 * `glMapGrid1` specifies a single linear mapping such that integer grid coordinate 0 maps exactly to **u1**, and integer grid coordinate **un** maps exactly to **u2**. All other integer grid coordinates 𝐢 are mapped so that
 *
 * 𝐮 = 𝐢(𝐮2 - 𝐮1) / 𝐮𝐧 + 𝐮1
 *
 * `glMapGrid2` specifies two such linear mappings. One maps integer grid coordinate 𝐢 = 0 exactly to **u1**, and integer grid coordinate 𝐢 = 𝐮𝐧 exactly to **u2**. The other maps integer grid coordinate 𝐣 = 0 exactly to **v1**, and integer grid coordinate 𝐣 = 𝐯𝐧 exactly to **v2**. Other integer grid coordinates 𝐢 and 𝐣 are mapped such that
 *
 * 𝐮 = 𝐢(𝐮2 - 𝐮1) / 𝐮𝐧 + 𝐮1
 *
 * 𝐯 = 𝐣(𝐯2 - 𝐯1) / 𝐯𝐧 + 𝐯1
 *
 * The mappings specified by `glMapGrid` are used identically by {@link glEvalMesh} and {@link glEvalPoint}.
 *
 * @summary define a one- or two-dimensional mesh
 * @param un Specifies the number of partitions in the grid range interval [**u1**, **u2**]. Must be positive.
 * @param u1 Specifies the mappings for integer grid domain values 𝐢 = 0 and 𝐢 = 𝐮𝐧.
 * @param u2 Specifies the mappings for integer grid domain values 𝐢 = 0 and 𝐢 = 𝐮𝐧.
 * @see [glMapGrid](https://docs.gl/gl3/glMapGrid)
 */
export function glMapGrid1f(un: GLint, u1: GLfloat, u2: GLfloat): void;

/**
 * `glMapGrid` and {@link glEvalMesh} are used together to efficiently generate and evaluate a series of evenly-spaced map domain values. {@link glEvalMesh} steps through the integer domain of a one- or two-dimensional grid, whose range is the domain of the evaluation maps specified by {@link glMap1} and {@link glMap2}.
 *
 * `glMapGrid1` and `glMapGrid2` specify the linear grid mappings between the 𝐢 (or 𝐢 and 𝐣) integer grid coordinates, to the 𝐮 (or 𝐮 and 𝐯) floating-point evaluation map coordinates. See {@link glMap1} and {@link glMap2} for details of how 𝐮 and 𝐯 coordinates are evaluated.
 *
 * `glMapGrid1` specifies a single linear mapping such that integer grid coordinate 0 maps exactly to **u1**, and integer grid coordinate **un** maps exactly to **u2**. All other integer grid coordinates 𝐢 are mapped so that
 *
 * 𝐮 = 𝐢(𝐮2 - 𝐮1) / 𝐮𝐧 + 𝐮1
 *
 * `glMapGrid2` specifies two such linear mappings. One maps integer grid coordinate 𝐢 = 0 exactly to **u1**, and integer grid coordinate 𝐢 = 𝐮𝐧 exactly to **u2**. The other maps integer grid coordinate 𝐣 = 0 exactly to **v1**, and integer grid coordinate 𝐣 = 𝐯𝐧 exactly to **v2**. Other integer grid coordinates 𝐢 and 𝐣 are mapped such that
 *
 * 𝐮 = 𝐢(𝐮2 - 𝐮1) / 𝐮𝐧 + 𝐮1
 *
 * 𝐯 = 𝐣(𝐯2 - 𝐯1) / 𝐯𝐧 + 𝐯1
 *
 * The mappings specified by `glMapGrid` are used identically by {@link glEvalMesh} and {@link glEvalPoint}.
 *
 * @summary define a one- or two-dimensional mesh
 * @param un Specifies the number of partitions in the grid range interval [**u1**, **u2**]. Must be positive.
 * @param u1 Specifies the mappings for integer grid domain values 𝐢 = 0 and 𝐢 = 𝐮𝐧.
 * @param u2 Specifies the mappings for integer grid domain values 𝐢 = 0 and 𝐢 = 𝐮𝐧.
 * @param vn Specifies the number of partitions in the grid range interval [**v1**, **v2**]. Must be positive.
 * @param v1 Specifies the mappings for integer grid domain values 𝐣 = 0 and 𝐣 = 𝐯𝐧.
 * @param v2 Specifies the mappings for integer grid domain values 𝐣 = 0 and 𝐣 = 𝐯𝐧.
 * @see [glMapGrid](https://docs.gl/gl3/glMapGrid)
 */
export function glMapGrid2d(
	un: GLint,
	u1: GLdouble,
	u2: GLdouble,
	vn: GLint,
	v1: GLdouble,
	v2: GLdouble
): void;

/**
 * `glMapGrid` and {@link glEvalMesh} are used together to efficiently generate and evaluate a series of evenly-spaced map domain values. {@link glEvalMesh} steps through the integer domain of a one- or two-dimensional grid, whose range is the domain of the evaluation maps specified by {@link glMap1} and {@link glMap2}.
 *
 * `glMapGrid1` and `glMapGrid2` specify the linear grid mappings between the 𝐢 (or 𝐢 and 𝐣) integer grid coordinates, to the 𝐮 (or 𝐮 and 𝐯) floating-point evaluation map coordinates. See {@link glMap1} and {@link glMap2} for details of how 𝐮 and 𝐯 coordinates are evaluated.
 *
 * `glMapGrid1` specifies a single linear mapping such that integer grid coordinate 0 maps exactly to **u1**, and integer grid coordinate **un** maps exactly to **u2**. All other integer grid coordinates 𝐢 are mapped so that
 *
 * 𝐮 = 𝐢(𝐮2 - 𝐮1) / 𝐮𝐧 + 𝐮1
 *
 * `glMapGrid2` specifies two such linear mappings. One maps integer grid coordinate 𝐢 = 0 exactly to **u1**, and integer grid coordinate 𝐢 = 𝐮𝐧 exactly to **u2**. The other maps integer grid coordinate 𝐣 = 0 exactly to **v1**, and integer grid coordinate 𝐣 = 𝐯𝐧 exactly to **v2**. Other integer grid coordinates 𝐢 and 𝐣 are mapped such that
 *
 * 𝐮 = 𝐢(𝐮2 - 𝐮1) / 𝐮𝐧 + 𝐮1
 *
 * 𝐯 = 𝐣(𝐯2 - 𝐯1) / 𝐯𝐧 + 𝐯1
 *
 * The mappings specified by `glMapGrid` are used identically by {@link glEvalMesh} and {@link glEvalPoint}.
 *
 * @summary define a one- or two-dimensional mesh
 * @param un Specifies the number of partitions in the grid range interval [**u1**, **u2**]. Must be positive.
 * @param u1 Specifies the mappings for integer grid domain values 𝐢 = 0 and 𝐢 = 𝐮𝐧.
 * @param u2 Specifies the mappings for integer grid domain values 𝐢 = 0 and 𝐢 = 𝐮𝐧.
 * @param vn Specifies the number of partitions in the grid range interval [**v1**, **v2**]. Must be positive.
 * @param v1 Specifies the mappings for integer grid domain values 𝐣 = 0 and 𝐣 = 𝐯𝐧.
 * @param v2 Specifies the mappings for integer grid domain values 𝐣 = 0 and 𝐣 = 𝐯𝐧.
 * @see [glMapGrid](https://docs.gl/gl3/glMapGrid)
 */
export function glMapGrid2f(
	un: GLint,
	u1: GLfloat,
	u2: GLfloat,
	vn: GLint,
	v1: GLfloat,
	v2: GLfloat
): void;

/**
 * `glMaterial` assigns values to material parameters. There are two matched sets of material parameters. One, the **front-facing** set, is used to shade points, lines, bitmaps, and all polygons (when two-sided lighting is disabled), or just front-facing polygons (when two-sided lighting is enabled). The other set, **back-facing**, is used to shade back-facing polygons only when two-sided lighting is enabled. Refer to the {@link glLightModel} reference page for details concerning one- and two-sided lighting calculations.
 *
 * `glMaterial` takes three arguments. The first, **face**, specifies whether the {@link GL_FRONT} materials, the {@link GL_BACK} materials, or both {@link GL_FRONT_AND_BACK} materials will be modified. The second, **pname**, specifies which of several parameters in one or both sets will be modified. The third, **params**, specifies what value or values will be assigned to the specified parameter.
 *
 * Material parameters are used in the lighting equation that is optionally applied to each vertex. The equation is discussed in the {@link glLightModel} reference page. The parameters that can be specified using `glMaterial`, and their interpretations by the lighting equation, are as follows:
 *
 * - {@link GL_AMBIENT}
 * **params** contains four integer or floating-point values that specify the ambient RGBA reflectance of the material. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial ambient reflectance for both front- and back-facing materials is (0.2, 0.2, 0.2, 1.0).
 *
 * - {@link GL_DIFFUSE}
 * **params** contains four integer or floating-point values that specify the diffuse RGBA reflectance of the material. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial diffuse reflectance for both front- and back-facing materials is (0.8, 0.8, 0.8, 1.0).
 *
 * - {@link GL_SPECULAR}
 * **params** contains four integer or floating-point values that specify the specular RGBA reflectance of the material. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial specular reflectance for both front- and back-facing materials is (0, 0, 0, 1).
 *
 * - {@link GL_EMISSION}
 * **params** contains four integer or floating-point values that specify the RGBA emitted light intensity of the material. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial emission intensity for both front- and back-facing materials is (0, 0, 0, 1).
 *
 * - {@link GL_SHININESS}
 * **params** is a single integer or floating-point value that specifies the RGBA specular exponent of the material. Integer and floating-point values are mapped directly. Only values in the range [0,128] are accepted. The initial specular exponent for both front- and back-facing materials is 0.
 *
 * - {@link GL_AMBIENT_AND_DIFFUSE}
 * Equivalent to calling `glMaterial` twice with the same parameter values, once with {@link GL_AMBIENT} and once with {@link GL_DIFFUSE}.
 *
 * - {@link GL_COLOR_INDEXES}
 * **params** contains three integer or floating-point values specifying the color indices for ambient, diffuse, and specular lighting. These three values, and {@link GL_SHININESS}, are the only material values used by the color index mode lighting equation. Refer to the {@link glLightModel} reference page for a discussion of color index lighting.
 *
 * @summary specify material parameters for the lighting model
 * @param face Specifies which face or faces are being updated. Must be one of {@link GL_FRONT}, {@link GL_BACK}, or {@link GL_FRONT_AND_BACK}.
 * @param pname Specifies the single-valued material parameter of the face or faces that is being updated. Must be {@link GL_SHININESS}.
 * @param param Specifies the value that parameter {@link GL_SHININESS} will be set to.
 * @see [glMaterial](https://docs.gl/gl3/glMaterial)
 */
export function glMaterialf(face: GLenum, pname: GLenum, param: GLfloat): void;

/**
 * `glMaterial` assigns values to material parameters. There are two matched sets of material parameters. One, the **front-facing** set, is used to shade points, lines, bitmaps, and all polygons (when two-sided lighting is disabled), or just front-facing polygons (when two-sided lighting is enabled). The other set, **back-facing**, is used to shade back-facing polygons only when two-sided lighting is enabled. Refer to the {@link glLightModel} reference page for details concerning one- and two-sided lighting calculations.
 *
 * `glMaterial` takes three arguments. The first, **face**, specifies whether the {@link GL_FRONT} materials, the {@link GL_BACK} materials, or both {@link GL_FRONT_AND_BACK} materials will be modified. The second, **pname**, specifies which of several parameters in one or both sets will be modified. The third, **params**, specifies what value or values will be assigned to the specified parameter.
 *
 * Material parameters are used in the lighting equation that is optionally applied to each vertex. The equation is discussed in the {@link glLightModel} reference page. The parameters that can be specified using `glMaterial`, and their interpretations by the lighting equation, are as follows:
 *
 * - {@link GL_AMBIENT}
 * **params** contains four integer or floating-point values that specify the ambient RGBA reflectance of the material. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial ambient reflectance for both front- and back-facing materials is (0.2, 0.2, 0.2, 1.0).
 *
 * - {@link GL_DIFFUSE}
 * **params** contains four integer or floating-point values that specify the diffuse RGBA reflectance of the material. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial diffuse reflectance for both front- and back-facing materials is (0.8, 0.8, 0.8, 1.0).
 *
 * - {@link GL_SPECULAR}
 * **params** contains four integer or floating-point values that specify the specular RGBA reflectance of the material. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial specular reflectance for both front- and back-facing materials is (0, 0, 0, 1).
 *
 * - {@link GL_EMISSION}
 * **params** contains four integer or floating-point values that specify the RGBA emitted light intensity of the material. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial emission intensity for both front- and back-facing materials is (0, 0, 0, 1).
 *
 * - {@link GL_SHININESS}
 * **params** is a single integer or floating-point value that specifies the RGBA specular exponent of the material. Integer and floating-point values are mapped directly. Only values in the range [0,128] are accepted. The initial specular exponent for both front- and back-facing materials is 0.
 *
 * - {@link GL_AMBIENT_AND_DIFFUSE}
 * Equivalent to calling `glMaterial` twice with the same parameter values, once with {@link GL_AMBIENT} and once with {@link GL_DIFFUSE}.
 *
 * - {@link GL_COLOR_INDEXES}
 * **params** contains three integer or floating-point values specifying the color indices for ambient, diffuse, and specular lighting. These three values, and {@link GL_SHININESS}, are the only material values used by the color index mode lighting equation. Refer to the {@link glLightModel} reference page for a discussion of color index lighting.
 *
 * @summary specify material parameters for the lighting model
 * @param face Specifies which face or faces are being updated. Must be one of {@link GL_FRONT}, {@link GL_BACK}, or {@link GL_FRONT_AND_BACK}.
 * @param pname Specifies the single-valued material parameter of the face or faces that is being updated. Must be {@link GL_SHININESS}.
 * @param param Specifies the value that parameter {@link GL_SHININESS} will be set to.
 * @see [glMaterial](https://docs.gl/gl3/glMaterial)
 */
export function glMateriali(face: GLenum, pname: GLenum, param: GLint): void;

/**
 * `glMaterial` assigns values to material parameters. There are two matched sets of material parameters. One, the **front-facing** set, is used to shade points, lines, bitmaps, and all polygons (when two-sided lighting is disabled), or just front-facing polygons (when two-sided lighting is enabled). The other set, **back-facing**, is used to shade back-facing polygons only when two-sided lighting is enabled. Refer to the {@link glLightModel} reference page for details concerning one- and two-sided lighting calculations.
 *
 * `glMaterial` takes three arguments. The first, **face**, specifies whether the {@link GL_FRONT} materials, the {@link GL_BACK} materials, or both {@link GL_FRONT_AND_BACK} materials will be modified. The second, **pname**, specifies which of several parameters in one or both sets will be modified. The third, **params**, specifies what value or values will be assigned to the specified parameter.
 *
 * Material parameters are used in the lighting equation that is optionally applied to each vertex. The equation is discussed in the {@link glLightModel} reference page. The parameters that can be specified using `glMaterial`, and their interpretations by the lighting equation, are as follows:
 *
 * - {@link GL_AMBIENT}
 * **params** contains four integer or floating-point values that specify the ambient RGBA reflectance of the material. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial ambient reflectance for both front- and back-facing materials is (0.2, 0.2, 0.2, 1.0).
 *
 * - {@link GL_DIFFUSE}
 * **params** contains four integer or floating-point values that specify the diffuse RGBA reflectance of the material. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial diffuse reflectance for both front- and back-facing materials is (0.8, 0.8, 0.8, 1.0).
 *
 * - {@link GL_SPECULAR}
 * **params** contains four integer or floating-point values that specify the specular RGBA reflectance of the material. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial specular reflectance for both front- and back-facing materials is (0, 0, 0, 1).
 *
 * - {@link GL_EMISSION}
 * **params** contains four integer or floating-point values that specify the RGBA emitted light intensity of the material. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial emission intensity for both front- and back-facing materials is (0, 0, 0, 1).
 *
 * - {@link GL_SHININESS}
 * **params** is a single integer or floating-point value that specifies the RGBA specular exponent of the material. Integer and floating-point values are mapped directly. Only values in the range [0,128] are accepted. The initial specular exponent for both front- and back-facing materials is 0.
 *
 * - {@link GL_AMBIENT_AND_DIFFUSE}
 * Equivalent to calling `glMaterial` twice with the same parameter values, once with {@link GL_AMBIENT} and once with {@link GL_DIFFUSE}.
 *
 * - {@link GL_COLOR_INDEXES}
 * **params** contains three integer or floating-point values specifying the color indices for ambient, diffuse, and specular lighting. These three values, and {@link GL_SHININESS}, are the only material values used by the color index mode lighting equation. Refer to the {@link glLightModel} reference page for a discussion of color index lighting.
 *
 * @summary specify material parameters for the lighting model
 * @param face Specifies which face or faces are being updated. Must be one of {@link GL_FRONT}, {@link GL_BACK}, or {@link GL_FRONT_AND_BACK}.
 * @param pname Specifies the material parameter of the face or faces that is being updated. Must be one of {@link GL_AMBIENT}, {@link GL_DIFFUSE}, {@link GL_SPECULAR}, {@link GL_EMISSION}, {@link GL_SHININESS}, {@link GL_AMBIENT_AND_DIFFUSE}, or {@link GL_COLOR_INDEXES}.
 * @param params Specifies a pointer to the value or values that **pname** will be set to.
 * @see [glMaterial](https://docs.gl/gl3/glMaterial)
 */
export function glMaterialfv(
	face: GLenum,
	pname: GLenum,
	params: GLfloat | GLfloat[]
): void;

/**
 * `glMaterial` assigns values to material parameters. There are two matched sets of material parameters. One, the **front-facing** set, is used to shade points, lines, bitmaps, and all polygons (when two-sided lighting is disabled), or just front-facing polygons (when two-sided lighting is enabled). The other set, **back-facing**, is used to shade back-facing polygons only when two-sided lighting is enabled. Refer to the {@link glLightModel} reference page for details concerning one- and two-sided lighting calculations.
 *
 * `glMaterial` takes three arguments. The first, **face**, specifies whether the {@link GL_FRONT} materials, the {@link GL_BACK} materials, or both {@link GL_FRONT_AND_BACK} materials will be modified. The second, **pname**, specifies which of several parameters in one or both sets will be modified. The third, **params**, specifies what value or values will be assigned to the specified parameter.
 *
 * Material parameters are used in the lighting equation that is optionally applied to each vertex. The equation is discussed in the {@link glLightModel} reference page. The parameters that can be specified using `glMaterial`, and their interpretations by the lighting equation, are as follows:
 *
 * - {@link GL_AMBIENT}
 * **params** contains four integer or floating-point values that specify the ambient RGBA reflectance of the material. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial ambient reflectance for both front- and back-facing materials is (0.2, 0.2, 0.2, 1.0).
 *
 * - {@link GL_DIFFUSE}
 * **params** contains four integer or floating-point values that specify the diffuse RGBA reflectance of the material. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial diffuse reflectance for both front- and back-facing materials is (0.8, 0.8, 0.8, 1.0).
 *
 * - {@link GL_SPECULAR}
 * **params** contains four integer or floating-point values that specify the specular RGBA reflectance of the material. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial specular reflectance for both front- and back-facing materials is (0, 0, 0, 1).
 *
 * - {@link GL_EMISSION}
 * **params** contains four integer or floating-point values that specify the RGBA emitted light intensity of the material. Integer values are mapped linearly such that the most positive representable value maps to 1.0, and the most negative representable value maps to −1.0. Floating-point values are mapped directly. Neither integer nor floating-point values are clamped. The initial emission intensity for both front- and back-facing materials is (0, 0, 0, 1).
 *
 * - {@link GL_SHININESS}
 * **params** is a single integer or floating-point value that specifies the RGBA specular exponent of the material. Integer and floating-point values are mapped directly. Only values in the range [0,128] are accepted. The initial specular exponent for both front- and back-facing materials is 0.
 *
 * - {@link GL_AMBIENT_AND_DIFFUSE}
 * Equivalent to calling `glMaterial` twice with the same parameter values, once with {@link GL_AMBIENT} and once with {@link GL_DIFFUSE}.
 *
 * - {@link GL_COLOR_INDEXES}
 * **params** contains three integer or floating-point values specifying the color indices for ambient, diffuse, and specular lighting. These three values, and {@link GL_SHININESS}, are the only material values used by the color index mode lighting equation. Refer to the {@link glLightModel} reference page for a discussion of color index lighting.
 *
 * @summary specify material parameters for the lighting model
 * @param face Specifies which face or faces are being updated. Must be one of {@link GL_FRONT}, {@link GL_BACK}, or {@link GL_FRONT_AND_BACK}.
 * @param pname Specifies the material parameter of the face or faces that is being updated. Must be one of {@link GL_AMBIENT}, {@link GL_DIFFUSE}, {@link GL_SPECULAR}, {@link GL_EMISSION}, {@link GL_SHININESS}, {@link GL_AMBIENT_AND_DIFFUSE}, or {@link GL_COLOR_INDEXES}.
 * @param params Specifies a pointer to the value or values that **pname** will be set to.
 * @see [glMaterial](https://docs.gl/gl3/glMaterial)
 */
export function glMaterialiv(
	face: GLenum,
	pname: GLenum,
	params: GLint | GLint[]
): void;

/**
 * `glMatrixMode` sets the current matrix mode. **mode** can assume one of four values:
 *
 * - {@link GL_MODELVIEW}
 * Applies subsequent matrix operations to the modelview matrix stack.
 *
 * - {@link GL_PROJECTION}
 * Applies subsequent matrix operations to the projection matrix stack.
 *
 * - {@link GL_TEXTURE}
 * Applies subsequent matrix operations to the texture matrix stack.
 *
 * - {@link GL_COLOR}
 * Applies subsequent matrix operations to the color matrix stack.
 *
 * To find out which matrix stack is currently the target of all matrix operations, call {@link glGet} with argument {@link GL_MATRIX_MODE}. The initial value is {@link GL_MODELVIEW}.
 *
 * @summary specify which matrix is the current matrix
 * @param mode Specifies which matrix stack is the target for subsequent matrix operations. Three values are accepted: {@link GL_MODELVIEW}, {@link GL_PROJECTION}, and {@link GL_TEXTURE}. The initial value is {@link GL_MODELVIEW}. Additionally, if the ARB_imaging extension is supported, {@link GL_COLOR} is also accepted.
 * @see [glMatrixMode](https://docs.gl/gl3/glMatrixMode)
 */
export function glMatrixMode(mode: GLenum): void;

/**
 * `glMultMatrix` multiplies the current matrix with the one specified using **m**, and replaces the current matrix with the product.
 *
 * The current matrix is determined by the current matrix mode (see {@link glMatrixMode}). It is either the projection matrix, modelview matrix, or the texture matrix.
 *
 * @summary multiply the current matrix with the specified matrix
 * @param m Points to 16 consecutive values that are used as the elements of a 4 × 4 column-major matrix.
 * @see [glMultMatrix](https://docs.gl/gl3/glMultMatrix)
 */
export function glMultMatrixd(m: GLdouble): void;

/**
 * `glMultMatrix` multiplies the current matrix with the one specified using **m**, and replaces the current matrix with the product.
 *
 * The current matrix is determined by the current matrix mode (see {@link glMatrixMode}). It is either the projection matrix, modelview matrix, or the texture matrix.
 *
 * @summary multiply the current matrix with the specified matrix
 * @param m Points to 16 consecutive values that are used as the elements of a 4 × 4 column-major matrix.
 * @see [glMultMatrix](https://docs.gl/gl3/glMultMatrix)
 */
export function glMultMatrixf(m: GLfloat): void;

/**
 * Display lists are groups of GL commands that have been stored for subsequent execution. Display lists are created with `glNewList`. All subsequent commands are placed in the display list, in the order issued, until {@link glEndList} is called.
 *
 * `glNewList` has two arguments. The first argument, **list**, is a positive integer that becomes the unique name for the display list. Names can be created and reserved with {@link glGenLists} and tested for uniqueness with {@link glIsList}. The second argument, **mode**, is a symbolic constant that can assume one of two values:
 *
 * - {@link GL_COMPILE}
 * Commands are merely compiled.
 *
 * - {@link GL_COMPILE_AND_EXECUTE}
 * Commands are executed as they are compiled into the display list.
 *
 * Certain commands are not compiled into the display list but are executed immediately, regardless of the display-list mode. These commands are {@link glAreTexturesResident}, {@link glColorPointer}, {@link glDeleteLists}, {@link glDeleteTextures}, {@link glDisableClientState}, {@link glEdgeFlagPointer}, {@link glEnableClientState}, {@link glFeedbackBuffer}, {@link glFinish}, {@link glFlush}, {@link glGenLists}, {@link glGenTextures}, {@link glIndexPointer}, {@link glInterleavedArrays}, {@link glIsEnabled}, {@link glIsList}, {@link glIsTexture}, {@link glNormalPointer}, {@link glPopClientAttrib}, {@link glPixelStore}, {@link glPushClientAttrib}, {@link glReadPixels}, {@link glRenderMode}, {@link glSelectBuffer}, {@link glTexCoordPointer}, {@link glVertexPointer}, and all of the {@link glGet} commands.
 *
 * Similarly, {@link glTexImage1D}, {@link glTexImage2D}, and {@link glTexImage3D} are executed immediately and not compiled into the display list when their first argument is {@link GL_PROXY_TEXTURE_1D}, {@link GL_PROXY_TEXTURE_1D}, or {@link GL_PROXY_TEXTURE_3D}, respectively.
 *
 * When the ARB_imaging extension is supported, {@link glHistogram} executes immediately when its argument is {@link GL_PROXY_HISTOGRAM}. Similarly, {@link glColorTable} executes immediately when its first argument is {@link GL_PROXY_COLOR_TABLE}, {@link GL_PROXY_POST_CONVOLUTION_COLOR_TABLE}, or {@link GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE}.
 *
 * For OpenGL versions 1.3 and greater, or when the ARB_multitexture extension is supported, {@link glClientActiveTexture} is not compiled into display lists, but executed immediately.
 *
 * When {@link glEndList} is encountered, the display-list definition is completed by associating the list with the unique name **list** (specified in the `glNewList` command). If a display list with name **list** already exists, it is replaced only when {@link glEndList} is called.
 *
 * @summary create or replace a display list
 * @param list Specifies the display-list name.
 * @param mode Specifies the compilation mode, which can be {@link GL_COMPILE} or {@link GL_COMPILE_AND_EXECUTE}.
 * @see [glNewList](https://docs.gl/gl3/glNewList)
 */
export function glNewList(list: GLuint, mode: GLenum): void;

/**
 * Display lists are groups of GL commands that have been stored for subsequent execution. Display lists are created with `glNewList`. All subsequent commands are placed in the display list, in the order issued, until {@link glEndList} is called.
 *
 * `glNewList` has two arguments. The first argument, **list**, is a positive integer that becomes the unique name for the display list. Names can be created and reserved with {@link glGenLists} and tested for uniqueness with {@link glIsList}. The second argument, **mode**, is a symbolic constant that can assume one of two values:
 *
 * - {@link GL_COMPILE}
 * Commands are merely compiled.
 *
 * - {@link GL_COMPILE_AND_EXECUTE}
 * Commands are executed as they are compiled into the display list.
 *
 * Certain commands are not compiled into the display list but are executed immediately, regardless of the display-list mode. These commands are {@link glAreTexturesResident}, {@link glColorPointer}, {@link glDeleteLists}, {@link glDeleteTextures}, {@link glDisableClientState}, {@link glEdgeFlagPointer}, {@link glEnableClientState}, {@link glFeedbackBuffer}, {@link glFinish}, {@link glFlush}, {@link glGenLists}, {@link glGenTextures}, {@link glIndexPointer}, {@link glInterleavedArrays}, {@link glIsEnabled}, {@link glIsList}, {@link glIsTexture}, {@link glNormalPointer}, {@link glPopClientAttrib}, {@link glPixelStore}, {@link glPushClientAttrib}, {@link glReadPixels}, {@link glRenderMode}, {@link glSelectBuffer}, {@link glTexCoordPointer}, {@link glVertexPointer}, and all of the {@link glGet} commands.
 *
 * Similarly, {@link glTexImage1D}, {@link glTexImage2D}, and {@link glTexImage3D} are executed immediately and not compiled into the display list when their first argument is {@link GL_PROXY_TEXTURE_1D}, {@link GL_PROXY_TEXTURE_1D}, or {@link GL_PROXY_TEXTURE_3D}, respectively.
 *
 * When the ARB_imaging extension is supported, {@link glHistogram} executes immediately when its argument is {@link GL_PROXY_HISTOGRAM}. Similarly, {@link glColorTable} executes immediately when its first argument is {@link GL_PROXY_COLOR_TABLE}, {@link GL_PROXY_POST_CONVOLUTION_COLOR_TABLE}, or {@link GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE}.
 *
 * For OpenGL versions 1.3 and greater, or when the ARB_multitexture extension is supported, {@link glClientActiveTexture} is not compiled into display lists, but executed immediately.
 *
 * When {@link glEndList} is encountered, the display-list definition is completed by associating the list with the unique name **list** (specified in the `glNewList` command). If a display list with name **list** already exists, it is replaced only when {@link glEndList} is called.
 *
 * @summary create or replace a display list
 * @see [glNewList](https://docs.gl/gl3/glNewList)
 */
export function glEndList();

/**
 * The current normal is set to the given coordinates whenever `glNormal` is issued. Byte, short, or integer arguments are converted to floating-point format with a linear mapping that maps the most positive representable integer value to 1.0 and the most negative representable integer value to −1.0.
 *
 * Normals specified with `glNormal` need not have unit length. If {@link GL_NORMALIZE} is enabled, then normals of any length specified with `glNormal` are normalized after transformation. If {@link GL_RESCALE_NORMAL} is enabled, normals are scaled by a scaling factor derived from the modelview matrix. {@link GL_RESCALE_NORMAL} requires that the originally specified normals were of unit length, and that the modelview matrix contain only uniform scales for proper results. To enable and disable normalization, call {@link glEnable} and {@link glDisable} with either {@link GL_NORMALIZE} or {@link GL_RESCALE_NORMAL}. Normalization is initially disabled.
 *
 * @summary set the current normal vector
 * @param x Specify the *x* coordinate of the new current normal.
 * @param y Specify the *y* coordinate of the new current normal.
 * @param z Specify the *z* coordinate of the new current normal.
 * @see [glNormal](https://docs.gl/gl3/glNormal)
 */
export function glNormal3b(x: GLbyte, y: GLbyte, z: GLbyte): void;

/**
 * The current normal is set to the given coordinates whenever `glNormal` is issued. Byte, short, or integer arguments are converted to floating-point format with a linear mapping that maps the most positive representable integer value to 1.0 and the most negative representable integer value to −1.0.
 *
 * Normals specified with `glNormal` need not have unit length. If {@link GL_NORMALIZE} is enabled, then normals of any length specified with `glNormal` are normalized after transformation. If {@link GL_RESCALE_NORMAL} is enabled, normals are scaled by a scaling factor derived from the modelview matrix. {@link GL_RESCALE_NORMAL} requires that the originally specified normals were of unit length, and that the modelview matrix contain only uniform scales for proper results. To enable and disable normalization, call {@link glEnable} and {@link glDisable} with either {@link GL_NORMALIZE} or {@link GL_RESCALE_NORMAL}. Normalization is initially disabled.
 *
 * @summary set the current normal vector
 * @param x Specify the *x* coordinate of the new current normal.
 * @param y Specify the *y* coordinate of the new current normal.
 * @param z Specify the *z* coordinate of the new current normal.
 * @see [glNormal](https://docs.gl/gl3/glNormal)
 */
export function glNormal3d(x: GLdouble, y: GLdouble, z: GLdouble): void;

/**
 * The current normal is set to the given coordinates whenever `glNormal` is issued. Byte, short, or integer arguments are converted to floating-point format with a linear mapping that maps the most positive representable integer value to 1.0 and the most negative representable integer value to −1.0.
 *
 * Normals specified with `glNormal` need not have unit length. If {@link GL_NORMALIZE} is enabled, then normals of any length specified with `glNormal` are normalized after transformation. If {@link GL_RESCALE_NORMAL} is enabled, normals are scaled by a scaling factor derived from the modelview matrix. {@link GL_RESCALE_NORMAL} requires that the originally specified normals were of unit length, and that the modelview matrix contain only uniform scales for proper results. To enable and disable normalization, call {@link glEnable} and {@link glDisable} with either {@link GL_NORMALIZE} or {@link GL_RESCALE_NORMAL}. Normalization is initially disabled.
 *
 * @summary set the current normal vector
 * @param x Specify the *x* coordinate of the new current normal.
 * @param y Specify the *y* coordinate of the new current normal.
 * @param z Specify the *z* coordinate of the new current normal.
 * @see [glNormal](https://docs.gl/gl3/glNormal)
 */
export function glNormal3f(x: GLfloat, y: GLfloat, z: GLfloat): void;

/**
 * The current normal is set to the given coordinates whenever `glNormal` is issued. Byte, short, or integer arguments are converted to floating-point format with a linear mapping that maps the most positive representable integer value to 1.0 and the most negative representable integer value to −1.0.
 *
 * Normals specified with `glNormal` need not have unit length. If {@link GL_NORMALIZE} is enabled, then normals of any length specified with `glNormal` are normalized after transformation. If {@link GL_RESCALE_NORMAL} is enabled, normals are scaled by a scaling factor derived from the modelview matrix. {@link GL_RESCALE_NORMAL} requires that the originally specified normals were of unit length, and that the modelview matrix contain only uniform scales for proper results. To enable and disable normalization, call {@link glEnable} and {@link glDisable} with either {@link GL_NORMALIZE} or {@link GL_RESCALE_NORMAL}. Normalization is initially disabled.
 *
 * @summary set the current normal vector
 * @param x Specify the *x* coordinate of the new current normal.
 * @param y Specify the *y* coordinate of the new current normal.
 * @param z Specify the *z* coordinate of the new current normal.
 * @see [glNormal](https://docs.gl/gl3/glNormal)
 */
export function glNormal3i(x: GLint, y: GLint, z: GLint): void;

/**
 * The current normal is set to the given coordinates whenever `glNormal` is issued. Byte, short, or integer arguments are converted to floating-point format with a linear mapping that maps the most positive representable integer value to 1.0 and the most negative representable integer value to −1.0.
 *
 * Normals specified with `glNormal` need not have unit length. If {@link GL_NORMALIZE} is enabled, then normals of any length specified with `glNormal` are normalized after transformation. If {@link GL_RESCALE_NORMAL} is enabled, normals are scaled by a scaling factor derived from the modelview matrix. {@link GL_RESCALE_NORMAL} requires that the originally specified normals were of unit length, and that the modelview matrix contain only uniform scales for proper results. To enable and disable normalization, call {@link glEnable} and {@link glDisable} with either {@link GL_NORMALIZE} or {@link GL_RESCALE_NORMAL}. Normalization is initially disabled.
 *
 * @summary set the current normal vector
 * @param x Specify the *x* coordinate of the new current normal.
 * @param y Specify the *y* coordinate of the new current normal.
 * @param z Specify the *z* coordinate of the new current normal.
 * @see [glNormal](https://docs.gl/gl3/glNormal)
 */
export function glNormal3s(x: GLshort, y: GLshort, z: GLshort): void;

/**
 * The current normal is set to the given coordinates whenever `glNormal` is issued. Byte, short, or integer arguments are converted to floating-point format with a linear mapping that maps the most positive representable integer value to 1.0 and the most negative representable integer value to −1.0.
 *
 * Normals specified with `glNormal` need not have unit length. If {@link GL_NORMALIZE} is enabled, then normals of any length specified with `glNormal` are normalized after transformation. If {@link GL_RESCALE_NORMAL} is enabled, normals are scaled by a scaling factor derived from the modelview matrix. {@link GL_RESCALE_NORMAL} requires that the originally specified normals were of unit length, and that the modelview matrix contain only uniform scales for proper results. To enable and disable normalization, call {@link glEnable} and {@link glDisable} with either {@link GL_NORMALIZE} or {@link GL_RESCALE_NORMAL}. Normalization is initially disabled.
 *
 * @summary set the current normal vector
 * @param v Specifies a pointer to an array of three elements: the *x*, *y*, and *z* coordinates of the new current normal.
 * @see [glNormal](https://docs.gl/gl3/glNormal)
 */
export function glNormal3bv(v: GLbyte): void;

/**
 * The current normal is set to the given coordinates whenever `glNormal` is issued. Byte, short, or integer arguments are converted to floating-point format with a linear mapping that maps the most positive representable integer value to 1.0 and the most negative representable integer value to −1.0.
 *
 * Normals specified with `glNormal` need not have unit length. If {@link GL_NORMALIZE} is enabled, then normals of any length specified with `glNormal` are normalized after transformation. If {@link GL_RESCALE_NORMAL} is enabled, normals are scaled by a scaling factor derived from the modelview matrix. {@link GL_RESCALE_NORMAL} requires that the originally specified normals were of unit length, and that the modelview matrix contain only uniform scales for proper results. To enable and disable normalization, call {@link glEnable} and {@link glDisable} with either {@link GL_NORMALIZE} or {@link GL_RESCALE_NORMAL}. Normalization is initially disabled.
 *
 * @summary set the current normal vector
 * @param v Specifies a pointer to an array of three elements: the *x*, *y*, and *z* coordinates of the new current normal.
 * @see [glNormal](https://docs.gl/gl3/glNormal)
 */
export function glNormal3dv(v: GLdouble): void;

/**
 * The current normal is set to the given coordinates whenever `glNormal` is issued. Byte, short, or integer arguments are converted to floating-point format with a linear mapping that maps the most positive representable integer value to 1.0 and the most negative representable integer value to −1.0.
 *
 * Normals specified with `glNormal` need not have unit length. If {@link GL_NORMALIZE} is enabled, then normals of any length specified with `glNormal` are normalized after transformation. If {@link GL_RESCALE_NORMAL} is enabled, normals are scaled by a scaling factor derived from the modelview matrix. {@link GL_RESCALE_NORMAL} requires that the originally specified normals were of unit length, and that the modelview matrix contain only uniform scales for proper results. To enable and disable normalization, call {@link glEnable} and {@link glDisable} with either {@link GL_NORMALIZE} or {@link GL_RESCALE_NORMAL}. Normalization is initially disabled.
 *
 * @summary set the current normal vector
 * @param v Specifies a pointer to an array of three elements: the *x*, *y*, and *z* coordinates of the new current normal.
 * @see [glNormal](https://docs.gl/gl3/glNormal)
 */
export function glNormal3fv(v: GLfloat): void;

/**
 * The current normal is set to the given coordinates whenever `glNormal` is issued. Byte, short, or integer arguments are converted to floating-point format with a linear mapping that maps the most positive representable integer value to 1.0 and the most negative representable integer value to −1.0.
 *
 * Normals specified with `glNormal` need not have unit length. If {@link GL_NORMALIZE} is enabled, then normals of any length specified with `glNormal` are normalized after transformation. If {@link GL_RESCALE_NORMAL} is enabled, normals are scaled by a scaling factor derived from the modelview matrix. {@link GL_RESCALE_NORMAL} requires that the originally specified normals were of unit length, and that the modelview matrix contain only uniform scales for proper results. To enable and disable normalization, call {@link glEnable} and {@link glDisable} with either {@link GL_NORMALIZE} or {@link GL_RESCALE_NORMAL}. Normalization is initially disabled.
 *
 * @summary set the current normal vector
 * @param v Specifies a pointer to an array of three elements: the *x*, *y*, and *z* coordinates of the new current normal.
 * @see [glNormal](https://docs.gl/gl3/glNormal)
 */
export function glNormal3iv(v: GLint): void;

/**
 * The current normal is set to the given coordinates whenever `glNormal` is issued. Byte, short, or integer arguments are converted to floating-point format with a linear mapping that maps the most positive representable integer value to 1.0 and the most negative representable integer value to −1.0.
 *
 * Normals specified with `glNormal` need not have unit length. If {@link GL_NORMALIZE} is enabled, then normals of any length specified with `glNormal` are normalized after transformation. If {@link GL_RESCALE_NORMAL} is enabled, normals are scaled by a scaling factor derived from the modelview matrix. {@link GL_RESCALE_NORMAL} requires that the originally specified normals were of unit length, and that the modelview matrix contain only uniform scales for proper results. To enable and disable normalization, call {@link glEnable} and {@link glDisable} with either {@link GL_NORMALIZE} or {@link GL_RESCALE_NORMAL}. Normalization is initially disabled.
 *
 * @summary set the current normal vector
 * @param v Specifies a pointer to an array of three elements: the *x*, *y*, and *z* coordinates of the new current normal.
 * @see [glNormal](https://docs.gl/gl3/glNormal)
 */
export function glNormal3sv(v: GLshort): void;

/**
 * `glNormalPointer` specifies the location and data format of an array of normals to use when rendering. **type** specifies the data type of each normal coordinate, and **stride** specifies the byte stride from one normal to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays. (Single-array storage may be more efficient on some implementations; see {@link glInterleavedArrays}.)
 *
 * If a non-zero named buffer object is bound to the {@link GL_ARRAY_BUFFER} target (see {@link glBindBuffer}) while a normal array is specified, **pointer** is treated as a byte offset into the buffer object's data store. Also, the buffer object binding ({@link GL_ARRAY_BUFFER_BINDING}) is saved as normal vertex array client-side state ({@link GL_NORMAL_ARRAY_BUFFER_BINDING}).
 *
 * When a normal array is specified, **type**, **stride**, and **pointer** are saved as client-side state, in addition to the current vertex array buffer object binding.
 *
 * To enable and disable the normal array, call {@link glEnableClientState} and {@link glDisableClientState} with the argument {@link GL_NORMAL_ARRAY}. If enabled, the normal array is used when {@link glDrawArrays}, {@link glMultiDrawArrays}, {@link glDrawElements}, {@link glMultiDrawElements}, {@link glDrawRangeElements}, or {@link glArrayElement} is called.
 *
 * @summary define an array of normals
 * @param type Specifies the data type of each coordinate in the array. Symbolic constants {@link GL_BYTE}, {@link GL_SHORT}, {@link GL_INT}, {@link GL_FLOAT}, and {@link GL_DOUBLE} are accepted. The initial value is {@link GL_FLOAT}.
 * @param stride Specifies the byte offset between consecutive normals. If **stride** is 0, the normals are understood to be tightly packed in the array. The initial value is 0.
 * @param pointer Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.
 * @see [glNormalPointer](https://docs.gl/gl3/glNormalPointer)
 */
export function glNormalPointer(
	type: GLenum,
	stride: GLsizei,
	pointer: GLvoid
): void;

/**
 * `glOrtho` describes a transformation that produces a parallel projection. The current matrix (see {@link glMatrixMode}) is multiplied by this matrix and the result replaces the current matrix, as if {@link glMultMatrix} were called with the following matrix as its argument:
 *
 * ⎛2 / right-leftㅤㅤ ㅤㅤ0ㅤㅤㅤㅤㅤㅤㅤ ㅤ ㅤ0ㅤㅤㅤㅤㅤㅤㅤ𝐭ₓ⎞
 *
 * ⎜0ㅤㅤㅤㅤㅤㅤ2 / top - bottomㅤㅤㅤㅤㅤㅤ0ㅤㅤㅤㅤㅤㅤㅤ𝐭ᵧ ⎜
 *
 * ⎜0ㅤㅤㅤㅤㅤㅤㅤ ㅤ ㅤ0ㅤㅤㅤㅤㅤ-2 / farVal - nearValㅤㅤㅤ𝐭𝑧 ⎜
 *
 * ⎝0ㅤㅤㅤㅤㅤㅤㅤ ㅤ ㅤ0ㅤㅤㅤㅤㅤㅤ ㅤ ㅤ ㅤ0ㅤㅤㅤㅤㅤㅤ ㅤ1⎠
 *
 * where
 *
 * 𝐭ₓ = − right + left / right − left
 *
 * 𝐭ᵧ = − top + bottom / top − bottom
 *
 * 𝐭𝑧 = − farVal + nearVal / farVal − nearVal
 *
 * Typically, the matrix mode is {@link GL_PROJECTION}, and (*left*, *bottom*, −*nearVal*) and (*right*, *top*, −*nearVal*) specify the points on the near clipping plane that are mapped to the lower left and upper right corners of the window, respectively, assuming that the eye is located at (0, 0, 0). −*farVal* specifies the location of the far clipping plane. Both **nearVal** and **farVal** can be either positive or negative.
 *
 * Use {@link glPushMatrix} and {@link glPopMatrix} to save and restore the current matrix stack.
 *
 * @summary multiply the current matrix with an orthographic matrix
 * @param left Specifies the coordinate for the left vertical clipping plane.
 * @param right Specifies the coordinate for the right vertical clipping plane.
 * @param bottom Specifies the coordinate for the bottom horizontal clipping plane.
 * @param top Specifies the coordinate for the top horizontal clipping plane.
 * @param nearVal Specifies the distance to the nearer depth clipping plane. This value is negative if the plane is to be behind the viewer.
 * @param farVal Specifies the distance to the farther depth clipping plane. This value is negative if the plane is to be behind the viewer.
 * @see [glOrtho](https://docs.gl/gl3/glOrtho)
 */
export function glOrtho(
	left: GLdouble,
	right: GLdouble,
	bottom: GLdouble,
	top: GLdouble,
	nearVal: GLdouble,
	farVal: GLdouble
): void;

/**
 * Feedback is a GL render mode. The mode is selected by calling {@link glRenderMode} with {@link GL_FEEDBACK}. When the GL is in feedback mode, no pixels are produced by rasterization. Instead, information about primitives that would have been rasterized is fed back to the application using the GL. See the {@link glFeedbackBuffer} reference page for a description of the feedback buffer and the values in it.
 *
 * `glPassThrough` inserts a user-defined marker in the feedback buffer when it is executed in feedback mode. **token** is returned as if it were a primitive; it is indicated with its own unique identifying value: {@link GL_PASS_THROUGH_TOKEN}. The order of `glPassThrough` commands with respect to the specification of graphics primitives is maintained.
 *
 * @summary place a marker in the feedback buffer
 * @param token Specifies a marker value to be placed in the feedback buffer following a {@link GL_PASS_THROUGH_TOKEN}.
 * @see [glPassThrough](https://docs.gl/gl3/glPassThrough)
 */
export function glPassThrough(token: GLfloat): void;

/**
 * `glPixelMap` sets up translation tables, or **maps**, used by {@link glCopyPixels}, {@link glCopyTexImage1D}, {@link glCopyTexImage2D}, {@link glCopyTexSubImage1D}, {@link glCopyTexSubImage2D}, {@link glCopyTexSubImage3D}, {@link glDrawPixels}, {@link glReadPixels}, {@link glTexImage1D}, {@link glTexImage2D}, {@link glTexImage3D}, {@link glTexSubImage1D}, {@link glTexSubImage2D}, and {@link glTexSubImage3D}. Additionally, if the ARB_imaging subset is supported, the routines {@link glColorTable}, {@link glColorSubTable}, {@link glConvolutionFilter1D}, {@link glConvolutionFilter2D}, {@link glHistogram}, {@link glMinmax}, and {@link glSeparableFilter2D}. Use of these maps is described completely in the {@link glPixelTransfer} reference page, and partly in the reference pages for the pixel and texture image commands. Only the specification of the maps is described in this reference page.
 *
 * **map** is a symbolic map name, indicating one of ten maps to set. **mapsize** specifies the number of entries in the map, and **values** is a pointer to an array of **mapsize** map values.
 *
 * If a non-zero named buffer object is bound to the {@link GL_PIXEL_UNPACK_BUFFER} target (see {@link glBindBuffer}) while a pixel transfer map is specified, **values** is treated as a byte offset into the buffer object's data store.
 *
 * The ten maps are as follows:
 *
 * - {@link GL_PIXEL_MAP_I_TO_I}
 * Maps color indices to color indices.
 *
 * - {@link GL_PIXEL_MAP_S_TO_S}
 * Maps stencil indices to stencil indices.
 *
 * - {@link GL_PIXEL_MAP_I_TO_R}
 * Maps color indices to red components.
 *
 * - {@link GL_PIXEL_MAP_I_TO_G}
 * Maps color indices to green components.
 *
 * - {@link GL_PIXEL_MAP_I_TO_B}
 * Maps color indices to blue components.
 *
 * - {@link GL_PIXEL_MAP_I_TO_A}
 * Maps color indices to alpha components.
 *
 * - {@link GL_PIXEL_MAP_R_TO_R}
 * Maps red components to red components.
 *
 * - {@link GL_PIXEL_MAP_G_TO_G}
 * Maps green components to green components.
 *
 * - {@link GL_PIXEL_MAP_B_TO_B}
 * Maps blue components to blue components.
 *
 * - {@link GL_PIXEL_MAP_A_TO_A}
 * Maps alpha components to alpha components.
 *
 * The entries in a map can be specified as single-precision floating-point numbers, unsigned short integers, or unsigned int integers. Maps that store color component values (all but {@link GL_PIXEL_MAP_I_TO_I} and {@link GL_PIXEL_MAP_S_TO_S}) retain their values in floating-point format, with unspecified mantissa and exponent sizes. Floating-point values specified by `glPixelMapfv` are converted directly to the internal floating-point format of these maps, then clamped to the range [0,1]. Unsigned integer values specified by `glPixelMapusv` and `glPixelMapuiv` are converted linearly such that the largest representable integer maps to 1.0, and 0 maps to 0.0.
 *
 * Maps that store indices, {@link GL_PIXEL_MAP_I_TO_I} and {@link GL_PIXEL_MAP_S_TO_S}, retain their values in fixed-point format, with an unspecified number of bits to the right of the binary point. Floating-point values specified by `glPixelMapfv` are converted directly to the internal fixed-point format of these maps. Unsigned integer values specified by `glPixelMapusv` and `glPixelMapuiv` specify integer values, with all 0's to the right of the binary point.
 *
 * The following table shows the initial sizes and values for each of the maps. Maps that are indexed by either color or stencil indices must have **mapsize** = 2ⁿ for some 𝐧 or the results are undefined. The maximum allowable size for each map depends on the implementation and can be determined by calling {@link glGet} with argument {@link GL_MAX_PIXEL_MAP_TABLE}. The single maximum applies to all maps; it is at least 32.
 *
 * | **map**                     | **Lookup Index** | **Lookup Value** | **Initial Size** | **Initial Value** |
 * | :-------------------------- | :--------------- | :--------------- | :--------------- | :---------------- |
 * | {@link GL_PIXEL_MAP_I_TO_I} | color index      | color index      | 1                | 0                 |
 * | {@link GL_PIXEL_MAP_S_TO_S} | stencil index    | stencil index    | 1                | 0                 |
 * | {@link GL_PIXEL_MAP_I_TO_R} | color index      | R                | 1                | 0                 |
 * | {@link GL_PIXEL_MAP_I_TO_G} | color index      | G                | 1                | 0                 |
 * | {@link GL_PIXEL_MAP_I_TO_B} | color index      | B                | 1                | 0                 |
 * | {@link GL_PIXEL_MAP_I_TO_A} | color index      | A                | 1                | 0                 |
 * | {@link GL_PIXEL_MAP_R_TO_R} | R                | R                | 1                | 0                 |
 * | {@link GL_PIXEL_MAP_G_TO_G} | G                | G                | 1                | 0                 |
 * | {@link GL_PIXEL_MAP_B_TO_B} | B                | B                | 1                | 0                 |
 * | {@link GL_PIXEL_MAP_A_TO_A} | A                | A                | 1                | 0                 |
 *
 * @summary set up pixel transfer maps
 * @param map Specifies a symbolic map name. Must be one of the following: {@link GL_PIXEL_MAP_I_TO_I}, {@link GL_PIXEL_MAP_S_TO_S}, {@link GL_PIXEL_MAP_I_TO_R}, {@link GL_PIXEL_MAP_I_TO_G}, {@link GL_PIXEL_MAP_I_TO_B}, {@link GL_PIXEL_MAP_I_TO_A}, {@link GL_PIXEL_MAP_R_TO_R}, {@link GL_PIXEL_MAP_G_TO_G}, {@link GL_PIXEL_MAP_B_TO_B}, or {@link GL_PIXEL_MAP_A_TO_A}.
 * @param mapsize Specifies the size of the map being defined.
 * @param values Specifies an array of **mapsize** values.
 * @see [glPixelMap](https://docs.gl/gl3/glPixelMap)
 */
export function glPixelMapfv(
	map: GLenum,
	mapsize: GLsizei,
	values: GLfloat
): void;

/**
 * `glPixelMap` sets up translation tables, or **maps**, used by {@link glCopyPixels}, {@link glCopyTexImage1D}, {@link glCopyTexImage2D}, {@link glCopyTexSubImage1D}, {@link glCopyTexSubImage2D}, {@link glCopyTexSubImage3D}, {@link glDrawPixels}, {@link glReadPixels}, {@link glTexImage1D}, {@link glTexImage2D}, {@link glTexImage3D}, {@link glTexSubImage1D}, {@link glTexSubImage2D}, and {@link glTexSubImage3D}. Additionally, if the ARB_imaging subset is supported, the routines {@link glColorTable}, {@link glColorSubTable}, {@link glConvolutionFilter1D}, {@link glConvolutionFilter2D}, {@link glHistogram}, {@link glMinmax}, and {@link glSeparableFilter2D}. Use of these maps is described completely in the {@link glPixelTransfer} reference page, and partly in the reference pages for the pixel and texture image commands. Only the specification of the maps is described in this reference page.
 *
 * **map** is a symbolic map name, indicating one of ten maps to set. **mapsize** specifies the number of entries in the map, and **values** is a pointer to an array of **mapsize** map values.
 *
 * If a non-zero named buffer object is bound to the {@link GL_PIXEL_UNPACK_BUFFER} target (see {@link glBindBuffer}) while a pixel transfer map is specified, **values** is treated as a byte offset into the buffer object's data store.
 *
 * The ten maps are as follows:
 *
 * - {@link GL_PIXEL_MAP_I_TO_I}
 * Maps color indices to color indices.
 *
 * - {@link GL_PIXEL_MAP_S_TO_S}
 * Maps stencil indices to stencil indices.
 *
 * - {@link GL_PIXEL_MAP_I_TO_R}
 * Maps color indices to red components.
 *
 * - {@link GL_PIXEL_MAP_I_TO_G}
 * Maps color indices to green components.
 *
 * - {@link GL_PIXEL_MAP_I_TO_B}
 * Maps color indices to blue components.
 *
 * - {@link GL_PIXEL_MAP_I_TO_A}
 * Maps color indices to alpha components.
 *
 * - {@link GL_PIXEL_MAP_R_TO_R}
 * Maps red components to red components.
 *
 * - {@link GL_PIXEL_MAP_G_TO_G}
 * Maps green components to green components.
 *
 * - {@link GL_PIXEL_MAP_B_TO_B}
 * Maps blue components to blue components.
 *
 * - {@link GL_PIXEL_MAP_A_TO_A}
 * Maps alpha components to alpha components.
 *
 * The entries in a map can be specified as single-precision floating-point numbers, unsigned short integers, or unsigned int integers. Maps that store color component values (all but {@link GL_PIXEL_MAP_I_TO_I} and {@link GL_PIXEL_MAP_S_TO_S}) retain their values in floating-point format, with unspecified mantissa and exponent sizes. Floating-point values specified by `glPixelMapfv` are converted directly to the internal floating-point format of these maps, then clamped to the range [0,1]. Unsigned integer values specified by `glPixelMapusv` and `glPixelMapuiv` are converted linearly such that the largest representable integer maps to 1.0, and 0 maps to 0.0.
 *
 * Maps that store indices, {@link GL_PIXEL_MAP_I_TO_I} and {@link GL_PIXEL_MAP_S_TO_S}, retain their values in fixed-point format, with an unspecified number of bits to the right of the binary point. Floating-point values specified by `glPixelMapfv` are converted directly to the internal fixed-point format of these maps. Unsigned integer values specified by `glPixelMapusv` and `glPixelMapuiv` specify integer values, with all 0's to the right of the binary point.
 *
 * The following table shows the initial sizes and values for each of the maps. Maps that are indexed by either color or stencil indices must have **mapsize** = 2ⁿ for some 𝐧 or the results are undefined. The maximum allowable size for each map depends on the implementation and can be determined by calling {@link glGet} with argument {@link GL_MAX_PIXEL_MAP_TABLE}. The single maximum applies to all maps; it is at least 32.
 *
 * | **map**                     | **Lookup Index** | **Lookup Value** | **Initial Size** | **Initial Value** |
 * | :-------------------------- | :--------------- | :--------------- | :--------------- | :---------------- |
 * | {@link GL_PIXEL_MAP_I_TO_I} | color index      | color index      | 1                | 0                 |
 * | {@link GL_PIXEL_MAP_S_TO_S} | stencil index    | stencil index    | 1                | 0                 |
 * | {@link GL_PIXEL_MAP_I_TO_R} | color index      | R                | 1                | 0                 |
 * | {@link GL_PIXEL_MAP_I_TO_G} | color index      | G                | 1                | 0                 |
 * | {@link GL_PIXEL_MAP_I_TO_B} | color index      | B                | 1                | 0                 |
 * | {@link GL_PIXEL_MAP_I_TO_A} | color index      | A                | 1                | 0                 |
 * | {@link GL_PIXEL_MAP_R_TO_R} | R                | R                | 1                | 0                 |
 * | {@link GL_PIXEL_MAP_G_TO_G} | G                | G                | 1                | 0                 |
 * | {@link GL_PIXEL_MAP_B_TO_B} | B                | B                | 1                | 0                 |
 * | {@link GL_PIXEL_MAP_A_TO_A} | A                | A                | 1                | 0                 |
 *
 * @summary set up pixel transfer maps
 * @param map Specifies a symbolic map name. Must be one of the following: {@link GL_PIXEL_MAP_I_TO_I}, {@link GL_PIXEL_MAP_S_TO_S}, {@link GL_PIXEL_MAP_I_TO_R}, {@link GL_PIXEL_MAP_I_TO_G}, {@link GL_PIXEL_MAP_I_TO_B}, {@link GL_PIXEL_MAP_I_TO_A}, {@link GL_PIXEL_MAP_R_TO_R}, {@link GL_PIXEL_MAP_G_TO_G}, {@link GL_PIXEL_MAP_B_TO_B}, or {@link GL_PIXEL_MAP_A_TO_A}.
 * @param mapsize Specifies the size of the map being defined.
 * @param values Specifies an array of **mapsize** values.
 * @see [glPixelMap](https://docs.gl/gl3/glPixelMap)
 */
export function glPixelMapuiv(
	map: GLenum,
	mapsize: GLsizei,
	values: GLuint
): void;

/**
 * `glPixelMap` sets up translation tables, or **maps**, used by {@link glCopyPixels}, {@link glCopyTexImage1D}, {@link glCopyTexImage2D}, {@link glCopyTexSubImage1D}, {@link glCopyTexSubImage2D}, {@link glCopyTexSubImage3D}, {@link glDrawPixels}, {@link glReadPixels}, {@link glTexImage1D}, {@link glTexImage2D}, {@link glTexImage3D}, {@link glTexSubImage1D}, {@link glTexSubImage2D}, and {@link glTexSubImage3D}. Additionally, if the ARB_imaging subset is supported, the routines {@link glColorTable}, {@link glColorSubTable}, {@link glConvolutionFilter1D}, {@link glConvolutionFilter2D}, {@link glHistogram}, {@link glMinmax}, and {@link glSeparableFilter2D}. Use of these maps is described completely in the {@link glPixelTransfer} reference page, and partly in the reference pages for the pixel and texture image commands. Only the specification of the maps is described in this reference page.
 *
 * **map** is a symbolic map name, indicating one of ten maps to set. **mapsize** specifies the number of entries in the map, and **values** is a pointer to an array of **mapsize** map values.
 *
 * If a non-zero named buffer object is bound to the {@link GL_PIXEL_UNPACK_BUFFER} target (see {@link glBindBuffer}) while a pixel transfer map is specified, **values** is treated as a byte offset into the buffer object's data store.
 *
 * The ten maps are as follows:
 *
 * - {@link GL_PIXEL_MAP_I_TO_I}
 * Maps color indices to color indices.
 *
 * - {@link GL_PIXEL_MAP_S_TO_S}
 * Maps stencil indices to stencil indices.
 *
 * - {@link GL_PIXEL_MAP_I_TO_R}
 * Maps color indices to red components.
 *
 * - {@link GL_PIXEL_MAP_I_TO_G}
 * Maps color indices to green components.
 *
 * - {@link GL_PIXEL_MAP_I_TO_B}
 * Maps color indices to blue components.
 *
 * - {@link GL_PIXEL_MAP_I_TO_A}
 * Maps color indices to alpha components.
 *
 * - {@link GL_PIXEL_MAP_R_TO_R}
 * Maps red components to red components.
 *
 * - {@link GL_PIXEL_MAP_G_TO_G}
 * Maps green components to green components.
 *
 * - {@link GL_PIXEL_MAP_B_TO_B}
 * Maps blue components to blue components.
 *
 * - {@link GL_PIXEL_MAP_A_TO_A}
 * Maps alpha components to alpha components.
 *
 * The entries in a map can be specified as single-precision floating-point numbers, unsigned short integers, or unsigned int integers. Maps that store color component values (all but {@link GL_PIXEL_MAP_I_TO_I} and {@link GL_PIXEL_MAP_S_TO_S}) retain their values in floating-point format, with unspecified mantissa and exponent sizes. Floating-point values specified by `glPixelMapfv` are converted directly to the internal floating-point format of these maps, then clamped to the range [0,1]. Unsigned integer values specified by `glPixelMapusv` and `glPixelMapuiv` are converted linearly such that the largest representable integer maps to 1.0, and 0 maps to 0.0.
 *
 * Maps that store indices, {@link GL_PIXEL_MAP_I_TO_I} and {@link GL_PIXEL_MAP_S_TO_S}, retain their values in fixed-point format, with an unspecified number of bits to the right of the binary point. Floating-point values specified by `glPixelMapfv` are converted directly to the internal fixed-point format of these maps. Unsigned integer values specified by `glPixelMapusv` and `glPixelMapuiv` specify integer values, with all 0's to the right of the binary point.
 *
 * The following table shows the initial sizes and values for each of the maps. Maps that are indexed by either color or stencil indices must have **mapsize** = 2ⁿ for some 𝐧 or the results are undefined. The maximum allowable size for each map depends on the implementation and can be determined by calling {@link glGet} with argument {@link GL_MAX_PIXEL_MAP_TABLE}. The single maximum applies to all maps; it is at least 32.
 *
 * | **map**                     | **Lookup Index** | **Lookup Value** | **Initial Size** | **Initial Value** |
 * | :-------------------------- | :--------------- | :--------------- | :--------------- | :---------------- |
 * | {@link GL_PIXEL_MAP_I_TO_I} | color index      | color index      | 1                | 0                 |
 * | {@link GL_PIXEL_MAP_S_TO_S} | stencil index    | stencil index    | 1                | 0                 |
 * | {@link GL_PIXEL_MAP_I_TO_R} | color index      | R                | 1                | 0                 |
 * | {@link GL_PIXEL_MAP_I_TO_G} | color index      | G                | 1                | 0                 |
 * | {@link GL_PIXEL_MAP_I_TO_B} | color index      | B                | 1                | 0                 |
 * | {@link GL_PIXEL_MAP_I_TO_A} | color index      | A                | 1                | 0                 |
 * | {@link GL_PIXEL_MAP_R_TO_R} | R                | R                | 1                | 0                 |
 * | {@link GL_PIXEL_MAP_G_TO_G} | G                | G                | 1                | 0                 |
 * | {@link GL_PIXEL_MAP_B_TO_B} | B                | B                | 1                | 0                 |
 * | {@link GL_PIXEL_MAP_A_TO_A} | A                | A                | 1                | 0                 |
 *
 * @summary set up pixel transfer maps
 * @param map Specifies a symbolic map name. Must be one of the following: {@link GL_PIXEL_MAP_I_TO_I}, {@link GL_PIXEL_MAP_S_TO_S}, {@link GL_PIXEL_MAP_I_TO_R}, {@link GL_PIXEL_MAP_I_TO_G}, {@link GL_PIXEL_MAP_I_TO_B}, {@link GL_PIXEL_MAP_I_TO_A}, {@link GL_PIXEL_MAP_R_TO_R}, {@link GL_PIXEL_MAP_G_TO_G}, {@link GL_PIXEL_MAP_B_TO_B}, or {@link GL_PIXEL_MAP_A_TO_A}.
 * @param mapsize Specifies the size of the map being defined.
 * @param values Specifies an array of **mapsize** values.
 * @see [glPixelMap](https://docs.gl/gl3/glPixelMap)
 */
export function glPixelMapusv(
	map: GLenum,
	mapsize: GLsizei,
	values: GLushort
): void;

/**
 * `glPixelStore` sets pixel storage modes that affect the operation of subsequent {@link glReadPixels} as well as the unpacking of texture patterns (see {@link glTexImage1D}, {@link glTexImage2D}, {@link glTexImage3D}, {@link glTexSubImage1D}, {@link glTexSubImage2D}, {@link glTexSubImage3D}).
 *
 * **pname** is a symbolic constant indicating the parameter to be set, and **param** is the new value. Six of the twelve storage parameters affect how pixel data is returned to client memory. They are as follows:
 *
 * - {@link GL_PACK_SWAP_BYTES}
 *  If true, byte ordering for multibyte color components, depth components, or stencil indices is reversed. That is, if a four-byte component consists of bytes 𝐛₀, 𝐛₁, 𝐛₂, 𝐛₃, it is stored in memory as 𝐛₃, 𝐛₂, 𝐛₁, 𝐛₀ if {@link GL_PACK_SWAP_BYTES} is true. {@link GL_PACK_SWAP_BYTES} has no effect on the memory order of components within a pixel, only on the order of bytes within components or indices. For example, the three components of a {@link GL_RGB} format pixel are always stored with red first, green second, and blue third, regardless of the value of {@link GL_PACK_SWAP_BYTES}.
 *
 * - {@link GL_PACK_LSB_FIRST}
 * If true, bits are ordered within a byte from least significant to most significant; otherwise, the first bit in each byte is the most significant one.
 *
 * - {@link GL_PACK_ROW_LENGTH}
 * If greater than 0, {@link GL_PACK_ROW_LENGTH} defines the number of pixels in a row. If the first pixel of a row is placed at location 𝐩 in memory, then the location of the first pixel of the next row is obtained by skipping
 *
 * ㅤㅤ ⎧ㅤㅤ𝐧𝐥ㅤㅤㅤㅤ𝐬 >= 𝐚
 *
 * 𝒌 = ⎨
 *
 * ㅤㅤ ⎩ 𝐚/𝐬⌈𝐬𝐧𝐥/𝐚⌉ㅤㅤ𝐬 < 𝐚
 *
 * components or indices, where 𝐧 is the number of components or indices in a pixel, 𝐥 is the number of pixels in a row ({@link GL_PACK_ROW_LENGTH} if it is greater than 0, the *width* argument to the pixel routine otherwise), 𝐚 is the value of {@link GL_PACK_ALIGNMENT}, and 𝐬 is the size, in bytes, of a single component (if 𝐚 < 𝐬, then it is as if 𝐚 = 𝐬). In the case of 1-bit values, the location of the next row is obtained by skipping
 *
 * 𝒌 = 8𝐚⌈𝐧𝐥/8𝐚⌉
 *
 * components or indices.
 *
 * The word **component** in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format {@link GL_RGB}, for example, has three components per pixel: first red, then green, and finally blue.
 *
 * - {@link GL_PACK_IMAGE_HEIGHT}
 * If greater than 0, {@link GL_PACK_IMAGE_HEIGHT} defines the number of pixels in an image three-dimensional texture volume, where ``image'' is defined by all pixels sharing the same third dimension index. If the first pixel of a row is placed at location 𝐩 in memory, then the location of the first pixel of the next row is obtained by skipping
 *
 * ㅤㅤ ⎧ㅤㅤ𝐧𝐥𝐡ㅤㅤㅤㅤ𝐬 >= 𝐚
 *
 * 𝒌 = ⎨
 *
 * ㅤㅤ ⎩ 𝐚/𝐬⌈𝐬𝐧𝐥𝐡/𝐚⌉ㅤㅤ𝐬 < 𝐚
 *
 * components or indices, where 𝐧 is the number of components or indices in a pixel, 𝑙 is the number of pixels in a row ({@link GL_PACK_ROW_LENGTH} if it is greater than 0, the *width* argument to {@link glTexImage3D} otherwise), 𝐡 is the number of rows in a pixel image ({@link GL_PACK_IMAGE_HEIGHT} if it is greater than 0, the *height* argument to the {@link glTexImage3D} routine otherwise), 𝐚 is the value of {@link GL_PACK_ALIGNMENT}, and 𝐬 is the size, in bytes, of a single component (if 𝐚 < 𝐬, then it is as if 𝐚 = 𝐬).
 *
 * The word **component** in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format {@link GL_RGB}, for example, has three components per pixel: first red, then green, and finally blue.
 *
 * - {@link GL_PACK_SKIP_PIXELS}, {@link GL_PACK_SKIP_ROWS}, and {@link GL_PACK_SKIP_IMAGES}
 * These values are provided as a convenience to the programmer; they provide no functionality that cannot be duplicated simply by incrementing the pointer passed to {@link glReadPixels}. Setting {@link GL_PACK_SKIP_PIXELS} to 𝐢 is equivalent to incrementing the pointer by 𝐢𝐧 components or indices, where 𝐧 is the number of components or indices in each pixel. Setting {@link GL_PACK_SKIP_ROWS} to 𝐣 is equivalent to incrementing the pointer by 𝐣𝐦 components or indices, where 𝐦 is the number of components or indices per row, as just computed in the {@link GL_PACK_ROW_LENGTH} section. Setting {@link GL_PACK_SKIP_IMAGES} to 𝐤 is equivalent to incrementing the pointer by 𝐤𝐩, where 𝐩 is the number of components or indices per image, as computed in the {@link GL_PACK_IMAGE_HEIGHT} section.
 *
 * - {@link GL_PACK_ALIGNMENT}
 *     Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries).
 *
 * The other six of the twelve storage parameters affect how pixel data is read from client memory. These values are significant for {@link glTexImage1D}, {@link glTexImage2D}, {@link glTexImage3D}, {@link glTexSubImage1D}, {@link glTexSubImage2D}, and {@link glTexSubImage3D}
 *
 * They are as follows:
 *
 * - {@link GL_UNPACK_SWAP_BYTES}
 * If true, byte ordering for multibyte color components, depth components, or stencil indices is reversed. That is, if a four-byte component consists of bytes 𝐛₀, 𝐛₁, 𝐛₂, 𝐛₃, it is stored in memory as 𝐛₃, 𝐛₂, 𝐛₁, 𝐛₀ if {@link GL_UNPACK_SWAP_BYTES} is true. {@link GL_UNPACK_SWAP_BYTES} has no effect on the memory order of components within a pixel, only on the order of bytes within components or indices. For example, the three components of a {@link GL_RGB} format pixel are always stored with red first, green second, and blue third, regardless of the value of {@link GL_UNPACK_SWAP_BYTES}.
 *
 * - {@link GL_UNPACK_LSB_FIRST}
 * If true, bits are ordered within a byte from least significant to most significant; otherwise, the first bit in each byte is the most significant one.
 *
 * - {@link GL_UNPACK_ROW_LENGTH}
 * If greater than 0, {@link GL_UNPACK_ROW_LENGTH} defines the number of pixels in a row. If the first pixel of a row is placed at location 𝐩 in memory, then the location of the first pixel of the next row is obtained by skipping
 *
 * ㅤㅤ ⎧ㅤㅤ𝐧𝐥ㅤㅤㅤㅤ𝐬 >= 𝐚
 *
 * 𝒌 = ⎨
 *
 * ㅤㅤ ⎩ 𝐚/𝐬⌈𝐬𝐧𝐥/𝐚⌉ㅤㅤ𝐬 < 𝐚
 *
 * components or indices, where 𝐧 is the number of components or indices in a pixel, 𝐥 is the number of pixels in a row ({@link GL_UNPACK_ROW_LENGTH} if it is greater than 0, the *width* argument to the pixel routine otherwise), 𝐚 is the value of {@link GL_UNPACK_ALIGNMENT}, and 𝐬 is the size, in bytes, of a single component (if 𝐚 < 𝐬, then it is as if 𝐚 = 𝐬). In the case of 1-bit values, the location of the next row is obtained by skipping
 *
 * 𝒌 = 8𝐚⌈𝐧𝐥/8𝐚⌉
 *
 * components or indices.
 *
 * The word **component** in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format {@link GL_RGB}, for example, has three components per pixel: first red, then green, and finally blue.
 *
 * - {@link GL_UNPACK_IMAGE_HEIGHT}
 * If greater than 0, {@link GL_UNPACK_IMAGE_HEIGHT} defines the number of pixels in an image three-dimensional texture volume, where ``image'' is defined by all pixels sharing the same third dimension index. If the first pixel of a row is placed at location 𝐩 in memory, then the location of the first pixel of the next row is obtained by skipping
 *
 * ㅤㅤ ⎧ㅤㅤ𝐧𝐥𝐡ㅤㅤㅤㅤ𝐬 >= 𝐚
 *
 * 𝒌 = ⎨
 *
 * ㅤㅤ ⎩ 𝐚/𝐬⌈𝐬𝐧𝐥𝐡/𝐚⌉ㅤㅤ𝐬 < 𝐚
 *
 * components or indices, where 𝐧 is the number of components or indices in a pixel, 𝑙 is the number of pixels in a row ({@link GL_UNPACK_ROW_LENGTH} if it is greater than 0, the *width* argument to the pixel routine otherwise), 𝐡 is the number of rows in a pixel image ({@link GL_UNPACK_IMAGE_HEIGHT} if it is greater than 0, the *height* argument to the pixel routine otherwise), 𝐚 is the value of {@link GL_UNPACK_ALIGNMENT}, and 𝐬 is the size, in bytes, of a single component (if 𝐚 < 𝐬, then it is as if 𝐚 = 𝐬).
 *
 * The word **component** in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format {@link GL_RGB}, for example, has three components per pixel: first red, then green, and finally blue.
 *
 * - {@link GL_UNPACK_SKIP_PIXELS} and {@link GL_UNPACK_SKIP_ROWS}
 * These values are provided as a convenience to the programmer; they provide no functionality that cannot be duplicated by incrementing the pointer passed to {@link glTexImage1D}, {@link glTexImage2D}, {@link glTexSubImage1D} or {@link glTexSubImage2D}. Setting {@link GL_UNPACK_SKIP_PIXELS} to 𝐢 is equivalent to incrementing the pointer by 𝐢𝐧 components or indices, where 𝐧 is the number of components or indices in each pixel. Setting {@link GL_UNPACK_SKIP_ROWS} to 𝐣 is equivalent to incrementing the pointer by 𝐣𝐤 components or indices, where 𝐤 is the number of components or indices per row, as just computed in the {@link GL_UNPACK_ROW_LENGTH} section.
 *
 * - {@link GL_UNPACK_ALIGNMENT}
 * Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries).
 *
 * The following table gives the type, initial value, and range of valid values for each storage parameter that can be set with `glPixelStore`.
 *
 * | **pname**                      | **Type** | **Initial Value** | **Valid Range** |
 * | :----------------------------- | :------- | :---------------- | :-------------- |
 * | {@link GL_PACK_SWAP_BYTES}     | boolean  | false             | true or false   |
 * | {@link GL_PACK_LSB_FIRST}      | boolean  | false             | true or false   |
 * | {@link GL_PACK_ROW_LENGTH}     | integer  | 0                 | [0,∞)           |
 * | {@link GL_PACK_IMAGE_HEIGHT}   | integer  | 0                 | [0,∞)           |
 * | {@link GL_PACK_SKIP_ROWS}      | integer  | 0                 | [0,∞)           |
 * | {@link GL_PACK_SKIP_PIXELS}    | integer  | 0                 | [0,∞)           |
 * | {@link GL_PACK_SKIP_IMAGES}    | integer  | 0                 | [0,∞)           |
 * | {@link GL_PACK_ALIGNMENT}      | integer  | 4                 | 1, 2, 4, or 8   |
 * | {@link GL_UNPACK_SWAP_BYTES}   | boolean  | false             | true or false   |
 * | {@link GL_UNPACK_LSB_FIRST}    | boolean  | false             | true or false   |
 * | {@link GL_UNPACK_ROW_LENGTH}   | integer  | 0                 | [0,∞)           |
 * | {@link GL_UNPACK_IMAGE_HEIGHT} | integer  | 0                 | [0,∞)           |
 * | {@link GL_UNPACK_SKIP_ROWS}    | integer  | 0                 | [0,∞)           |
 * | {@link GL_UNPACK_SKIP_PIXELS}  | integer  | 0                 | [0,∞)           |
 * | {@link GL_UNPACK_SKIP_IMAGES}  | integer  | 0                 | [0,∞)           |
 * | {@link GL_UNPACK_ALIGNMENT}    | integer  | 4                 | 1, 2, 4, or 8   |
 *
 * `glPixelStoref` can be used to set any pixel store parameter. If the parameter type is boolean, then if **param** is 0, the parameter is false; otherwise it is set to true. If **pname** is a integer type parameter, **param** is rounded to the nearest integer.
 *
 * Likewise, `glPixelStorei` can also be used to set any of the pixel store parameters. Boolean parameters are set to false if **param** is 0 and true otherwise.
 *
 * @summary set pixel storage modes
 * @param pname Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: {@link GL_PACK_SWAP_BYTES}, {@link GL_PACK_LSB_FIRST}, {@link GL_PACK_ROW_LENGTH}, {@link GL_PACK_IMAGE_HEIGHT}, {@link GL_PACK_SKIP_PIXELS}, {@link GL_PACK_SKIP_ROWS}, {@link GL_PACK_SKIP_IMAGES}, and {@link GL_PACK_ALIGNMENT}. Six more affect the unpacking of pixel data **from** memory: {@link GL_UNPACK_SWAP_BYTES}, {@link GL_UNPACK_LSB_FIRST}, {@link GL_UNPACK_ROW_LENGTH}, {@link GL_UNPACK_IMAGE_HEIGHT}, {@link GL_UNPACK_SKIP_PIXELS}, {@link GL_UNPACK_SKIP_ROWS}, {@link GL_UNPACK_SKIP_IMAGES}, and {@link GL_UNPACK_ALIGNMENT}.
 * @param param Specifies the value that **pname** is set to.
 * @see [glPixelStore](https://docs.gl/gl3/glPixelStore)
 */
export function glPixelStoref(pname: GLenum, param: GLfloat): void;

/**
 * `glPixelStore` sets pixel storage modes that affect the operation of subsequent {@link glReadPixels} as well as the unpacking of texture patterns (see {@link glTexImage1D}, {@link glTexImage2D}, {@link glTexImage3D}, {@link glTexSubImage1D}, {@link glTexSubImage2D}, {@link glTexSubImage3D}).
 *
 * **pname** is a symbolic constant indicating the parameter to be set, and **param** is the new value. Six of the twelve storage parameters affect how pixel data is returned to client memory. They are as follows:
 *
 * - {@link GL_PACK_SWAP_BYTES}
 *  If true, byte ordering for multibyte color components, depth components, or stencil indices is reversed. That is, if a four-byte component consists of bytes 𝐛₀, 𝐛₁, 𝐛₂, 𝐛₃, it is stored in memory as 𝐛₃, 𝐛₂, 𝐛₁, 𝐛₀ if {@link GL_PACK_SWAP_BYTES} is true. {@link GL_PACK_SWAP_BYTES} has no effect on the memory order of components within a pixel, only on the order of bytes within components or indices. For example, the three components of a {@link GL_RGB} format pixel are always stored with red first, green second, and blue third, regardless of the value of {@link GL_PACK_SWAP_BYTES}.
 *
 * - {@link GL_PACK_LSB_FIRST}
 * If true, bits are ordered within a byte from least significant to most significant; otherwise, the first bit in each byte is the most significant one.
 *
 * - {@link GL_PACK_ROW_LENGTH}
 * If greater than 0, {@link GL_PACK_ROW_LENGTH} defines the number of pixels in a row. If the first pixel of a row is placed at location 𝐩 in memory, then the location of the first pixel of the next row is obtained by skipping
 *
 * ㅤㅤ ⎧ㅤㅤ𝐧𝐥ㅤㅤㅤㅤ𝐬 >= 𝐚
 *
 * 𝒌 = ⎨
 *
 * ㅤㅤ ⎩ 𝐚/𝐬⌈𝐬𝐧𝐥/𝐚⌉ㅤㅤ𝐬 < 𝐚
 *
 * components or indices, where 𝐧 is the number of components or indices in a pixel, 𝐥 is the number of pixels in a row ({@link GL_PACK_ROW_LENGTH} if it is greater than 0, the *width* argument to the pixel routine otherwise), 𝐚 is the value of {@link GL_PACK_ALIGNMENT}, and 𝐬 is the size, in bytes, of a single component (if 𝐚 < 𝐬, then it is as if 𝐚 = 𝐬). In the case of 1-bit values, the location of the next row is obtained by skipping
 *
 * 𝒌 = 8𝐚⌈𝐧𝐥/8𝐚⌉
 *
 * components or indices.
 *
 * The word **component** in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format {@link GL_RGB}, for example, has three components per pixel: first red, then green, and finally blue.
 *
 * - {@link GL_PACK_IMAGE_HEIGHT}
 * If greater than 0, {@link GL_PACK_IMAGE_HEIGHT} defines the number of pixels in an image three-dimensional texture volume, where ``image'' is defined by all pixels sharing the same third dimension index. If the first pixel of a row is placed at location 𝐩 in memory, then the location of the first pixel of the next row is obtained by skipping
 *
 * ㅤㅤ ⎧ㅤㅤ𝐧𝐥𝐡ㅤㅤㅤㅤ𝐬 >= 𝐚
 *
 * 𝒌 = ⎨
 *
 * ㅤㅤ ⎩ 𝐚/𝐬⌈𝐬𝐧𝐥𝐡/𝐚⌉ㅤㅤ𝐬 < 𝐚
 *
 * components or indices, where 𝐧 is the number of components or indices in a pixel, 𝑙 is the number of pixels in a row ({@link GL_PACK_ROW_LENGTH} if it is greater than 0, the *width* argument to {@link glTexImage3D} otherwise), 𝐡 is the number of rows in a pixel image ({@link GL_PACK_IMAGE_HEIGHT} if it is greater than 0, the *height* argument to the {@link glTexImage3D} routine otherwise), 𝐚 is the value of {@link GL_PACK_ALIGNMENT}, and 𝐬 is the size, in bytes, of a single component (if 𝐚 < 𝐬, then it is as if 𝐚 = 𝐬).
 *
 * The word **component** in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format {@link GL_RGB}, for example, has three components per pixel: first red, then green, and finally blue.
 *
 * - {@link GL_PACK_SKIP_PIXELS}, {@link GL_PACK_SKIP_ROWS}, and {@link GL_PACK_SKIP_IMAGES}
 * These values are provided as a convenience to the programmer; they provide no functionality that cannot be duplicated simply by incrementing the pointer passed to {@link glReadPixels}. Setting {@link GL_PACK_SKIP_PIXELS} to 𝐢 is equivalent to incrementing the pointer by 𝐢𝐧 components or indices, where 𝐧 is the number of components or indices in each pixel. Setting {@link GL_PACK_SKIP_ROWS} to 𝐣 is equivalent to incrementing the pointer by 𝐣𝐦 components or indices, where 𝐦 is the number of components or indices per row, as just computed in the {@link GL_PACK_ROW_LENGTH} section. Setting {@link GL_PACK_SKIP_IMAGES} to 𝐤 is equivalent to incrementing the pointer by 𝐤𝐩, where 𝐩 is the number of components or indices per image, as computed in the {@link GL_PACK_IMAGE_HEIGHT} section.
 *
 * - {@link GL_PACK_ALIGNMENT}
 *     Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries).
 *
 * The other six of the twelve storage parameters affect how pixel data is read from client memory. These values are significant for {@link glTexImage1D}, {@link glTexImage2D}, {@link glTexImage3D}, {@link glTexSubImage1D}, {@link glTexSubImage2D}, and {@link glTexSubImage3D}
 *
 * They are as follows:
 *
 * - {@link GL_UNPACK_SWAP_BYTES}
 * If true, byte ordering for multibyte color components, depth components, or stencil indices is reversed. That is, if a four-byte component consists of bytes 𝐛₀, 𝐛₁, 𝐛₂, 𝐛₃, it is stored in memory as 𝐛₃, 𝐛₂, 𝐛₁, 𝐛₀ if {@link GL_UNPACK_SWAP_BYTES} is true. {@link GL_UNPACK_SWAP_BYTES} has no effect on the memory order of components within a pixel, only on the order of bytes within components or indices. For example, the three components of a {@link GL_RGB} format pixel are always stored with red first, green second, and blue third, regardless of the value of {@link GL_UNPACK_SWAP_BYTES}.
 *
 * - {@link GL_UNPACK_LSB_FIRST}
 * If true, bits are ordered within a byte from least significant to most significant; otherwise, the first bit in each byte is the most significant one.
 *
 * - {@link GL_UNPACK_ROW_LENGTH}
 * If greater than 0, {@link GL_UNPACK_ROW_LENGTH} defines the number of pixels in a row. If the first pixel of a row is placed at location 𝐩 in memory, then the location of the first pixel of the next row is obtained by skipping
 *
 * ㅤㅤ ⎧ㅤㅤ𝐧𝐥ㅤㅤㅤㅤ𝐬 >= 𝐚
 *
 * 𝒌 = ⎨
 *
 * ㅤㅤ ⎩ 𝐚/𝐬⌈𝐬𝐧𝐥/𝐚⌉ㅤㅤ𝐬 < 𝐚
 *
 * components or indices, where 𝐧 is the number of components or indices in a pixel, 𝐥 is the number of pixels in a row ({@link GL_UNPACK_ROW_LENGTH} if it is greater than 0, the *width* argument to the pixel routine otherwise), 𝐚 is the value of {@link GL_UNPACK_ALIGNMENT}, and 𝐬 is the size, in bytes, of a single component (if 𝐚 < 𝐬, then it is as if 𝐚 = 𝐬). In the case of 1-bit values, the location of the next row is obtained by skipping
 *
 * 𝒌 = 8𝐚⌈𝐧𝐥/8𝐚⌉
 *
 * components or indices.
 *
 * The word **component** in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format {@link GL_RGB}, for example, has three components per pixel: first red, then green, and finally blue.
 *
 * - {@link GL_UNPACK_IMAGE_HEIGHT}
 * If greater than 0, {@link GL_UNPACK_IMAGE_HEIGHT} defines the number of pixels in an image three-dimensional texture volume, where ``image'' is defined by all pixels sharing the same third dimension index. If the first pixel of a row is placed at location 𝐩 in memory, then the location of the first pixel of the next row is obtained by skipping
 *
 * ㅤㅤ ⎧ㅤㅤ𝐧𝐥𝐡ㅤㅤㅤㅤ𝐬 >= 𝐚
 *
 * 𝒌 = ⎨
 *
 * ㅤㅤ ⎩ 𝐚/𝐬⌈𝐬𝐧𝐥𝐡/𝐚⌉ㅤㅤ𝐬 < 𝐚
 *
 * components or indices, where 𝐧 is the number of components or indices in a pixel, 𝑙 is the number of pixels in a row ({@link GL_UNPACK_ROW_LENGTH} if it is greater than 0, the *width* argument to the pixel routine otherwise), 𝐡 is the number of rows in a pixel image ({@link GL_UNPACK_IMAGE_HEIGHT} if it is greater than 0, the *height* argument to the pixel routine otherwise), 𝐚 is the value of {@link GL_UNPACK_ALIGNMENT}, and 𝐬 is the size, in bytes, of a single component (if 𝐚 < 𝐬, then it is as if 𝐚 = 𝐬).
 *
 * The word **component** in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format {@link GL_RGB}, for example, has three components per pixel: first red, then green, and finally blue.
 *
 * - {@link GL_UNPACK_SKIP_PIXELS} and {@link GL_UNPACK_SKIP_ROWS}
 * These values are provided as a convenience to the programmer; they provide no functionality that cannot be duplicated by incrementing the pointer passed to {@link glTexImage1D}, {@link glTexImage2D}, {@link glTexSubImage1D} or {@link glTexSubImage2D}. Setting {@link GL_UNPACK_SKIP_PIXELS} to 𝐢 is equivalent to incrementing the pointer by 𝐢𝐧 components or indices, where 𝐧 is the number of components or indices in each pixel. Setting {@link GL_UNPACK_SKIP_ROWS} to 𝐣 is equivalent to incrementing the pointer by 𝐣𝐤 components or indices, where 𝐤 is the number of components or indices per row, as just computed in the {@link GL_UNPACK_ROW_LENGTH} section.
 *
 * - {@link GL_UNPACK_ALIGNMENT}
 * Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries).
 *
 * The following table gives the type, initial value, and range of valid values for each storage parameter that can be set with `glPixelStore`.
 *
 * | **pname**                      | **Type** | **Initial Value** | **Valid Range** |
 * | :----------------------------- | :------- | :---------------- | :-------------- |
 * | {@link GL_PACK_SWAP_BYTES}     | boolean  | false             | true or false   |
 * | {@link GL_PACK_LSB_FIRST}      | boolean  | false             | true or false   |
 * | {@link GL_PACK_ROW_LENGTH}     | integer  | 0                 | [0,∞)           |
 * | {@link GL_PACK_IMAGE_HEIGHT}   | integer  | 0                 | [0,∞)           |
 * | {@link GL_PACK_SKIP_ROWS}      | integer  | 0                 | [0,∞)           |
 * | {@link GL_PACK_SKIP_PIXELS}    | integer  | 0                 | [0,∞)           |
 * | {@link GL_PACK_SKIP_IMAGES}    | integer  | 0                 | [0,∞)           |
 * | {@link GL_PACK_ALIGNMENT}      | integer  | 4                 | 1, 2, 4, or 8   |
 * | {@link GL_UNPACK_SWAP_BYTES}   | boolean  | false             | true or false   |
 * | {@link GL_UNPACK_LSB_FIRST}    | boolean  | false             | true or false   |
 * | {@link GL_UNPACK_ROW_LENGTH}   | integer  | 0                 | [0,∞)           |
 * | {@link GL_UNPACK_IMAGE_HEIGHT} | integer  | 0                 | [0,∞)           |
 * | {@link GL_UNPACK_SKIP_ROWS}    | integer  | 0                 | [0,∞)           |
 * | {@link GL_UNPACK_SKIP_PIXELS}  | integer  | 0                 | [0,∞)           |
 * | {@link GL_UNPACK_SKIP_IMAGES}  | integer  | 0                 | [0,∞)           |
 * | {@link GL_UNPACK_ALIGNMENT}    | integer  | 4                 | 1, 2, 4, or 8   |
 *
 * `glPixelStoref` can be used to set any pixel store parameter. If the parameter type is boolean, then if **param** is 0, the parameter is false; otherwise it is set to true. If **pname** is a integer type parameter, **param** is rounded to the nearest integer.
 *
 * Likewise, `glPixelStorei` can also be used to set any of the pixel store parameters. Boolean parameters are set to false if **param** is 0 and true otherwise.
 *
 * @summary set pixel storage modes
 * @param pname Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: {@link GL_PACK_SWAP_BYTES}, {@link GL_PACK_LSB_FIRST}, {@link GL_PACK_ROW_LENGTH}, {@link GL_PACK_IMAGE_HEIGHT}, {@link GL_PACK_SKIP_PIXELS}, {@link GL_PACK_SKIP_ROWS}, {@link GL_PACK_SKIP_IMAGES}, and {@link GL_PACK_ALIGNMENT}. Six more affect the unpacking of pixel data **from** memory: {@link GL_UNPACK_SWAP_BYTES}, {@link GL_UNPACK_LSB_FIRST}, {@link GL_UNPACK_ROW_LENGTH}, {@link GL_UNPACK_IMAGE_HEIGHT}, {@link GL_UNPACK_SKIP_PIXELS}, {@link GL_UNPACK_SKIP_ROWS}, {@link GL_UNPACK_SKIP_IMAGES}, and {@link GL_UNPACK_ALIGNMENT}.
 * @param param Specifies the value that **pname** is set to.
 * @see [glPixelStore](https://docs.gl/gl3/glPixelStore)
 */
export function glPixelStorei(pname: GLenum, param: GLint): void;

/**
 * `glPixelStore` sets pixel storage modes that affect the operation of subsequent {@link glReadPixels} as well as the unpacking of texture patterns (see {@link glTexImage1D}, {@link glTexImage2D}, {@link glTexImage3D}, {@link glTexSubImage1D}, {@link glTexSubImage2D}, {@link glTexSubImage3D}).
 *
 * **pname** is a symbolic constant indicating the parameter to be set, and **param** is the new value. Six of the twelve storage parameters affect how pixel data is returned to client memory. They are as follows:
 *
 * - {@link GL_PACK_SWAP_BYTES}
 *  If true, byte ordering for multibyte color components, depth components, or stencil indices is reversed. That is, if a four-byte component consists of bytes 𝐛₀, 𝐛₁, 𝐛₂, 𝐛₃, it is stored in memory as 𝐛₃, 𝐛₂, 𝐛₁, 𝐛₀ if {@link GL_PACK_SWAP_BYTES} is true. {@link GL_PACK_SWAP_BYTES} has no effect on the memory order of components within a pixel, only on the order of bytes within components or indices. For example, the three components of a {@link GL_RGB} format pixel are always stored with red first, green second, and blue third, regardless of the value of {@link GL_PACK_SWAP_BYTES}.
 *
 * - {@link GL_PACK_LSB_FIRST}
 * If true, bits are ordered within a byte from least significant to most significant; otherwise, the first bit in each byte is the most significant one.
 *
 * - {@link GL_PACK_ROW_LENGTH}
 * If greater than 0, {@link GL_PACK_ROW_LENGTH} defines the number of pixels in a row. If the first pixel of a row is placed at location 𝐩 in memory, then the location of the first pixel of the next row is obtained by skipping
 *
 * ㅤㅤ ⎧ㅤㅤ𝐧𝐥ㅤㅤㅤㅤ𝐬 >= 𝐚
 *
 * 𝒌 = ⎨
 *
 * ㅤㅤ ⎩ 𝐚/𝐬⌈𝐬𝐧𝐥/𝐚⌉ㅤㅤ𝐬 < 𝐚
 *
 * components or indices, where 𝐧 is the number of components or indices in a pixel, 𝐥 is the number of pixels in a row ({@link GL_PACK_ROW_LENGTH} if it is greater than 0, the *width* argument to the pixel routine otherwise), 𝐚 is the value of {@link GL_PACK_ALIGNMENT}, and 𝐬 is the size, in bytes, of a single component (if 𝐚 < 𝐬, then it is as if 𝐚 = 𝐬). In the case of 1-bit values, the location of the next row is obtained by skipping
 *
 * 𝒌 = 8𝐚⌈𝐧𝐥/8𝐚⌉
 *
 * components or indices.
 *
 * The word **component** in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format {@link GL_RGB}, for example, has three components per pixel: first red, then green, and finally blue.
 *
 * - {@link GL_PACK_IMAGE_HEIGHT}
 * If greater than 0, {@link GL_PACK_IMAGE_HEIGHT} defines the number of pixels in an image three-dimensional texture volume, where ``image'' is defined by all pixels sharing the same third dimension index. If the first pixel of a row is placed at location 𝐩 in memory, then the location of the first pixel of the next row is obtained by skipping
 *
 * ㅤㅤ ⎧ㅤㅤ𝐧𝐥𝐡ㅤㅤㅤㅤ𝐬 >= 𝐚
 *
 * 𝒌 = ⎨
 *
 * ㅤㅤ ⎩ 𝐚/𝐬⌈𝐬𝐧𝐥𝐡/𝐚⌉ㅤㅤ𝐬 < 𝐚
 *
 * components or indices, where 𝐧 is the number of components or indices in a pixel, 𝑙 is the number of pixels in a row ({@link GL_PACK_ROW_LENGTH} if it is greater than 0, the *width* argument to {@link glTexImage3D} otherwise), 𝐡 is the number of rows in a pixel image ({@link GL_PACK_IMAGE_HEIGHT} if it is greater than 0, the *height* argument to the {@link glTexImage3D} routine otherwise), 𝐚 is the value of {@link GL_PACK_ALIGNMENT}, and 𝐬 is the size, in bytes, of a single component (if 𝐚 < 𝐬, then it is as if 𝐚 = 𝐬).
 *
 * The word **component** in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format {@link GL_RGB}, for example, has three components per pixel: first red, then green, and finally blue.
 *
 * - {@link GL_PACK_SKIP_PIXELS}, {@link GL_PACK_SKIP_ROWS}, and {@link GL_PACK_SKIP_IMAGES}
 * These values are provided as a convenience to the programmer; they provide no functionality that cannot be duplicated simply by incrementing the pointer passed to {@link glReadPixels}. Setting {@link GL_PACK_SKIP_PIXELS} to 𝐢 is equivalent to incrementing the pointer by 𝐢𝐧 components or indices, where 𝐧 is the number of components or indices in each pixel. Setting {@link GL_PACK_SKIP_ROWS} to 𝐣 is equivalent to incrementing the pointer by 𝐣𝐦 components or indices, where 𝐦 is the number of components or indices per row, as just computed in the {@link GL_PACK_ROW_LENGTH} section. Setting {@link GL_PACK_SKIP_IMAGES} to 𝐤 is equivalent to incrementing the pointer by 𝐤𝐩, where 𝐩 is the number of components or indices per image, as computed in the {@link GL_PACK_IMAGE_HEIGHT} section.
 *
 * - {@link GL_PACK_ALIGNMENT}
 *     Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries).
 *
 * The other six of the twelve storage parameters affect how pixel data is read from client memory. These values are significant for {@link glTexImage1D}, {@link glTexImage2D}, {@link glTexImage3D}, {@link glTexSubImage1D}, {@link glTexSubImage2D}, and {@link glTexSubImage3D}
 *
 * They are as follows:
 *
 * - {@link GL_UNPACK_SWAP_BYTES}
 * If true, byte ordering for multibyte color components, depth components, or stencil indices is reversed. That is, if a four-byte component consists of bytes 𝐛₀, 𝐛₁, 𝐛₂, 𝐛₃, it is stored in memory as 𝐛₃, 𝐛₂, 𝐛₁, 𝐛₀ if {@link GL_UNPACK_SWAP_BYTES} is true. {@link GL_UNPACK_SWAP_BYTES} has no effect on the memory order of components within a pixel, only on the order of bytes within components or indices. For example, the three components of a {@link GL_RGB} format pixel are always stored with red first, green second, and blue third, regardless of the value of {@link GL_UNPACK_SWAP_BYTES}.
 *
 * - {@link GL_UNPACK_LSB_FIRST}
 * If true, bits are ordered within a byte from least significant to most significant; otherwise, the first bit in each byte is the most significant one.
 *
 * - {@link GL_UNPACK_ROW_LENGTH}
 * If greater than 0, {@link GL_UNPACK_ROW_LENGTH} defines the number of pixels in a row. If the first pixel of a row is placed at location 𝐩 in memory, then the location of the first pixel of the next row is obtained by skipping
 *
 * ㅤㅤ ⎧ㅤㅤ𝐧𝐥ㅤㅤㅤㅤ𝐬 >= 𝐚
 *
 * 𝒌 = ⎨
 *
 * ㅤㅤ ⎩ 𝐚/𝐬⌈𝐬𝐧𝐥/𝐚⌉ㅤㅤ𝐬 < 𝐚
 *
 * components or indices, where 𝐧 is the number of components or indices in a pixel, 𝐥 is the number of pixels in a row ({@link GL_UNPACK_ROW_LENGTH} if it is greater than 0, the *width* argument to the pixel routine otherwise), 𝐚 is the value of {@link GL_UNPACK_ALIGNMENT}, and 𝐬 is the size, in bytes, of a single component (if 𝐚 < 𝐬, then it is as if 𝐚 = 𝐬). In the case of 1-bit values, the location of the next row is obtained by skipping
 *
 * 𝒌 = 8𝐚⌈𝐧𝐥/8𝐚⌉
 *
 * components or indices.
 *
 * The word **component** in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format {@link GL_RGB}, for example, has three components per pixel: first red, then green, and finally blue.
 *
 * - {@link GL_UNPACK_IMAGE_HEIGHT}
 * If greater than 0, {@link GL_UNPACK_IMAGE_HEIGHT} defines the number of pixels in an image three-dimensional texture volume, where ``image'' is defined by all pixels sharing the same third dimension index. If the first pixel of a row is placed at location 𝐩 in memory, then the location of the first pixel of the next row is obtained by skipping
 *
 * ㅤㅤ ⎧ㅤㅤ𝐧𝐥𝐡ㅤㅤㅤㅤ𝐬 >= 𝐚
 *
 * 𝒌 = ⎨
 *
 * ㅤㅤ ⎩ 𝐚/𝐬⌈𝐬𝐧𝐥𝐡/𝐚⌉ㅤㅤ𝐬 < 𝐚
 *
 * components or indices, where 𝐧 is the number of components or indices in a pixel, 𝑙 is the number of pixels in a row ({@link GL_UNPACK_ROW_LENGTH} if it is greater than 0, the *width* argument to the pixel routine otherwise), 𝐡 is the number of rows in a pixel image ({@link GL_UNPACK_IMAGE_HEIGHT} if it is greater than 0, the *height* argument to the pixel routine otherwise), 𝐚 is the value of {@link GL_UNPACK_ALIGNMENT}, and 𝐬 is the size, in bytes, of a single component (if 𝐚 < 𝐬, then it is as if 𝐚 = 𝐬).
 *
 * The word **component** in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format {@link GL_RGB}, for example, has three components per pixel: first red, then green, and finally blue.
 *
 * - {@link GL_UNPACK_SKIP_PIXELS} and {@link GL_UNPACK_SKIP_ROWS}
 * These values are provided as a convenience to the programmer; they provide no functionality that cannot be duplicated by incrementing the pointer passed to {@link glTexImage1D}, {@link glTexImage2D}, {@link glTexSubImage1D} or {@link glTexSubImage2D}. Setting {@link GL_UNPACK_SKIP_PIXELS} to 𝐢 is equivalent to incrementing the pointer by 𝐢𝐧 components or indices, where 𝐧 is the number of components or indices in each pixel. Setting {@link GL_UNPACK_SKIP_ROWS} to 𝐣 is equivalent to incrementing the pointer by 𝐣𝐤 components or indices, where 𝐤 is the number of components or indices per row, as just computed in the {@link GL_UNPACK_ROW_LENGTH} section.
 *
 * - {@link GL_UNPACK_ALIGNMENT}
 * Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries).
 *
 * The following table gives the type, initial value, and range of valid values for each storage parameter that can be set with `glPixelStore`.
 *
 * | **pname**                      | **Type** | **Initial Value** | **Valid Range** |
 * | :----------------------------- | :------- | :---------------- | :-------------- |
 * | {@link GL_PACK_SWAP_BYTES}     | boolean  | false             | true or false   |
 * | {@link GL_PACK_LSB_FIRST}      | boolean  | false             | true or false   |
 * | {@link GL_PACK_ROW_LENGTH}     | integer  | 0                 | [0,∞)           |
 * | {@link GL_PACK_IMAGE_HEIGHT}   | integer  | 0                 | [0,∞)           |
 * | {@link GL_PACK_SKIP_ROWS}      | integer  | 0                 | [0,∞)           |
 * | {@link GL_PACK_SKIP_PIXELS}    | integer  | 0                 | [0,∞)           |
 * | {@link GL_PACK_SKIP_IMAGES}    | integer  | 0                 | [0,∞)           |
 * | {@link GL_PACK_ALIGNMENT}      | integer  | 4                 | 1, 2, 4, or 8   |
 * | {@link GL_UNPACK_SWAP_BYTES}   | boolean  | false             | true or false   |
 * | {@link GL_UNPACK_LSB_FIRST}    | boolean  | false             | true or false   |
 * | {@link GL_UNPACK_ROW_LENGTH}   | integer  | 0                 | [0,∞)           |
 * | {@link GL_UNPACK_IMAGE_HEIGHT} | integer  | 0                 | [0,∞)           |
 * | {@link GL_UNPACK_SKIP_ROWS}    | integer  | 0                 | [0,∞)           |
 * | {@link GL_UNPACK_SKIP_PIXELS}  | integer  | 0                 | [0,∞)           |
 * | {@link GL_UNPACK_SKIP_IMAGES}  | integer  | 0                 | [0,∞)           |
 * | {@link GL_UNPACK_ALIGNMENT}    | integer  | 4                 | 1, 2, 4, or 8   |
 *
 * `glPixelStoref` can be used to set any pixel store parameter. If the parameter type is boolean, then if **param** is 0, the parameter is false; otherwise it is set to true. If **pname** is a integer type parameter, **param** is rounded to the nearest integer.
 *
 * Likewise, `glPixelStorei` can also be used to set any of the pixel store parameters. Boolean parameters are set to false if **param** is 0 and true otherwise.
 *
 * @summary set pixel storage modes
 * @param pname Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: {@link GL_PACK_SWAP_BYTES}, {@link GL_PACK_LSB_FIRST}, {@link GL_PACK_ROW_LENGTH}, {@link GL_PACK_IMAGE_HEIGHT}, {@link GL_PACK_SKIP_PIXELS}, {@link GL_PACK_SKIP_ROWS}, {@link GL_PACK_SKIP_IMAGES}, and {@link GL_PACK_ALIGNMENT}. Six more affect the unpacking of pixel data **from** memory: {@link GL_UNPACK_SWAP_BYTES}, {@link GL_UNPACK_LSB_FIRST}, {@link GL_UNPACK_ROW_LENGTH}, {@link GL_UNPACK_IMAGE_HEIGHT}, {@link GL_UNPACK_SKIP_PIXELS}, {@link GL_UNPACK_SKIP_ROWS}, {@link GL_UNPACK_SKIP_IMAGES}, and {@link GL_UNPACK_ALIGNMENT}.
 * @param param Specifies the value that **pname** is set to.
 * @see [glPixelStore](https://docs.gl/gl3/glPixelStore)
 */
export function glPixelTransferf(pname: GLenum, param: GLfloat): void;

/**
 * `glPixelStore` sets pixel storage modes that affect the operation of subsequent {@link glReadPixels} as well as the unpacking of texture patterns (see {@link glTexImage1D}, {@link glTexImage2D}, {@link glTexImage3D}, {@link glTexSubImage1D}, {@link glTexSubImage2D}, {@link glTexSubImage3D}).
 *
 * **pname** is a symbolic constant indicating the parameter to be set, and **param** is the new value. Six of the twelve storage parameters affect how pixel data is returned to client memory. They are as follows:
 *
 * - {@link GL_PACK_SWAP_BYTES}
 *  If true, byte ordering for multibyte color components, depth components, or stencil indices is reversed. That is, if a four-byte component consists of bytes 𝐛₀, 𝐛₁, 𝐛₂, 𝐛₃, it is stored in memory as 𝐛₃, 𝐛₂, 𝐛₁, 𝐛₀ if {@link GL_PACK_SWAP_BYTES} is true. {@link GL_PACK_SWAP_BYTES} has no effect on the memory order of components within a pixel, only on the order of bytes within components or indices. For example, the three components of a {@link GL_RGB} format pixel are always stored with red first, green second, and blue third, regardless of the value of {@link GL_PACK_SWAP_BYTES}.
 *
 * - {@link GL_PACK_LSB_FIRST}
 * If true, bits are ordered within a byte from least significant to most significant; otherwise, the first bit in each byte is the most significant one.
 *
 * - {@link GL_PACK_ROW_LENGTH}
 * If greater than 0, {@link GL_PACK_ROW_LENGTH} defines the number of pixels in a row. If the first pixel of a row is placed at location 𝐩 in memory, then the location of the first pixel of the next row is obtained by skipping
 *
 * ㅤㅤ ⎧ㅤㅤ𝐧𝐥ㅤㅤㅤㅤ𝐬 >= 𝐚
 *
 * 𝒌 = ⎨
 *
 * ㅤㅤ ⎩ 𝐚/𝐬⌈𝐬𝐧𝐥/𝐚⌉ㅤㅤ𝐬 < 𝐚
 *
 * components or indices, where 𝐧 is the number of components or indices in a pixel, 𝐥 is the number of pixels in a row ({@link GL_PACK_ROW_LENGTH} if it is greater than 0, the *width* argument to the pixel routine otherwise), 𝐚 is the value of {@link GL_PACK_ALIGNMENT}, and 𝐬 is the size, in bytes, of a single component (if 𝐚 < 𝐬, then it is as if 𝐚 = 𝐬). In the case of 1-bit values, the location of the next row is obtained by skipping
 *
 * 𝒌 = 8𝐚⌈𝐧𝐥/8𝐚⌉
 *
 * components or indices.
 *
 * The word **component** in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format {@link GL_RGB}, for example, has three components per pixel: first red, then green, and finally blue.
 *
 * - {@link GL_PACK_IMAGE_HEIGHT}
 * If greater than 0, {@link GL_PACK_IMAGE_HEIGHT} defines the number of pixels in an image three-dimensional texture volume, where ``image'' is defined by all pixels sharing the same third dimension index. If the first pixel of a row is placed at location 𝐩 in memory, then the location of the first pixel of the next row is obtained by skipping
 *
 * ㅤㅤ ⎧ㅤㅤ𝐧𝐥𝐡ㅤㅤㅤㅤ𝐬 >= 𝐚
 *
 * 𝒌 = ⎨
 *
 * ㅤㅤ ⎩ 𝐚/𝐬⌈𝐬𝐧𝐥𝐡/𝐚⌉ㅤㅤ𝐬 < 𝐚
 *
 * components or indices, where 𝐧 is the number of components or indices in a pixel, 𝑙 is the number of pixels in a row ({@link GL_PACK_ROW_LENGTH} if it is greater than 0, the *width* argument to {@link glTexImage3D} otherwise), 𝐡 is the number of rows in a pixel image ({@link GL_PACK_IMAGE_HEIGHT} if it is greater than 0, the *height* argument to the {@link glTexImage3D} routine otherwise), 𝐚 is the value of {@link GL_PACK_ALIGNMENT}, and 𝐬 is the size, in bytes, of a single component (if 𝐚 < 𝐬, then it is as if 𝐚 = 𝐬).
 *
 * The word **component** in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format {@link GL_RGB}, for example, has three components per pixel: first red, then green, and finally blue.
 *
 * - {@link GL_PACK_SKIP_PIXELS}, {@link GL_PACK_SKIP_ROWS}, and {@link GL_PACK_SKIP_IMAGES}
 * These values are provided as a convenience to the programmer; they provide no functionality that cannot be duplicated simply by incrementing the pointer passed to {@link glReadPixels}. Setting {@link GL_PACK_SKIP_PIXELS} to 𝐢 is equivalent to incrementing the pointer by 𝐢𝐧 components or indices, where 𝐧 is the number of components or indices in each pixel. Setting {@link GL_PACK_SKIP_ROWS} to 𝐣 is equivalent to incrementing the pointer by 𝐣𝐦 components or indices, where 𝐦 is the number of components or indices per row, as just computed in the {@link GL_PACK_ROW_LENGTH} section. Setting {@link GL_PACK_SKIP_IMAGES} to 𝐤 is equivalent to incrementing the pointer by 𝐤𝐩, where 𝐩 is the number of components or indices per image, as computed in the {@link GL_PACK_IMAGE_HEIGHT} section.
 *
 * - {@link GL_PACK_ALIGNMENT}
 *     Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries).
 *
 * The other six of the twelve storage parameters affect how pixel data is read from client memory. These values are significant for {@link glTexImage1D}, {@link glTexImage2D}, {@link glTexImage3D}, {@link glTexSubImage1D}, {@link glTexSubImage2D}, and {@link glTexSubImage3D}
 *
 * They are as follows:
 *
 * - {@link GL_UNPACK_SWAP_BYTES}
 * If true, byte ordering for multibyte color components, depth components, or stencil indices is reversed. That is, if a four-byte component consists of bytes 𝐛₀, 𝐛₁, 𝐛₂, 𝐛₃, it is stored in memory as 𝐛₃, 𝐛₂, 𝐛₁, 𝐛₀ if {@link GL_UNPACK_SWAP_BYTES} is true. {@link GL_UNPACK_SWAP_BYTES} has no effect on the memory order of components within a pixel, only on the order of bytes within components or indices. For example, the three components of a {@link GL_RGB} format pixel are always stored with red first, green second, and blue third, regardless of the value of {@link GL_UNPACK_SWAP_BYTES}.
 *
 * - {@link GL_UNPACK_LSB_FIRST}
 * If true, bits are ordered within a byte from least significant to most significant; otherwise, the first bit in each byte is the most significant one.
 *
 * - {@link GL_UNPACK_ROW_LENGTH}
 * If greater than 0, {@link GL_UNPACK_ROW_LENGTH} defines the number of pixels in a row. If the first pixel of a row is placed at location 𝐩 in memory, then the location of the first pixel of the next row is obtained by skipping
 *
 * ㅤㅤ ⎧ㅤㅤ𝐧𝐥ㅤㅤㅤㅤ𝐬 >= 𝐚
 *
 * 𝒌 = ⎨
 *
 * ㅤㅤ ⎩ 𝐚/𝐬⌈𝐬𝐧𝐥/𝐚⌉ㅤㅤ𝐬 < 𝐚
 *
 * components or indices, where 𝐧 is the number of components or indices in a pixel, 𝐥 is the number of pixels in a row ({@link GL_UNPACK_ROW_LENGTH} if it is greater than 0, the *width* argument to the pixel routine otherwise), 𝐚 is the value of {@link GL_UNPACK_ALIGNMENT}, and 𝐬 is the size, in bytes, of a single component (if 𝐚 < 𝐬, then it is as if 𝐚 = 𝐬). In the case of 1-bit values, the location of the next row is obtained by skipping
 *
 * 𝒌 = 8𝐚⌈𝐧𝐥/8𝐚⌉
 *
 * components or indices.
 *
 * The word **component** in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format {@link GL_RGB}, for example, has three components per pixel: first red, then green, and finally blue.
 *
 * - {@link GL_UNPACK_IMAGE_HEIGHT}
 * If greater than 0, {@link GL_UNPACK_IMAGE_HEIGHT} defines the number of pixels in an image three-dimensional texture volume, where ``image'' is defined by all pixels sharing the same third dimension index. If the first pixel of a row is placed at location 𝐩 in memory, then the location of the first pixel of the next row is obtained by skipping
 *
 * ㅤㅤ ⎧ㅤㅤ𝐧𝐥𝐡ㅤㅤㅤㅤ𝐬 >= 𝐚
 *
 * 𝒌 = ⎨
 *
 * ㅤㅤ ⎩ 𝐚/𝐬⌈𝐬𝐧𝐥𝐡/𝐚⌉ㅤㅤ𝐬 < 𝐚
 *
 * components or indices, where 𝐧 is the number of components or indices in a pixel, 𝑙 is the number of pixels in a row ({@link GL_UNPACK_ROW_LENGTH} if it is greater than 0, the *width* argument to the pixel routine otherwise), 𝐡 is the number of rows in a pixel image ({@link GL_UNPACK_IMAGE_HEIGHT} if it is greater than 0, the *height* argument to the pixel routine otherwise), 𝐚 is the value of {@link GL_UNPACK_ALIGNMENT}, and 𝐬 is the size, in bytes, of a single component (if 𝐚 < 𝐬, then it is as if 𝐚 = 𝐬).
 *
 * The word **component** in this description refers to the nonindex values red, green, blue, alpha, and depth. Storage format {@link GL_RGB}, for example, has three components per pixel: first red, then green, and finally blue.
 *
 * - {@link GL_UNPACK_SKIP_PIXELS} and {@link GL_UNPACK_SKIP_ROWS}
 * These values are provided as a convenience to the programmer; they provide no functionality that cannot be duplicated by incrementing the pointer passed to {@link glTexImage1D}, {@link glTexImage2D}, {@link glTexSubImage1D} or {@link glTexSubImage2D}. Setting {@link GL_UNPACK_SKIP_PIXELS} to 𝐢 is equivalent to incrementing the pointer by 𝐢𝐧 components or indices, where 𝐧 is the number of components or indices in each pixel. Setting {@link GL_UNPACK_SKIP_ROWS} to 𝐣 is equivalent to incrementing the pointer by 𝐣𝐤 components or indices, where 𝐤 is the number of components or indices per row, as just computed in the {@link GL_UNPACK_ROW_LENGTH} section.
 *
 * - {@link GL_UNPACK_ALIGNMENT}
 * Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries).
 *
 * The following table gives the type, initial value, and range of valid values for each storage parameter that can be set with `glPixelStore`.
 *
 * | **pname**                      | **Type** | **Initial Value** | **Valid Range** |
 * | :----------------------------- | :------- | :---------------- | :-------------- |
 * | {@link GL_PACK_SWAP_BYTES}     | boolean  | false             | true or false   |
 * | {@link GL_PACK_LSB_FIRST}      | boolean  | false             | true or false   |
 * | {@link GL_PACK_ROW_LENGTH}     | integer  | 0                 | [0,∞)           |
 * | {@link GL_PACK_IMAGE_HEIGHT}   | integer  | 0                 | [0,∞)           |
 * | {@link GL_PACK_SKIP_ROWS}      | integer  | 0                 | [0,∞)           |
 * | {@link GL_PACK_SKIP_PIXELS}    | integer  | 0                 | [0,∞)           |
 * | {@link GL_PACK_SKIP_IMAGES}    | integer  | 0                 | [0,∞)           |
 * | {@link GL_PACK_ALIGNMENT}      | integer  | 4                 | 1, 2, 4, or 8   |
 * | {@link GL_UNPACK_SWAP_BYTES}   | boolean  | false             | true or false   |
 * | {@link GL_UNPACK_LSB_FIRST}    | boolean  | false             | true or false   |
 * | {@link GL_UNPACK_ROW_LENGTH}   | integer  | 0                 | [0,∞)           |
 * | {@link GL_UNPACK_IMAGE_HEIGHT} | integer  | 0                 | [0,∞)           |
 * | {@link GL_UNPACK_SKIP_ROWS}    | integer  | 0                 | [0,∞)           |
 * | {@link GL_UNPACK_SKIP_PIXELS}  | integer  | 0                 | [0,∞)           |
 * | {@link GL_UNPACK_SKIP_IMAGES}  | integer  | 0                 | [0,∞)           |
 * | {@link GL_UNPACK_ALIGNMENT}    | integer  | 4                 | 1, 2, 4, or 8   |
 *
 * `glPixelStoref` can be used to set any pixel store parameter. If the parameter type is boolean, then if **param** is 0, the parameter is false; otherwise it is set to true. If **pname** is a integer type parameter, **param** is rounded to the nearest integer.
 *
 * Likewise, `glPixelStorei` can also be used to set any of the pixel store parameters. Boolean parameters are set to false if **param** is 0 and true otherwise.
 *
 * @summary set pixel storage modes
 * @param pname Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: {@link GL_PACK_SWAP_BYTES}, {@link GL_PACK_LSB_FIRST}, {@link GL_PACK_ROW_LENGTH}, {@link GL_PACK_IMAGE_HEIGHT}, {@link GL_PACK_SKIP_PIXELS}, {@link GL_PACK_SKIP_ROWS}, {@link GL_PACK_SKIP_IMAGES}, and {@link GL_PACK_ALIGNMENT}. Six more affect the unpacking of pixel data **from** memory: {@link GL_UNPACK_SWAP_BYTES}, {@link GL_UNPACK_LSB_FIRST}, {@link GL_UNPACK_ROW_LENGTH}, {@link GL_UNPACK_IMAGE_HEIGHT}, {@link GL_UNPACK_SKIP_PIXELS}, {@link GL_UNPACK_SKIP_ROWS}, {@link GL_UNPACK_SKIP_IMAGES}, and {@link GL_UNPACK_ALIGNMENT}.
 * @param param Specifies the value that **pname** is set to.
 * @see [glPixelStore](https://docs.gl/gl3/glPixelStore)
 */
export function glPixelTransferi(pname: GLenum, param: GLint): void;

/**
 * `glPixelZoom` specifies values for the 𝐱 and 𝐲 zoom factors. During the execution of {@link glDrawPixels} or {@link glCopyPixels}, if (𝐱𝐫, 𝐲𝐫) is the current raster position, and a given element is in the 𝐦ᵗʰ and 𝐧ᵗʰ column of the pixel rectangle, then pixels whose centers are in the rectangle with corners at
 *
 * (𝐱𝐫 + 𝐧⋅*xfactor*, 𝐲𝐫 + 𝐦⋅*yfactor*)
 *
 * (𝐱𝐫 + (𝐧 + 1)⋅*xfactor*, 𝐲𝐫 + (𝐦 + 1)⋅*yfactor*)
 *
 * are candidates for replacement. Any pixel whose center lies on the bottom or left edge of this rectangular region is also modified.
 *
 * Pixel zoom factors are not limited to positive values. Negative zoom factors reflect the resulting image about the current raster position.
 *
 * @summary specify the pixel zoom factors
 * @param xfactor Specifies the 𝐱 zoom factor for pixel write operations.
 * @param yfactor Specifies the 𝐲 zoom factor for pixel write operations.
 * @see [glPixelZoom](https://docs.gl/gl3/glPixelZoom)
 */
export function glPixelZoom(): void;

/**
 * `glPointSize` specifies the rasterized diameter of points. If point size mode is disabled (see {@link glEnable} with parameter {@link GL_PROGRAM_POINT_SIZE}), this value will be used to rasterize points. Otherwise, the value written to the shading language built-in variable gl_PointSize will be used.
 *
 * @summary specify the diameter of rasterized points
 * @param size Specifies the diameter of rasterized points. The initial value is 1.
 * @see [glPointSize](https://docs.gl/gl3/glPointSize)
 */
export function glPointSize(size: GLfloat): void;

/**
 * `glPolygonMode` controls the interpretation of polygons for rasterization. **face** describes which polygons **mode** applies to: both front and back-facing polygons ({@link GL_FRONT_AND_BACK}). The polygon mode affects only the final rasterization of polygons. In particular, a polygon's vertices are lit and the polygon is clipped and possibly culled before these modes are applied.
 *
 * Three modes are defined and can be specified in **mode**:
 *
 * - {@link GL_POINT}
 * Polygon vertices that are marked as the start of a boundary edge are drawn as points. Point attributes such as {@link GL_POINT_SIZE} and {@link GL_POINT_SMOOTH} control the rasterization of the points. Polygon rasterization attributes other than {@link GL_POLYGON_MODE} have no effect.
 *
 * - {@link GL_LINE}
 * Boundary edges of the polygon are drawn as line segments. Line attributes such as {@link GL_LINE_WIDTH} and {@link GL_LINE_SMOOTH} control the rasterization of the lines. Polygon rasterization attributes other than {@link GL_POLYGON_MODE} have no effect.
 *
 * - {@link GL_FILL}
 * The interior of the polygon is filled. Polygon attributes such as {@link GL_POLYGON_SMOOTH} control the rasterization of the polygon.
 *
 * @summary select a polygon rasterization mode
 * @param face Specifies the polygons that **mode** applies to. Must be {@link GL_FRONT_AND_BACK} for front- and back-facing polygons.
 * @param mode Specifies how polygons will be rasterized. Accepted values are {@link GL_POINT}, {@link GL_LINE}, and {@link GL_FILL}. The initial value is {@link GL_FILL} for both front- and back-facing polygons.
 * @example To draw a surface with outlined polygons, call
 * ```
 * glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
 * ```
 * @see [glPolygonMode](https://docs.gl/gl3/glPolygonMode)
 */
export function glPolygonMode(face: GLenum, mode: GLenum): void;

/**
 * When {@link GL_POLYGON_OFFSET_FILL}, {@link GL_POLYGON_OFFSET_LINE}, or {@link GL_POLYGON_OFFSET_POINT} is enabled, each fragment's **depth** value will be offset after it is interpolated from the **depth** values of the appropriate vertices. The value of the offset is *factor* × 𝐃𝐙 + 𝐫 × *units*, where 𝐃𝐙 is a measurement of the change in depth relative to the screen area of the polygon, and 𝐫 is the smallest value that is guaranteed to produce a resolvable offset for a given implementation. The offset is added before the depth test is performed and before the value is written into the depth buffer.
 *
 * `glPolygonOffset` is useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges.
 *
 * @summary set the scale and units used to calculate depth values
 * @param factor Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0.
 * @param units Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0.
 * @see [glPolygonOffset](https://docs.gl/gl3/glPolygonOffset)
 */
export function glPolygonOffset(factor: GLfloat, units: GLfloat): void;

/**
 * Polygon stippling, like line stippling (see {@link glLineStipple}), masks out certain fragments produced by rasterization, creating a pattern. Stippling is independent of polygon antialiasing.
 *
 * **pattern** is a pointer to a 32 × 32 stipple pattern that is stored in memory just like the pixel data supplied to a {@link glDrawPixels} call with **** height and **width** both equal to 32, a pixel format of {@link GL_COLOR_INDEX}, and data type of {@link GL_BITMAP}. That is, the stipple pattern is represented as a 32 × 32 array of 1-bit color indices packed in unsigned bytes. {@link glPixelStore} parameters like {@link GL_UNPACK_SWAP_BYTES} and {@link GL_UNPACK_LSB_FIRST} affect the assembling of the bits into a stipple pattern. Pixel transfer operations (shift, offset, pixel map) are not applied to the stipple image, however.
 *
 * If a non-zero named buffer object is bound to the {@link GL_PIXEL_UNPACK_BUFFER} target (see {@link glBindBuffer}) while a stipple pattern is specified, **pattern** is treated as a byte offset into the buffer object's data store.
 *
 * To enable and disable polygon stippling, call {@link glEnable} and {@link glDisable} with argument {@link GL_POLYGON_STIPPLE}. Polygon stippling is initially disabled. If it's enabled, a rasterized polygon fragment with window coordinates 𝐱𝑤 and 𝐲𝑤 is sent to the next stage of the GL if and only if the (𝐱𝑤%32)ᵗʰ bit in the (𝐲𝑤%32)ᵗʰ row of the stipple pattern is 1 (one). When polygon stippling is disabled, it is as if the stipple pattern consists of all 1's.
 *
 * @summary set the polygon stippling pattern
 * @param pattern Specifies a pointer to a 32 × 32 stipple pattern that will be unpacked from memory in the same way that {@link glDrawPixels} unpacks pixels.
 * @see [glPolygonStipple](https://docs.gl/gl3/glPolygonStipple)
 */
export function glPolygonStipple(pattern: GLubyte): void;

/**
 * `glPrioritizeTextures` assigns the **n** texture priorities given in **priorities** to the **n** textures named in **textures**.
 *
 * The GL establishes a ``working set'' of textures that are resident in texture memory. These textures may be bound to a texture target much more efficiently than textures that are not resident. By specifying a priority for each texture, `glPrioritizeTextures` allows applications to guide the GL implementation in determining which textures should be resident.
 *
 * The priorities given in **priorities** are clamped to the range [0,1] before they are assigned. 0 indicates the lowest priority; textures with priority 0 are least likely to be resident. 1 indicates the highest priority; textures with priority 1 are most likely to be resident. However, textures are not guaranteed to be resident until they are used.
 *
 * `glPrioritizeTextures` silently ignores attempts to prioritize texture 0 or any texture name that does not correspond to an existing texture.
 *
 * `glPrioritizeTextures` does not require that any of the textures named by **textures** be bound to a texture target. {@link glTexParameter} may also be used to set a texture's priority, but only if the texture is currently bound. This is the only way to set the priority of a default texture.
 *
 * @summary set texture residence priority
 * @param n Specifies the number of textures to be prioritized.
 * @param textures Specifies an array containing the names of the textures to be prioritized.
 * @param priorities Specifies an array containing the texture priorities. A priority given in an element of **priorities** applies to the texture named by the corresponding element of **textures**.
 * @see [glPrioritizeTextures](https://docs.gl/gl3/glPrioritizeTextures)
 */
export function glPrioritizeTextures(
	n: GLsizei,
	textures: GLuint,
	priorities: GLclampf
): void;

/**
 * `glPushAttrib` takes one argument, a mask that indicates which groups of state variables to save on the attribute stack. Symbolic constants are used to set bits in the mask. **mask** is typically constructed by specifying the bitwise-or of several of these constants together. The special mask {@link GL_ALL_ATTRIB_BITS} can be used to save all stackable states.
 *
 * The symbolic mask constants and their associated GL state are as follows (the second column lists which attributes are saved):
 *
 * |                                |                                                                        |
 * | :----------------------------- | :--------------------------------------------------------------------- |
 * | {@link GL_ACCUM_BUFFER_BIT}    | Accumulation buffer clear value                                        |
 * | {@link GL_COLOR_BUFFER_BIT}    | {@link GL_ALPHA_TEST} enable bit                                       |
 * |                                | Alpha test function and reference value                                |
 * |                                | {@link GL_BLEND} enable bit                                            |
 * |                                | Blending source and destination functions                              |
 * |                                | Constant blend color                                                   |
 * |                                | Blending equation                                                      |
 * |                                | {@link GL_DITHER} enable bit                                           |
 * |                                | {@link GL_DRAW_BUFFER} setting                                         |
 * |                                | {@link GL_COLOR_LOGIC_OP} enable bit                                   |
 * |                                | {@link GL_INDEX_LOGIC_OP} enable bit                                   |
 * |                                | Logic op function                                                      |
 * |                                | Color mode and index mode clear values                                 |
 * |                                | Color mode and index mode writemasks                                   |
 * | {@link GL_CURRENT_BIT}         | Current RGBA color                                                     |
 * |                                | Current color index                                                    |
 * |                                | Current normal vector                                                  |
 * |                                | Current texture coordinates                                            |
 * |                                | Current raster position                                                |
 * |                                | {@link GL_CURRENT_RASTER_POSITION_VALID} flag                          |
 * |                                | RGBA color associated with current raster position                     |
 * |                                | Color index associated with current raster position                    |
 * |                                | Texture coordinates associated with current raster position            |
 * |                                | {@link GL_EDGE_FLAG} flag                                              |
 * | {@link GL_DEPTH_BUFFER_BIT}    | {@link GL_DEPTH_TEST} enable bit                                       |
 * |                                | Depth buffer test function                                             |
 * |                                | Depth buffer clear value                                               |
 * |                                | {@link GL_DEPTH_WRITEMASK} enable bit                                  |
 * | {@link GL_ENABLE_BIT}          | {@link GL_ALPHA_TEST} flag                                             |
 * |                                | {@link GL_AUTO_NORMAL} flag                                            |
 * |                                | {@link GL_BLEND} flag                                                  |
 * |                                | Enable bits for the user-definable clipping planes                     |
 * |                                | {@link GL_COLOR_MATERIAL}                                              |
 * |                                | {@link GL_CULL_FACE} flag                                              |
 * |                                | {@link GL_DEPTH_TEST} flag                                             |
 * |                                | {@link GL_DITHER} flag                                                 |
 * |                                | {@link GL_FOG} flag                                                    |
 * |                                | {@link GL_LIGHT}**i** where {@link 0} <= **i** < {@link GL_MAX_LIGHTS} |
 * |                                | {@link GL_LIGHTING} flag                                               |
 * |                                | {@link GL_LINE_SMOOTH} flag                                            |
 * |                                | {@link GL_LINE_STIPPLE} flag                                           |
 * |                                | {@link GL_COLOR_LOGIC_OP} flag                                         |
 * |                                | {@link GL_INDEX_LOGIC_OP} flag                                         |
 * |                                | {@link GL_MAP1_}**x** where **x** is a map type                        |
 * |                                | {@link GL_MAP2_}**x** where **x** is a map type                        |
 * |                                | {@link GL_MULTISAMPLE} flag                                            |
 * |                                | {@link GL_NORMALIZE} flag                                              |
 * |                                | {@link GL_POINT_SMOOTH} flag                                           |
 * |                                | {@link GL_POLYGON_OFFSET_LINE} flag                                    |
 * |                                | {@link GL_POLYGON_OFFSET_FILL} flag                                    |
 * |                                | {@link GL_POLYGON_OFFSET_POINT} flag                                   |
 * |                                | {@link GL_POLYGON_SMOOTH} flag                                         |
 * |                                | {@link GL_POLYGON_STIPPLE} flag                                        |
 * |                                | {@link GL_SAMPLE_ALPHA_TO_COVERAGE} flag                               |
 * |                                | {@link GL_SAMPLE_ALPHA_TO_ONE} flag                                    |
 * |                                | {@link GL_SAMPLE_COVERAGE} flag                                        |
 * |                                | {@link GL_SCISSOR_TEST} flag                                           |
 * |                                | {@link GL_STENCIL_TEST} flag                                           |
 * |                                | {@link GL_TEXTURE_1D} flag                                             |
 * |                                | {@link GL_TEXTURE_2D} flag                                             |
 * |                                | {@link GL_TEXTURE_3D} flag                                             |
 * |                                | Flags {@link GL_TEXTURE_GEN_}**x** where **x** is S, T, R, or Q        |
 * | {@link GL_EVAL_BIT}            | {@link GL_MAP1_}**x** enable bits, where **x** is a map type           |
 * |                                | {@link GL_MAP2_}**x** enable bits, where **x** is a map type           |
 * |                                | 1D grid endpoints and divisions                                        |
 * |                                | 2D grid endpoints and divisions                                        |
 * |                                | {@link GL_AUTO_NORMAL} enable bit                                      |
 * | {@link GL_FOG_BIT}             | {@link GL_FOG} enable bit                                              |
 * |                                | Fog color                                                              |
 * |                                | Fog density                                                            |
 * |                                | Linear fog start                                                       |
 * |                                | Linear fog end                                                         |
 * |                                | Fog index                                                              |
 * |                                | {@link GL_FOG_MODE} value                                              |
 * | {@link GL_HINT_BIT}            | {@link GL_PERSPECTIVE_CORRECTION_HINT} setting                         |
 * |                                | {@link GL_POINT_SMOOTH_HINT} setting                                   |
 * |                                | {@link GL_LINE_SMOOTH_HINT} setting                                    |
 * |                                | {@link GL_POLYGON_SMOOTH_HINT} setting                                 |
 * |                                | {@link GL_FOG_HINT} setting                                            |
 * |                                | {@link GL_GENERATE_MIPMAP_HINT} setting                                |
 * |                                | {@link GL_TEXTURE_COMPRESSION_HINT} setting                            |
 * | {@link GL_LIGHTING_BIT}        | {@link GL_COLOR_MATERIAL} enable bit                                   |
 * |                                | {@link GL_COLOR_MATERIAL_FACE} value                                   |
 * |                                | Color material parameters that are tracking the current color          |
 * |                                | Ambient scene color                                                    |
 * |                                | {@link GL_LIGHT_MODEL_LOCAL_VIEWER} value                              |
 * |                                | {@link GL_LIGHT_MODEL_TWO_SIDE} setting                                |
 * |                                | {@link GL_LIGHTING} enable bit                                         |
 * |                                | Enable bit for each light                                              |
 * |                                | Ambient, diffuse, and specular intensity for each light                |
 * |                                | Direction, position, exponent, and cutoff angle for each light         |
 * |                                | Constant, linear, and quadratic attenuation factors for each light     |
 * |                                | Ambient, diffuse, specular, and emissive color for each material       |
 * |                                | Ambient, diffuse, and specular color indices for each material         |
 * |                                | Specular exponent for each material                                    |
 * |                                | {@link GL_SHADE_MODEL} setting                                         |
 * | {@link GL_LINE_BIT}            | {@link GL_LINE_SMOOTH} flag                                            |
 * |                                | {@link GL_LINE_STIPPLE} enable bit                                     |
 * |                                | Line stipple pattern and repeat counter                                |
 * |                                | Line width                                                             |
 * | {@link GL_LIST_BIT}            | {@link GL_LIST_BASE} setting                                           |
 * | {@link GL_MULTISAMPLE_BIT}     | {@link GL_MULTISAMPLE} flag                                            |
 * |                                | {@link GL_SAMPLE_ALPHA_TO_COVERAGE} flag                               |
 * |                                | {@link GL_SAMPLE_ALPHA_TO_ONE} flag                                    |
 * |                                | {@link GL_SAMPLE_COVERAGE} flag                                        |
 * |                                | {@link GL_SAMPLE_COVERAGE_VALUE} value                                 |
 * |                                | {@link GL_SAMPLE_COVERAGE_INVERT} value                                |
 * | {@link GL_PIXEL_MODE_BIT}      | {@link GL_RED_BIAS} and {@link GL_RED_SCALE} settings                  |
 * |                                | {@link GL_GREEN_BIAS} and {@link GL_GREEN_SCALE} values                |
 * |                                | {@link GL_BLUE_BIAS} and {@link GL_BLUE_SCALE}                         |
 * |                                | {@link GL_ALPHA_BIAS} and {@link GL_ALPHA_SCALE}                       |
 * |                                | {@link GL_DEPTH_BIAS} and {@link GL_DEPTH_SCALE}                       |
 * |                                | {@link GL_INDEX_OFFSET} and {@link GL_INDEX_SHIFT} values              |
 * |                                | {@link GL_MAP_COLOR} and {@link GL_MAP_STENCIL} flags                  |
 * |                                | {@link GL_ZOOM_X} and {@link GL_ZOOM_Y} factors                        |
 * |                                | {@link GL_READ_BUFFER} setting                                         |
 * | {@link GL_POINT_BIT}           | {@link GL_POINT_SMOOTH} flag                                           |
 * |                                | Point size                                                             |
 * | {@link GL_POLYGON_BIT}         | {@link GL_CULL_FACE} enable bit                                        |
 * |                                | {@link GL_CULL_FACE_MODE} value                                        |
 * |                                | {@link GL_FRONT_FACE} indicator                                        |
 * |                                | {@link GL_POLYGON_MODE} setting                                        |
 * |                                | {@link GL_POLYGON_SMOOTH} flag                                         |
 * |                                | {@link GL_POLYGON_STIPPLE} enable bit                                  |
 * |                                | {@link GL_POLYGON_OFFSET_FILL} flag                                    |
 * |                                | {@link GL_POLYGON_OFFSET_LINE} flag                                    |
 * |                                | {@link GL_POLYGON_OFFSET_POINT} flag                                   |
 * |                                | {@link GL_POLYGON_OFFSET_FACTOR}                                       |
 * |                                | {@link GL_POLYGON_OFFSET_UNITS}                                        |
 * | {@link GL_POLYGON_STIPPLE_BIT} | Polygon stipple image                                                  |
 * | {@link GL_SCISSOR_BIT}         | {@link GL_SCISSOR_TEST} flag                                           |
 * |                                | Scissor box                                                            |
 * | {@link GL_STENCIL_BUFFER_BIT}  | {@link GL_STENCIL_TEST} enable bit                                     |
 * |                                | Stencil function and reference value                                   |
 * |                                | Stencil value mask                                                     |
 * |                                | Stencil fail, pass, and depth buffer pass actions                      |
 * |                                | Stencil buffer clear value                                             |
 * |                                | Stencil buffer writemask                                               |
 * | {@link GL_TEXTURE_BIT}         | Enable bits for the four texture coordinates                           |
 * |                                | Border color for each texture image                                    |
 * |                                | Minification function for each texture image                           |
 * |                                | Magnification function for each texture image                          |
 * |                                | Texture coordinates and wrap mode for each texture image               |
 * |                                | Color and mode for each texture environment                            |
 * |                                | Enable bits {@link GL_TEXTURE_GEN_}**x**, **x** is S, T, R, and Q      |
 * |                                | {@link GL_TEXTURE_GEN_MODE} setting for S, T, R, and Q                 |
 * |                                | {@link glTexGen} plane equations for S, T, R, and Q                    |
 * |                                | Current texture bindings (for example, {@link GL_TEXTURE_BINDING_2D})  |
 * | {@link GL_TRANSFORM_BIT}       | Coefficients of the six clipping planes                                |
 * |                                | Enable bits for the user-definable clipping planes                     |
 * |                                | {@link GL_MATRIX_MODE} value                                           |
 * |                                | {@link GL_NORMALIZE} flag                                              |
 * |                                | {@link GL_RESCALE_NORMAL} flag                                         |
 * | {@link GL_VIEWPORT_BIT}        | Depth range (near and far)                                             |
 * |                                | Viewport origin and extent                                             |
 *
 * {@link glPopAttrib} restores the values of the state variables saved with the last `glPushAttrib` command. Those not saved are left unchanged.
 *
 * It is an error to push attributes onto a full stack or to pop attributes off an empty stack. In either case, the error flag is set and no other change is made to GL state.
 *
 * Initially, the attribute stack is empty.
 *
 * @summary push the server attribute stack
 * @param mask Specifies a mask that indicates which attributes to save. Values for **mask** are listed below.
 * @see [glPushAttrib](https://docs.gl/gl3/glPushAttrib)
 */
export function glPushAttrib(mask: GLbitfield): void;

/**
 * `glPopAttrib` restores the values of the state variables saved with the last {@link glPushAttrib} command. Those not saved are left unchanged.
 *
 * It is an error to push attributes onto a full stack or to pop attributes off an empty stack. In either case, the error flag is set and no other change is made to GL state.
 *
 * Initially, the attribute stack is empty.
 *
 * @summary pop the server attribute stack
 * @see [glPushAttrib](https://docs.gl/gl3/glPushAttrib)
 */
export function glPopAttrib(): void;

/**
 * `glPushClientAttrib` takes one argument, a mask that indicates which groups of client-state variables to save on the client attribute stack. Symbolic constants are used to set bits in the mask. **mask** is typically constructed by specifying the bitwise-or of several of these constants together. The special mask {@link GL_CLIENT_ALL_ATTRIB_BITS} can be used to save all stackable client state.
 *
 * The symbolic mask constants and their associated GL client state are as follows (the second column lists which attributes are saved):
 *
 * {@link GL_CLIENT_PIXEL_STORE_BIT} Pixel storage modes {@link GL_CLIENT_VERTEX_ARRAY_BIT} Vertex arrays (and enables)
 *
 * {@link glPopClientAttrib} restores the values of the client-state variables saved with the last `glPushClientAttrib`. Those not saved are left unchanged.
 *
 * It is an error to push attributes onto a full client attribute stack or to pop attributes off an empty stack. In either case, the error flag is set, and no other change is made to GL state.
 *
 * Initially, the client attribute stack is empty.
 *
 * @summary push the client attribute stack
 * @param mask Specifies a mask that indicates which attributes to save. Values for **mask** are listed below.
 * @see [glPushClientAttrib](https://docs.gl/gl3/glPushClientAttrib)
 */
export function glPushClientAttrib(mask: GLbitfield): void;

/**
 * `glPopClientAttrib` restores the values of the client-state variables saved with the last {@link glPushClientAttrib}. Those not saved are left unchanged.
 *
 * It is an error to push attributes onto a full client attribute stack or to pop attributes off an empty stack. In either case, the error flag is set, and no other change is made to GL state.
 *
 * Initially, the client attribute stack is empty.
 *
 * @summary pop the client attribute stack
 * @see [glPushClientAttrib](https://docs.gl/gl3/glPushClientAttrib)
 */
export function glPopClientAttrib(): void;

/**
 * There is a stack of matrices for each of the matrix modes. In {@link GL_MODELVIEW} mode, the stack depth is at least 32. In the other modes, {@link GL_COLOR}, {@link GL_PROJECTION}, and {@link GL_TEXTURE}, the depth is at least 2. The current matrix in any mode is the matrix on the top of the stack for that mode.
 *
 * `glPushMatrix` pushes the current matrix stack down by one, duplicating the current matrix. That is, after a `glPushMatrix` call, the matrix on top of the stack is identical to the one below it.
 *
 * {@link glPopMatrix} pops the current matrix stack, replacing the current matrix with the one below it on the stack.
 *
 * Initially, each of the stacks contains one matrix, an identity matrix.
 *
 * It is an error to push a full matrix stack or to pop a matrix stack that contains only a single matrix. In either case, the error flag is set and no other change is made to GL state.
 *
 * @summary push the current matrix stack
 * @see [glPushMatrix](https://docs.gl/gl3/glPushMatrix)
 */
export function glPushMatrix(): void;

/**
 * There is a stack of matrices for each of the matrix modes. In {@link GL_MODELVIEW} mode, the stack depth is at least 32. In the other modes, {@link GL_COLOR}, {@link GL_PROJECTION}, and {@link GL_TEXTURE}, the depth is at least 2. The current matrix in any mode is the matrix on the top of the stack for that mode.
 *
 * `glPopMatrix` pops the current matrix stack, replacing the current matrix with the one below it on the stack.
 *
 * Initially, each of the stacks contains one matrix, an identity matrix.
 *
 * It is an error to push a full matrix stack or to pop a matrix stack that contains only a single matrix. In either case, the error flag is set and no other change is made to GL state.
 *
 * @summary pop the current matrix stack
 * @see [glPushMatrix](https://docs.gl/gl3/glPushMatrix)
 */
export function glPopMatrix(): void;

/**
 * The name stack is used during selection mode to allow sets of rendering commands to be uniquely identified. It consists of an ordered set of unsigned integers and is initially empty.
 *
 * `glPushName` causes **name** to be pushed onto the name stack. {@link glPopName} pops one name off the top of the stack.
 *
 * The maximum name stack depth is implementation-dependent; call {@link GL_MAX_NAME_STACK_DEPTH} to find out the value for a particular implementation. It is an error to push a name onto a full stack or to pop a name off an empty stack. It is also an error to manipulate the name stack between the execution of {@link glBegin} and the corresponding execution of {@link glEnd}. In any of these cases, the error flag is set and no other change is made to GL state.
 *
 * The name stack is always empty while the render mode is not {@link GL_SELECT}. Calls to `glPushName` or {@link glPopName} while the render mode is not {@link GL_SELECT} are ignored.
 *
 * @summary push the name stack
 * @param name Specifies a name that will be pushed onto the name stack.
 * @see [glPushName](https://docs.gl/gl3/glPushName)
 */
export function glPushName(name: GLuint): void;

/**
 * The name stack is used during selection mode to allow sets of rendering commands to be uniquely identified. It consists of an ordered set of unsigned integers and is initially empty.
 *
 * `glPopName` pops one name off the top of the stack.
 *
 * The maximum name stack depth is implementation-dependent; call {@link GL_MAX_NAME_STACK_DEPTH} to find out the value for a particular implementation. It is an error to push a name onto a full stack or to pop a name off an empty stack. It is also an error to manipulate the name stack between the execution of {@link glBegin} and the corresponding execution of {@link glEnd}. In any of these cases, the error flag is set and no other change is made to GL state.
 *
 * The name stack is always empty while the render mode is not {@link GL_SELECT}. Calls to {@link glPushName} or `glPopName` while the render mode is not {@link GL_SELECT} are ignored.
 *
 * @summary pop the name stack
 * @see [glPushName](https://docs.gl/gl3/glPushName)
 */
export function glPopName(): void;

/**
 * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See {@link glBitmap}, {@link glDrawPixels}, and {@link glCopyPixels}.
 *
 * The current raster position consists of three window coordinates (𝐱, 𝐲, 𝐳), a clip coordinate value (𝐰), an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The 𝐰 coordinate is a clip coordinate, because 𝐰 is not projected to window coordinates. `glRasterPos4` specifies object coordinates 𝐱, 𝐲, 𝐳, and 𝐰 explicitly. `glRasterPos3` specifies object coordinate 𝐱, 𝐲, and 𝐳 explicitly, while 𝐰 is implicitly set to 1. `glRasterPos2` uses the argument values for 𝐱 and 𝐲 while implicitly setting 𝐳 and 𝐰 to 0 and 1.
 *
 * The object coordinates presented by `glRasterPos` are treated just like those of a {@link glVertex} command: They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the {@link GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex **is** culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
 *
 * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then {@link GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@link GL_CURRENT_RASTER_INDEX} (in color index mode) is set to the color produced by the lighting calculation (see {@link glLight}, {@link glLightModel}, and {@link glShadeModel}). If lighting is disabled, current color (in RGBA mode, state variable {@link GL_CURRENT_COLOR}) or color index (in color index mode, state variable {@link GL_CURRENT_INDEX}) is used to update the current raster color. {@link GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
 *
 * Likewise, {@link GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of {@link GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see {@link glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as transformed by only the modelview matrix replaces {@link GL_CURRENT_RASTER_DISTANCE}.
 *
 * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, {@link GL_CURRENT_RASTER_INDEX} is always 1; in color index mode, the current raster RGBA color always maintains its initial value.
 *
 * @summary specify the raster position for pixel operations
 * @param x Specifies the x object coordinate (if present) for the raster position.
 * @param y Specifies the y object coordinate (if present) for the raster position.
 * @see [glRasterPos](https://docs.gl/gl3/glRasterPos)
 */
export function glRasterPos2d(x: GLdouble, y: GLdouble): void;

/**
 * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See {@link glBitmap}, {@link glDrawPixels}, and {@link glCopyPixels}.
 *
 * The current raster position consists of three window coordinates (𝐱, 𝐲, 𝐳), a clip coordinate value (𝐰), an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The 𝐰 coordinate is a clip coordinate, because 𝐰 is not projected to window coordinates. `glRasterPos4` specifies object coordinates 𝐱, 𝐲, 𝐳, and 𝐰 explicitly. `glRasterPos3` specifies object coordinate 𝐱, 𝐲, and 𝐳 explicitly, while 𝐰 is implicitly set to 1. `glRasterPos2` uses the argument values for 𝐱 and 𝐲 while implicitly setting 𝐳 and 𝐰 to 0 and 1.
 *
 * The object coordinates presented by `glRasterPos` are treated just like those of a {@link glVertex} command: They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the {@link GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex **is** culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
 *
 * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then {@link GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@link GL_CURRENT_RASTER_INDEX} (in color index mode) is set to the color produced by the lighting calculation (see {@link glLight}, {@link glLightModel}, and {@link glShadeModel}). If lighting is disabled, current color (in RGBA mode, state variable {@link GL_CURRENT_COLOR}) or color index (in color index mode, state variable {@link GL_CURRENT_INDEX}) is used to update the current raster color. {@link GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
 *
 * Likewise, {@link GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of {@link GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see {@link glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as transformed by only the modelview matrix replaces {@link GL_CURRENT_RASTER_DISTANCE}.
 *
 * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, {@link GL_CURRENT_RASTER_INDEX} is always 1; in color index mode, the current raster RGBA color always maintains its initial value.
 *
 * @summary specify the raster position for pixel operations
 * @param x Specifies the x object coordinate (if present) for the raster position.
 * @param y Specifies the y object coordinate (if present) for the raster position.
 * @see [glRasterPos](https://docs.gl/gl3/glRasterPos)
 */
export function glRasterPos2f(x: GLfloat, y: GLfloat): void;

/**
 * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See {@link glBitmap}, {@link glDrawPixels}, and {@link glCopyPixels}.
 *
 * The current raster position consists of three window coordinates (𝐱, 𝐲, 𝐳), a clip coordinate value (𝐰), an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The 𝐰 coordinate is a clip coordinate, because 𝐰 is not projected to window coordinates. `glRasterPos4` specifies object coordinates 𝐱, 𝐲, 𝐳, and 𝐰 explicitly. `glRasterPos3` specifies object coordinate 𝐱, 𝐲, and 𝐳 explicitly, while 𝐰 is implicitly set to 1. `glRasterPos2` uses the argument values for 𝐱 and 𝐲 while implicitly setting 𝐳 and 𝐰 to 0 and 1.
 *
 * The object coordinates presented by `glRasterPos` are treated just like those of a {@link glVertex} command: They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the {@link GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex **is** culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
 *
 * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then {@link GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@link GL_CURRENT_RASTER_INDEX} (in color index mode) is set to the color produced by the lighting calculation (see {@link glLight}, {@link glLightModel}, and {@link glShadeModel}). If lighting is disabled, current color (in RGBA mode, state variable {@link GL_CURRENT_COLOR}) or color index (in color index mode, state variable {@link GL_CURRENT_INDEX}) is used to update the current raster color. {@link GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
 *
 * Likewise, {@link GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of {@link GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see {@link glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as transformed by only the modelview matrix replaces {@link GL_CURRENT_RASTER_DISTANCE}.
 *
 * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, {@link GL_CURRENT_RASTER_INDEX} is always 1; in color index mode, the current raster RGBA color always maintains its initial value.
 *
 * @summary specify the raster position for pixel operations
 * @param x Specifies the x object coordinate (if present) for the raster position.
 * @param y Specifies the y object coordinate (if present) for the raster position.
 * @see [glRasterPos](https://docs.gl/gl3/glRasterPos)
 */
export function glRasterPos2i(x: GLint, y: GLint): void;

/**
 * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See {@link glBitmap}, {@link glDrawPixels}, and {@link glCopyPixels}.
 *
 * The current raster position consists of three window coordinates (𝐱, 𝐲, 𝐳), a clip coordinate value (𝐰), an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The 𝐰 coordinate is a clip coordinate, because 𝐰 is not projected to window coordinates. `glRasterPos4` specifies object coordinates 𝐱, 𝐲, 𝐳, and 𝐰 explicitly. `glRasterPos3` specifies object coordinate 𝐱, 𝐲, and 𝐳 explicitly, while 𝐰 is implicitly set to 1. `glRasterPos2` uses the argument values for 𝐱 and 𝐲 while implicitly setting 𝐳 and 𝐰 to 0 and 1.
 *
 * The object coordinates presented by `glRasterPos` are treated just like those of a {@link glVertex} command: They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the {@link GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex **is** culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
 *
 * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then {@link GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@link GL_CURRENT_RASTER_INDEX} (in color index mode) is set to the color produced by the lighting calculation (see {@link glLight}, {@link glLightModel}, and {@link glShadeModel}). If lighting is disabled, current color (in RGBA mode, state variable {@link GL_CURRENT_COLOR}) or color index (in color index mode, state variable {@link GL_CURRENT_INDEX}) is used to update the current raster color. {@link GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
 *
 * Likewise, {@link GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of {@link GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see {@link glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as transformed by only the modelview matrix replaces {@link GL_CURRENT_RASTER_DISTANCE}.
 *
 * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, {@link GL_CURRENT_RASTER_INDEX} is always 1; in color index mode, the current raster RGBA color always maintains its initial value.
 *
 * @summary specify the raster position for pixel operations
 * @param x Specifies the x object coordinate (if present) for the raster position.
 * @param y Specifies the y object coordinate (if present) for the raster position.
 * @see [glRasterPos](https://docs.gl/gl3/glRasterPos)
 */
export function glRasterPos2s(x: GLshort, y: GLshort): void;

/**
 * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See {@link glBitmap}, {@link glDrawPixels}, and {@link glCopyPixels}.
 *
 * The current raster position consists of three window coordinates (𝐱, 𝐲, 𝐳), a clip coordinate value (𝐰), an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The 𝐰 coordinate is a clip coordinate, because 𝐰 is not projected to window coordinates. `glRasterPos4` specifies object coordinates 𝐱, 𝐲, 𝐳, and 𝐰 explicitly. `glRasterPos3` specifies object coordinate 𝐱, 𝐲, and 𝐳 explicitly, while 𝐰 is implicitly set to 1. `glRasterPos2` uses the argument values for 𝐱 and 𝐲 while implicitly setting 𝐳 and 𝐰 to 0 and 1.
 *
 * The object coordinates presented by `glRasterPos` are treated just like those of a {@link glVertex} command: They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the {@link GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex **is** culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
 *
 * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then {@link GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@link GL_CURRENT_RASTER_INDEX} (in color index mode) is set to the color produced by the lighting calculation (see {@link glLight}, {@link glLightModel}, and {@link glShadeModel}). If lighting is disabled, current color (in RGBA mode, state variable {@link GL_CURRENT_COLOR}) or color index (in color index mode, state variable {@link GL_CURRENT_INDEX}) is used to update the current raster color. {@link GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
 *
 * Likewise, {@link GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of {@link GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see {@link glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as transformed by only the modelview matrix replaces {@link GL_CURRENT_RASTER_DISTANCE}.
 *
 * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, {@link GL_CURRENT_RASTER_INDEX} is always 1; in color index mode, the current raster RGBA color always maintains its initial value.
 *
 * @summary specify the raster position for pixel operations
 * @param x Specifies the x object coordinate (if present) for the raster position.
 * @param y Specifies the y object coordinate (if present) for the raster position.
 * @param z Specifies the z object coordinate (if present) for the raster position.
 * @see [glRasterPos](https://docs.gl/gl3/glRasterPos)
 */
export function glRasterPos3d(x: GLdouble, y: GLdouble, z: GLdouble): void;

/**
 * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See {@link glBitmap}, {@link glDrawPixels}, and {@link glCopyPixels}.
 *
 * The current raster position consists of three window coordinates (𝐱, 𝐲, 𝐳), a clip coordinate value (𝐰), an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The 𝐰 coordinate is a clip coordinate, because 𝐰 is not projected to window coordinates. `glRasterPos4` specifies object coordinates 𝐱, 𝐲, 𝐳, and 𝐰 explicitly. `glRasterPos3` specifies object coordinate 𝐱, 𝐲, and 𝐳 explicitly, while 𝐰 is implicitly set to 1. `glRasterPos2` uses the argument values for 𝐱 and 𝐲 while implicitly setting 𝐳 and 𝐰 to 0 and 1.
 *
 * The object coordinates presented by `glRasterPos` are treated just like those of a {@link glVertex} command: They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the {@link GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex **is** culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
 *
 * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then {@link GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@link GL_CURRENT_RASTER_INDEX} (in color index mode) is set to the color produced by the lighting calculation (see {@link glLight}, {@link glLightModel}, and {@link glShadeModel}). If lighting is disabled, current color (in RGBA mode, state variable {@link GL_CURRENT_COLOR}) or color index (in color index mode, state variable {@link GL_CURRENT_INDEX}) is used to update the current raster color. {@link GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
 *
 * Likewise, {@link GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of {@link GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see {@link glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as transformed by only the modelview matrix replaces {@link GL_CURRENT_RASTER_DISTANCE}.
 *
 * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, {@link GL_CURRENT_RASTER_INDEX} is always 1; in color index mode, the current raster RGBA color always maintains its initial value.
 *
 * @summary specify the raster position for pixel operations
 * @param x Specifies the x object coordinate (if present) for the raster position.
 * @param y Specifies the y object coordinate (if present) for the raster position.
 * @param z Specifies the z object coordinate (if present) for the raster position.
 * @see [glRasterPos](https://docs.gl/gl3/glRasterPos)
 */
export function glRasterPos3f(x: GLfloat, y: GLfloat, z: GLfloat): void;

/**
 * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See {@link glBitmap}, {@link glDrawPixels}, and {@link glCopyPixels}.
 *
 * The current raster position consists of three window coordinates (𝐱, 𝐲, 𝐳), a clip coordinate value (𝐰), an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The 𝐰 coordinate is a clip coordinate, because 𝐰 is not projected to window coordinates. `glRasterPos4` specifies object coordinates 𝐱, 𝐲, 𝐳, and 𝐰 explicitly. `glRasterPos3` specifies object coordinate 𝐱, 𝐲, and 𝐳 explicitly, while 𝐰 is implicitly set to 1. `glRasterPos2` uses the argument values for 𝐱 and 𝐲 while implicitly setting 𝐳 and 𝐰 to 0 and 1.
 *
 * The object coordinates presented by `glRasterPos` are treated just like those of a {@link glVertex} command: They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the {@link GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex **is** culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
 *
 * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then {@link GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@link GL_CURRENT_RASTER_INDEX} (in color index mode) is set to the color produced by the lighting calculation (see {@link glLight}, {@link glLightModel}, and {@link glShadeModel}). If lighting is disabled, current color (in RGBA mode, state variable {@link GL_CURRENT_COLOR}) or color index (in color index mode, state variable {@link GL_CURRENT_INDEX}) is used to update the current raster color. {@link GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
 *
 * Likewise, {@link GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of {@link GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see {@link glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as transformed by only the modelview matrix replaces {@link GL_CURRENT_RASTER_DISTANCE}.
 *
 * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, {@link GL_CURRENT_RASTER_INDEX} is always 1; in color index mode, the current raster RGBA color always maintains its initial value.
 *
 * @summary specify the raster position for pixel operations
 * @param x Specifies the x object coordinate (if present) for the raster position.
 * @param y Specifies the y object coordinate (if present) for the raster position.
 * @param z Specifies the z object coordinate (if present) for the raster position.
 * @see [glRasterPos](https://docs.gl/gl3/glRasterPos)
 */
export function glRasterPos3i(x: GLint, y: GLint, z: GLint): void;

/**
 * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See {@link glBitmap}, {@link glDrawPixels}, and {@link glCopyPixels}.
 *
 * The current raster position consists of three window coordinates (𝐱, 𝐲, 𝐳), a clip coordinate value (𝐰), an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The 𝐰 coordinate is a clip coordinate, because 𝐰 is not projected to window coordinates. `glRasterPos4` specifies object coordinates 𝐱, 𝐲, 𝐳, and 𝐰 explicitly. `glRasterPos3` specifies object coordinate 𝐱, 𝐲, and 𝐳 explicitly, while 𝐰 is implicitly set to 1. `glRasterPos2` uses the argument values for 𝐱 and 𝐲 while implicitly setting 𝐳 and 𝐰 to 0 and 1.
 *
 * The object coordinates presented by `glRasterPos` are treated just like those of a {@link glVertex} command: They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the {@link GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex **is** culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
 *
 * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then {@link GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@link GL_CURRENT_RASTER_INDEX} (in color index mode) is set to the color produced by the lighting calculation (see {@link glLight}, {@link glLightModel}, and {@link glShadeModel}). If lighting is disabled, current color (in RGBA mode, state variable {@link GL_CURRENT_COLOR}) or color index (in color index mode, state variable {@link GL_CURRENT_INDEX}) is used to update the current raster color. {@link GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
 *
 * Likewise, {@link GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of {@link GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see {@link glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as transformed by only the modelview matrix replaces {@link GL_CURRENT_RASTER_DISTANCE}.
 *
 * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, {@link GL_CURRENT_RASTER_INDEX} is always 1; in color index mode, the current raster RGBA color always maintains its initial value.
 *
 * @summary specify the raster position for pixel operations
 * @param x Specifies the x object coordinate (if present) for the raster position.
 * @param y Specifies the y object coordinate (if present) for the raster position.
 * @param z Specifies the z object coordinate (if present) for the raster position.
 * @see [glRasterPos](https://docs.gl/gl3/glRasterPos)
 */
export function glRasterPos3s(x: GLshort, y: GLshort, z: GLshort): void;

/**
 * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See {@link glBitmap}, {@link glDrawPixels}, and {@link glCopyPixels}.
 *
 * The current raster position consists of three window coordinates (𝐱, 𝐲, 𝐳), a clip coordinate value (𝐰), an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The 𝐰 coordinate is a clip coordinate, because 𝐰 is not projected to window coordinates. `glRasterPos4` specifies object coordinates 𝐱, 𝐲, 𝐳, and 𝐰 explicitly. `glRasterPos3` specifies object coordinate 𝐱, 𝐲, and 𝐳 explicitly, while 𝐰 is implicitly set to 1. `glRasterPos2` uses the argument values for 𝐱 and 𝐲 while implicitly setting 𝐳 and 𝐰 to 0 and 1.
 *
 * The object coordinates presented by `glRasterPos` are treated just like those of a {@link glVertex} command: They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the {@link GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex **is** culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
 *
 * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then {@link GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@link GL_CURRENT_RASTER_INDEX} (in color index mode) is set to the color produced by the lighting calculation (see {@link glLight}, {@link glLightModel}, and {@link glShadeModel}). If lighting is disabled, current color (in RGBA mode, state variable {@link GL_CURRENT_COLOR}) or color index (in color index mode, state variable {@link GL_CURRENT_INDEX}) is used to update the current raster color. {@link GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
 *
 * Likewise, {@link GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of {@link GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see {@link glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as transformed by only the modelview matrix replaces {@link GL_CURRENT_RASTER_DISTANCE}.
 *
 * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, {@link GL_CURRENT_RASTER_INDEX} is always 1; in color index mode, the current raster RGBA color always maintains its initial value.
 *
 * @summary specify the raster position for pixel operations
 * @param x Specifies the x object coordinate (if present) for the raster position.
 * @param y Specifies the y object coordinate (if present) for the raster position.
 * @param z Specifies the z object coordinate (if present) for the raster position.
 * @param w Specifies the w object coordinate (if present) for the raster position.
 * @see [glRasterPos](https://docs.gl/gl3/glRasterPos)
 */
export function glRasterPos4d(
	x: GLdouble,
	y: GLdouble,
	z: GLdouble,
	w: GLdouble
): void;

/**
 * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See {@link glBitmap}, {@link glDrawPixels}, and {@link glCopyPixels}.
 *
 * The current raster position consists of three window coordinates (𝐱, 𝐲, 𝐳), a clip coordinate value (𝐰), an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The 𝐰 coordinate is a clip coordinate, because 𝐰 is not projected to window coordinates. `glRasterPos4` specifies object coordinates 𝐱, 𝐲, 𝐳, and 𝐰 explicitly. `glRasterPos3` specifies object coordinate 𝐱, 𝐲, and 𝐳 explicitly, while 𝐰 is implicitly set to 1. `glRasterPos2` uses the argument values for 𝐱 and 𝐲 while implicitly setting 𝐳 and 𝐰 to 0 and 1.
 *
 * The object coordinates presented by `glRasterPos` are treated just like those of a {@link glVertex} command: They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the {@link GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex **is** culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
 *
 * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then {@link GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@link GL_CURRENT_RASTER_INDEX} (in color index mode) is set to the color produced by the lighting calculation (see {@link glLight}, {@link glLightModel}, and {@link glShadeModel}). If lighting is disabled, current color (in RGBA mode, state variable {@link GL_CURRENT_COLOR}) or color index (in color index mode, state variable {@link GL_CURRENT_INDEX}) is used to update the current raster color. {@link GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
 *
 * Likewise, {@link GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of {@link GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see {@link glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as transformed by only the modelview matrix replaces {@link GL_CURRENT_RASTER_DISTANCE}.
 *
 * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, {@link GL_CURRENT_RASTER_INDEX} is always 1; in color index mode, the current raster RGBA color always maintains its initial value.
 *
 * @summary specify the raster position for pixel operations
 * @param x Specifies the x object coordinate (if present) for the raster position.
 * @param y Specifies the y object coordinate (if present) for the raster position.
 * @param z Specifies the z object coordinate (if present) for the raster position.
 * @param w Specifies the w object coordinate (if present) for the raster position.
 * @see [glRasterPos](https://docs.gl/gl3/glRasterPos)
 */
export function glRasterPos4f(
	x: GLfloat,
	y: GLfloat,
	z: GLfloat,
	w: GLfloat
): void;

/**
 * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See {@link glBitmap}, {@link glDrawPixels}, and {@link glCopyPixels}.
 *
 * The current raster position consists of three window coordinates (𝐱, 𝐲, 𝐳), a clip coordinate value (𝐰), an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The 𝐰 coordinate is a clip coordinate, because 𝐰 is not projected to window coordinates. `glRasterPos4` specifies object coordinates 𝐱, 𝐲, 𝐳, and 𝐰 explicitly. `glRasterPos3` specifies object coordinate 𝐱, 𝐲, and 𝐳 explicitly, while 𝐰 is implicitly set to 1. `glRasterPos2` uses the argument values for 𝐱 and 𝐲 while implicitly setting 𝐳 and 𝐰 to 0 and 1.
 *
 * The object coordinates presented by `glRasterPos` are treated just like those of a {@link glVertex} command: They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the {@link GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex **is** culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
 *
 * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then {@link GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@link GL_CURRENT_RASTER_INDEX} (in color index mode) is set to the color produced by the lighting calculation (see {@link glLight}, {@link glLightModel}, and {@link glShadeModel}). If lighting is disabled, current color (in RGBA mode, state variable {@link GL_CURRENT_COLOR}) or color index (in color index mode, state variable {@link GL_CURRENT_INDEX}) is used to update the current raster color. {@link GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
 *
 * Likewise, {@link GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of {@link GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see {@link glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as transformed by only the modelview matrix replaces {@link GL_CURRENT_RASTER_DISTANCE}.
 *
 * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, {@link GL_CURRENT_RASTER_INDEX} is always 1; in color index mode, the current raster RGBA color always maintains its initial value.
 *
 * @summary specify the raster position for pixel operations
 * @param x Specifies the x object coordinate (if present) for the raster position.
 * @param y Specifies the y object coordinate (if present) for the raster position.
 * @param z Specifies the z object coordinate (if present) for the raster position.
 * @param w Specifies the w object coordinate (if present) for the raster position.
 * @see [glRasterPos](https://docs.gl/gl3/glRasterPos)
 */
export function glRasterPos4i(x: GLint, y: GLint, z: GLint, w: GLint): void;

/**
 * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See {@link glBitmap}, {@link glDrawPixels}, and {@link glCopyPixels}.
 *
 * The current raster position consists of three window coordinates (𝐱, 𝐲, 𝐳), a clip coordinate value (𝐰), an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The 𝐰 coordinate is a clip coordinate, because 𝐰 is not projected to window coordinates. `glRasterPos4` specifies object coordinates 𝐱, 𝐲, 𝐳, and 𝐰 explicitly. `glRasterPos3` specifies object coordinate 𝐱, 𝐲, and 𝐳 explicitly, while 𝐰 is implicitly set to 1. `glRasterPos2` uses the argument values for 𝐱 and 𝐲 while implicitly setting 𝐳 and 𝐰 to 0 and 1.
 *
 * The object coordinates presented by `glRasterPos` are treated just like those of a {@link glVertex} command: They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the {@link GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex **is** culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
 *
 * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then {@link GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@link GL_CURRENT_RASTER_INDEX} (in color index mode) is set to the color produced by the lighting calculation (see {@link glLight}, {@link glLightModel}, and {@link glShadeModel}). If lighting is disabled, current color (in RGBA mode, state variable {@link GL_CURRENT_COLOR}) or color index (in color index mode, state variable {@link GL_CURRENT_INDEX}) is used to update the current raster color. {@link GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
 *
 * Likewise, {@link GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of {@link GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see {@link glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as transformed by only the modelview matrix replaces {@link GL_CURRENT_RASTER_DISTANCE}.
 *
 * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, {@link GL_CURRENT_RASTER_INDEX} is always 1; in color index mode, the current raster RGBA color always maintains its initial value.
 *
 * @summary specify the raster position for pixel operations
 * @param x Specifies the x object coordinate (if present) for the raster position.
 * @param y Specifies the y object coordinate (if present) for the raster position.
 * @param z Specifies the z object coordinate (if present) for the raster position.
 * @param w Specifies the w object coordinate (if present) for the raster position.
 * @see [glRasterPos](https://docs.gl/gl3/glRasterPos)
 */
export function glRasterPos4s(
	x: GLshort,
	y: GLshort,
	z: GLshort,
	w: GLshort
): void;

/**
 * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See {@link glBitmap}, {@link glDrawPixels}, and {@link glCopyPixels}.
 *
 * The current raster position consists of three window coordinates (𝐱, 𝐲, 𝐳), a clip coordinate value (𝐰), an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The 𝐰 coordinate is a clip coordinate, because 𝐰 is not projected to window coordinates. `glRasterPos4` specifies object coordinates 𝐱, 𝐲, 𝐳, and 𝐰 explicitly. `glRasterPos3` specifies object coordinate 𝐱, 𝐲, and 𝐳 explicitly, while 𝐰 is implicitly set to 1. `glRasterPos2` uses the argument values for 𝐱 and 𝐲 while implicitly setting 𝐳 and 𝐰 to 0 and 1.
 *
 * The object coordinates presented by `glRasterPos` are treated just like those of a {@link glVertex} command: They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the {@link GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex **is** culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
 *
 * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then {@link GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@link GL_CURRENT_RASTER_INDEX} (in color index mode) is set to the color produced by the lighting calculation (see {@link glLight}, {@link glLightModel}, and {@link glShadeModel}). If lighting is disabled, current color (in RGBA mode, state variable {@link GL_CURRENT_COLOR}) or color index (in color index mode, state variable {@link GL_CURRENT_INDEX}) is used to update the current raster color. {@link GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
 *
 * Likewise, {@link GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of {@link GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see {@link glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as transformed by only the modelview matrix replaces {@link GL_CURRENT_RASTER_DISTANCE}.
 *
 * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, {@link GL_CURRENT_RASTER_INDEX} is always 1; in color index mode, the current raster RGBA color always maintains its initial value.
 *
 * @summary specify the raster position for pixel operations
 * @param v Specifies a pointer to an array of two, three, or four elements, specifying 𝐱, 𝐲, 𝐳, and 𝐰 coordinates, respectively.
 * @see [glRasterPos](https://docs.gl/gl3/glRasterPos)
 */
export function glRasterPos2dv(v: GLdouble): void;

/**
 * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See {@link glBitmap}, {@link glDrawPixels}, and {@link glCopyPixels}.
 *
 * The current raster position consists of three window coordinates (𝐱, 𝐲, 𝐳), a clip coordinate value (𝐰), an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The 𝐰 coordinate is a clip coordinate, because 𝐰 is not projected to window coordinates. `glRasterPos4` specifies object coordinates 𝐱, 𝐲, 𝐳, and 𝐰 explicitly. `glRasterPos3` specifies object coordinate 𝐱, 𝐲, and 𝐳 explicitly, while 𝐰 is implicitly set to 1. `glRasterPos2` uses the argument values for 𝐱 and 𝐲 while implicitly setting 𝐳 and 𝐰 to 0 and 1.
 *
 * The object coordinates presented by `glRasterPos` are treated just like those of a {@link glVertex} command: They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the {@link GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex **is** culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
 *
 * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then {@link GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@link GL_CURRENT_RASTER_INDEX} (in color index mode) is set to the color produced by the lighting calculation (see {@link glLight}, {@link glLightModel}, and {@link glShadeModel}). If lighting is disabled, current color (in RGBA mode, state variable {@link GL_CURRENT_COLOR}) or color index (in color index mode, state variable {@link GL_CURRENT_INDEX}) is used to update the current raster color. {@link GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
 *
 * Likewise, {@link GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of {@link GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see {@link glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as transformed by only the modelview matrix replaces {@link GL_CURRENT_RASTER_DISTANCE}.
 *
 * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, {@link GL_CURRENT_RASTER_INDEX} is always 1; in color index mode, the current raster RGBA color always maintains its initial value.
 *
 * @summary specify the raster position for pixel operations
 * @param v Specifies a pointer to an array of two, three, or four elements, specifying 𝐱, 𝐲, 𝐳, and 𝐰 coordinates, respectively.
 * @see [glRasterPos](https://docs.gl/gl3/glRasterPos)
 */
export function glRasterPos2fv(v: GLfloat): void;

/**
 * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See {@link glBitmap}, {@link glDrawPixels}, and {@link glCopyPixels}.
 *
 * The current raster position consists of three window coordinates (𝐱, 𝐲, 𝐳), a clip coordinate value (𝐰), an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The 𝐰 coordinate is a clip coordinate, because 𝐰 is not projected to window coordinates. `glRasterPos4` specifies object coordinates 𝐱, 𝐲, 𝐳, and 𝐰 explicitly. `glRasterPos3` specifies object coordinate 𝐱, 𝐲, and 𝐳 explicitly, while 𝐰 is implicitly set to 1. `glRasterPos2` uses the argument values for 𝐱 and 𝐲 while implicitly setting 𝐳 and 𝐰 to 0 and 1.
 *
 * The object coordinates presented by `glRasterPos` are treated just like those of a {@link glVertex} command: They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the {@link GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex **is** culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
 *
 * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then {@link GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@link GL_CURRENT_RASTER_INDEX} (in color index mode) is set to the color produced by the lighting calculation (see {@link glLight}, {@link glLightModel}, and {@link glShadeModel}). If lighting is disabled, current color (in RGBA mode, state variable {@link GL_CURRENT_COLOR}) or color index (in color index mode, state variable {@link GL_CURRENT_INDEX}) is used to update the current raster color. {@link GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
 *
 * Likewise, {@link GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of {@link GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see {@link glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as transformed by only the modelview matrix replaces {@link GL_CURRENT_RASTER_DISTANCE}.
 *
 * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, {@link GL_CURRENT_RASTER_INDEX} is always 1; in color index mode, the current raster RGBA color always maintains its initial value.
 *
 * @summary specify the raster position for pixel operations
 * @param v Specifies a pointer to an array of two, three, or four elements, specifying 𝐱, 𝐲, 𝐳, and 𝐰 coordinates, respectively.
 * @see [glRasterPos](https://docs.gl/gl3/glRasterPos)
 */
export function glRasterPos2iv(v: GLint): void;

/**
 * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See {@link glBitmap}, {@link glDrawPixels}, and {@link glCopyPixels}.
 *
 * The current raster position consists of three window coordinates (𝐱, 𝐲, 𝐳), a clip coordinate value (𝐰), an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The 𝐰 coordinate is a clip coordinate, because 𝐰 is not projected to window coordinates. `glRasterPos4` specifies object coordinates 𝐱, 𝐲, 𝐳, and 𝐰 explicitly. `glRasterPos3` specifies object coordinate 𝐱, 𝐲, and 𝐳 explicitly, while 𝐰 is implicitly set to 1. `glRasterPos2` uses the argument values for 𝐱 and 𝐲 while implicitly setting 𝐳 and 𝐰 to 0 and 1.
 *
 * The object coordinates presented by `glRasterPos` are treated just like those of a {@link glVertex} command: They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the {@link GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex **is** culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
 *
 * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then {@link GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@link GL_CURRENT_RASTER_INDEX} (in color index mode) is set to the color produced by the lighting calculation (see {@link glLight}, {@link glLightModel}, and {@link glShadeModel}). If lighting is disabled, current color (in RGBA mode, state variable {@link GL_CURRENT_COLOR}) or color index (in color index mode, state variable {@link GL_CURRENT_INDEX}) is used to update the current raster color. {@link GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
 *
 * Likewise, {@link GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of {@link GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see {@link glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as transformed by only the modelview matrix replaces {@link GL_CURRENT_RASTER_DISTANCE}.
 *
 * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, {@link GL_CURRENT_RASTER_INDEX} is always 1; in color index mode, the current raster RGBA color always maintains its initial value.
 *
 * @summary specify the raster position for pixel operations
 * @param v Specifies a pointer to an array of two, three, or four elements, specifying 𝐱, 𝐲, 𝐳, and 𝐰 coordinates, respectively.
 * @see [glRasterPos](https://docs.gl/gl3/glRasterPos)
 */
export function glRasterPos2sv(v: GLshort): void;

/**
 * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See {@link glBitmap}, {@link glDrawPixels}, and {@link glCopyPixels}.
 *
 * The current raster position consists of three window coordinates (𝐱, 𝐲, 𝐳), a clip coordinate value (𝐰), an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The 𝐰 coordinate is a clip coordinate, because 𝐰 is not projected to window coordinates. `glRasterPos4` specifies object coordinates 𝐱, 𝐲, 𝐳, and 𝐰 explicitly. `glRasterPos3` specifies object coordinate 𝐱, 𝐲, and 𝐳 explicitly, while 𝐰 is implicitly set to 1. `glRasterPos2` uses the argument values for 𝐱 and 𝐲 while implicitly setting 𝐳 and 𝐰 to 0 and 1.
 *
 * The object coordinates presented by `glRasterPos` are treated just like those of a {@link glVertex} command: They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the {@link GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex **is** culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
 *
 * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then {@link GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@link GL_CURRENT_RASTER_INDEX} (in color index mode) is set to the color produced by the lighting calculation (see {@link glLight}, {@link glLightModel}, and {@link glShadeModel}). If lighting is disabled, current color (in RGBA mode, state variable {@link GL_CURRENT_COLOR}) or color index (in color index mode, state variable {@link GL_CURRENT_INDEX}) is used to update the current raster color. {@link GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
 *
 * Likewise, {@link GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of {@link GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see {@link glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as transformed by only the modelview matrix replaces {@link GL_CURRENT_RASTER_DISTANCE}.
 *
 * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, {@link GL_CURRENT_RASTER_INDEX} is always 1; in color index mode, the current raster RGBA color always maintains its initial value.
 *
 * @summary specify the raster position for pixel operations
 * @param v Specifies a pointer to an array of two, three, or four elements, specifying 𝐱, 𝐲, 𝐳, and 𝐰 coordinates, respectively.
 * @see [glRasterPos](https://docs.gl/gl3/glRasterPos)
 */
export function glRasterPos3dv(v: GLdouble): void;

/**
 * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See {@link glBitmap}, {@link glDrawPixels}, and {@link glCopyPixels}.
 *
 * The current raster position consists of three window coordinates (𝐱, 𝐲, 𝐳), a clip coordinate value (𝐰), an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The 𝐰 coordinate is a clip coordinate, because 𝐰 is not projected to window coordinates. `glRasterPos4` specifies object coordinates 𝐱, 𝐲, 𝐳, and 𝐰 explicitly. `glRasterPos3` specifies object coordinate 𝐱, 𝐲, and 𝐳 explicitly, while 𝐰 is implicitly set to 1. `glRasterPos2` uses the argument values for 𝐱 and 𝐲 while implicitly setting 𝐳 and 𝐰 to 0 and 1.
 *
 * The object coordinates presented by `glRasterPos` are treated just like those of a {@link glVertex} command: They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the {@link GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex **is** culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
 *
 * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then {@link GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@link GL_CURRENT_RASTER_INDEX} (in color index mode) is set to the color produced by the lighting calculation (see {@link glLight}, {@link glLightModel}, and {@link glShadeModel}). If lighting is disabled, current color (in RGBA mode, state variable {@link GL_CURRENT_COLOR}) or color index (in color index mode, state variable {@link GL_CURRENT_INDEX}) is used to update the current raster color. {@link GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
 *
 * Likewise, {@link GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of {@link GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see {@link glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as transformed by only the modelview matrix replaces {@link GL_CURRENT_RASTER_DISTANCE}.
 *
 * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, {@link GL_CURRENT_RASTER_INDEX} is always 1; in color index mode, the current raster RGBA color always maintains its initial value.
 *
 * @summary specify the raster position for pixel operations
 * @param v Specifies a pointer to an array of two, three, or four elements, specifying 𝐱, 𝐲, 𝐳, and 𝐰 coordinates, respectively.
 * @see [glRasterPos](https://docs.gl/gl3/glRasterPos)
 */
export function glRasterPos3fv(v: GLfloat): void;

/**
 * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See {@link glBitmap}, {@link glDrawPixels}, and {@link glCopyPixels}.
 *
 * The current raster position consists of three window coordinates (𝐱, 𝐲, 𝐳), a clip coordinate value (𝐰), an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The 𝐰 coordinate is a clip coordinate, because 𝐰 is not projected to window coordinates. `glRasterPos4` specifies object coordinates 𝐱, 𝐲, 𝐳, and 𝐰 explicitly. `glRasterPos3` specifies object coordinate 𝐱, 𝐲, and 𝐳 explicitly, while 𝐰 is implicitly set to 1. `glRasterPos2` uses the argument values for 𝐱 and 𝐲 while implicitly setting 𝐳 and 𝐰 to 0 and 1.
 *
 * The object coordinates presented by `glRasterPos` are treated just like those of a {@link glVertex} command: They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the {@link GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex **is** culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
 *
 * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then {@link GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@link GL_CURRENT_RASTER_INDEX} (in color index mode) is set to the color produced by the lighting calculation (see {@link glLight}, {@link glLightModel}, and {@link glShadeModel}). If lighting is disabled, current color (in RGBA mode, state variable {@link GL_CURRENT_COLOR}) or color index (in color index mode, state variable {@link GL_CURRENT_INDEX}) is used to update the current raster color. {@link GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
 *
 * Likewise, {@link GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of {@link GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see {@link glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as transformed by only the modelview matrix replaces {@link GL_CURRENT_RASTER_DISTANCE}.
 *
 * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, {@link GL_CURRENT_RASTER_INDEX} is always 1; in color index mode, the current raster RGBA color always maintains its initial value.
 *
 * @summary specify the raster position for pixel operations
 * @param v Specifies a pointer to an array of two, three, or four elements, specifying 𝐱, 𝐲, 𝐳, and 𝐰 coordinates, respectively.
 * @see [glRasterPos](https://docs.gl/gl3/glRasterPos)
 */
export function glRasterPos3iv(v: GLint): void;

/**
 * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See {@link glBitmap}, {@link glDrawPixels}, and {@link glCopyPixels}.
 *
 * The current raster position consists of three window coordinates (𝐱, 𝐲, 𝐳), a clip coordinate value (𝐰), an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The 𝐰 coordinate is a clip coordinate, because 𝐰 is not projected to window coordinates. `glRasterPos4` specifies object coordinates 𝐱, 𝐲, 𝐳, and 𝐰 explicitly. `glRasterPos3` specifies object coordinate 𝐱, 𝐲, and 𝐳 explicitly, while 𝐰 is implicitly set to 1. `glRasterPos2` uses the argument values for 𝐱 and 𝐲 while implicitly setting 𝐳 and 𝐰 to 0 and 1.
 *
 * The object coordinates presented by `glRasterPos` are treated just like those of a {@link glVertex} command: They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the {@link GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex **is** culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
 *
 * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then {@link GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@link GL_CURRENT_RASTER_INDEX} (in color index mode) is set to the color produced by the lighting calculation (see {@link glLight}, {@link glLightModel}, and {@link glShadeModel}). If lighting is disabled, current color (in RGBA mode, state variable {@link GL_CURRENT_COLOR}) or color index (in color index mode, state variable {@link GL_CURRENT_INDEX}) is used to update the current raster color. {@link GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
 *
 * Likewise, {@link GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of {@link GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see {@link glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as transformed by only the modelview matrix replaces {@link GL_CURRENT_RASTER_DISTANCE}.
 *
 * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, {@link GL_CURRENT_RASTER_INDEX} is always 1; in color index mode, the current raster RGBA color always maintains its initial value.
 *
 * @summary specify the raster position for pixel operations
 * @param v Specifies a pointer to an array of two, three, or four elements, specifying 𝐱, 𝐲, 𝐳, and 𝐰 coordinates, respectively.
 * @see [glRasterPos](https://docs.gl/gl3/glRasterPos)
 */
export function glRasterPos3sv(v: GLshort): void;

/**
 * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See {@link glBitmap}, {@link glDrawPixels}, and {@link glCopyPixels}.
 *
 * The current raster position consists of three window coordinates (𝐱, 𝐲, 𝐳), a clip coordinate value (𝐰), an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The 𝐰 coordinate is a clip coordinate, because 𝐰 is not projected to window coordinates. `glRasterPos4` specifies object coordinates 𝐱, 𝐲, 𝐳, and 𝐰 explicitly. `glRasterPos3` specifies object coordinate 𝐱, 𝐲, and 𝐳 explicitly, while 𝐰 is implicitly set to 1. `glRasterPos2` uses the argument values for 𝐱 and 𝐲 while implicitly setting 𝐳 and 𝐰 to 0 and 1.
 *
 * The object coordinates presented by `glRasterPos` are treated just like those of a {@link glVertex} command: They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the {@link GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex **is** culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
 *
 * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then {@link GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@link GL_CURRENT_RASTER_INDEX} (in color index mode) is set to the color produced by the lighting calculation (see {@link glLight}, {@link glLightModel}, and {@link glShadeModel}). If lighting is disabled, current color (in RGBA mode, state variable {@link GL_CURRENT_COLOR}) or color index (in color index mode, state variable {@link GL_CURRENT_INDEX}) is used to update the current raster color. {@link GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
 *
 * Likewise, {@link GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of {@link GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see {@link glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as transformed by only the modelview matrix replaces {@link GL_CURRENT_RASTER_DISTANCE}.
 *
 * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, {@link GL_CURRENT_RASTER_INDEX} is always 1; in color index mode, the current raster RGBA color always maintains its initial value.
 *
 * @summary specify the raster position for pixel operations
 * @param v Specifies a pointer to an array of two, three, or four elements, specifying 𝐱, 𝐲, 𝐳, and 𝐰 coordinates, respectively.
 * @see [glRasterPos](https://docs.gl/gl3/glRasterPos)
 */
export function glRasterPos4dv(v: GLdouble): void;

/**
 * @see [glRasterPos4fv](https://docs.gl/gl3/glRasterPos4fv)
 */
export function glRasterPos4fv(v: GLfloat): void;

/**
 * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See {@link glBitmap}, {@link glDrawPixels}, and {@link glCopyPixels}.
 *
 * The current raster position consists of three window coordinates (𝐱, 𝐲, 𝐳), a clip coordinate value (𝐰), an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The 𝐰 coordinate is a clip coordinate, because 𝐰 is not projected to window coordinates. `glRasterPos4` specifies object coordinates 𝐱, 𝐲, 𝐳, and 𝐰 explicitly. `glRasterPos3` specifies object coordinate 𝐱, 𝐲, and 𝐳 explicitly, while 𝐰 is implicitly set to 1. `glRasterPos2` uses the argument values for 𝐱 and 𝐲 while implicitly setting 𝐳 and 𝐰 to 0 and 1.
 *
 * The object coordinates presented by `glRasterPos` are treated just like those of a {@link glVertex} command: They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the {@link GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex **is** culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
 *
 * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then {@link GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@link GL_CURRENT_RASTER_INDEX} (in color index mode) is set to the color produced by the lighting calculation (see {@link glLight}, {@link glLightModel}, and {@link glShadeModel}). If lighting is disabled, current color (in RGBA mode, state variable {@link GL_CURRENT_COLOR}) or color index (in color index mode, state variable {@link GL_CURRENT_INDEX}) is used to update the current raster color. {@link GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
 *
 * Likewise, {@link GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of {@link GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see {@link glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as transformed by only the modelview matrix replaces {@link GL_CURRENT_RASTER_DISTANCE}.
 *
 * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, {@link GL_CURRENT_RASTER_INDEX} is always 1; in color index mode, the current raster RGBA color always maintains its initial value.
 *
 * @summary specify the raster position for pixel operations
 * @param v Specifies a pointer to an array of two, three, or four elements, specifying 𝐱, 𝐲, 𝐳, and 𝐰 coordinates, respectively.
 * @see [glRasterPos](https://docs.gl/gl3/glRasterPos)
 */
export function glRasterPos4iv(v: GLint): void;

/**
 * The GL maintains a 3D position in window coordinates. This position, called the raster position, is used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See {@link glBitmap}, {@link glDrawPixels}, and {@link glCopyPixels}.
 *
 * The current raster position consists of three window coordinates (𝐱, 𝐲, 𝐳), a clip coordinate value (𝐰), an eye coordinate distance, a valid bit, and associated color data and texture coordinates. The 𝐰 coordinate is a clip coordinate, because 𝐰 is not projected to window coordinates. `glRasterPos4` specifies object coordinates 𝐱, 𝐲, 𝐳, and 𝐰 explicitly. `glRasterPos3` specifies object coordinate 𝐱, 𝐲, and 𝐳 explicitly, while 𝐰 is implicitly set to 1. `glRasterPos2` uses the argument values for 𝐱 and 𝐲 while implicitly setting 𝐳 and 𝐰 to 0 and 1.
 *
 * The object coordinates presented by `glRasterPos` are treated just like those of a {@link glVertex} command: They are transformed by the current modelview and projection matrices and passed to the clipping stage. If the vertex is not culled, then it is projected and scaled to window coordinates, which become the new current raster position, and the {@link GL_CURRENT_RASTER_POSITION_VALID} flag is set. If the vertex **is** culled, then the valid bit is cleared and the current raster position and associated color and texture coordinates are undefined.
 *
 * The current raster position also includes some associated color data and texture coordinates. If lighting is enabled, then {@link GL_CURRENT_RASTER_COLOR} (in RGBA mode) or {@link GL_CURRENT_RASTER_INDEX} (in color index mode) is set to the color produced by the lighting calculation (see {@link glLight}, {@link glLightModel}, and {@link glShadeModel}). If lighting is disabled, current color (in RGBA mode, state variable {@link GL_CURRENT_COLOR}) or color index (in color index mode, state variable {@link GL_CURRENT_INDEX}) is used to update the current raster color. {@link GL_CURRENT_RASTER_SECONDARY_COLOR} (in RGBA mode) is likewise updated.
 *
 * Likewise, {@link GL_CURRENT_RASTER_TEXTURE_COORDS} is updated as a function of {@link GL_CURRENT_TEXTURE_COORDS}, based on the texture matrix and the texture generation functions (see {@link glTexGen}). Finally, the distance from the origin of the eye coordinate system to the vertex as transformed by only the modelview matrix replaces {@link GL_CURRENT_RASTER_DISTANCE}.
 *
 * Initially, the current raster position is (0, 0, 0, 1), the current raster distance is 0, the valid bit is set, the associated RGBA color is (1, 1, 1, 1), the associated color index is 1, and the associated texture coordinates are (0, 0, 0, 1). In RGBA mode, {@link GL_CURRENT_RASTER_INDEX} is always 1; in color index mode, the current raster RGBA color always maintains its initial value.
 *
 * @summary specify the raster position for pixel operations
 * @param v Specifies a pointer to an array of two, three, or four elements, specifying 𝐱, 𝐲, 𝐳, and 𝐰 coordinates, respectively.
 * @see [glRasterPos](https://docs.gl/gl3/glRasterPos)
 */
export function glRasterPos4sv(v: GLshort): void;

/**
 * `glReadBuffer` specifies a color buffer as the source for subsequent {@link glReadPixels}, {@link glCopyTexImage1D}, {@link glCopyTexImage2D}, {@link glCopyTexSubImage1D}, {@link glCopyTexSubImage2D}, and {@link glCopyTexSubImage3D} commands. **mode** accepts one of twelve or more predefined values. In a fully configured system, {@link GL_FRONT}, {@link GL_LEFT}, and {@link GL_FRONT_LEFT} all name the front left buffer, {@link GL_FRONT_RIGHT} and {@link GL_RIGHT} name the front right buffer, and {@link GL_BACK_LEFT} and {@link GL_BACK} name the back left buffer. Furthermore, the constants {@link GL_COLOR_ATTACHMENT**i**} may be used to indicate the **i**th color attachment where **i** ranges from zero to the value of {@link GL_MAX_COLOR_ATTACHMENTS} minus one.
 *
 * Nonstereo double-buffered configurations have only a front left and a back left buffer. Single-buffered configurations have a front left and a front right buffer if stereo, and only a front left buffer if nonstereo. It is an error to specify a nonexistent buffer to `glReadBuffer`.
 *
 * **mode** is initially {@link GL_FRONT} in single-buffered configurations and {@link GL_BACK} in double-buffered configurations.
 *
 * @summary select a color buffer source for pixels
 * @param mode Specifies a color buffer. Accepted values are {@link GL_FRONT_LEFT}, {@link GL_FRONT_RIGHT}, {@link GL_BACK_LEFT}, {@link GL_BACK_RIGHT}, {@link GL_FRONT}, {@link GL_BACK}, {@link GL_LEFT}, and the constants {@link GL_COLOR_ATTACHMENT**i**}.
 * @see [glReadBuffer](https://docs.gl/gl3/glReadBuffer)
 */
export function glReadBuffer(mode: GLenum): void;

/**
 * `glReadPixels` returns pixel data from the frame buffer, starting with the pixel whose lower left corner is at location (**x**, **y**), into client memory starting at location **data**. Several parameters control the processing of the pixel data before it is placed into client memory. These parameters are set with {@link glPixelStore}. This reference page describes the effects on `glReadPixels` of most, but not all of the parameters specified by these three commands.
 *
 * If a non-zero named buffer object is bound to the {@link GL_PIXEL_PACK_BUFFER} target (see {@link glBindBuffer}) while a block of pixels is requested, **data** is treated as a byte offset into the buffer object's data store rather than a pointer to client memory.
 *
 * `glReadPixels` returns values from each pixel with lower left corner at (𝐱 + 𝐢, 𝐲 + 𝐣) for 0 <= 𝐢 < *width* and 0 <= 𝐣 < *height*. This pixel is said to be the 𝐢ᵗʰ pixel in the 𝐣ᵗʰ row. Pixels are returned in row order from the lowest to the highest row, left to right in each row.
 *
 * **format** specifies the format for the returned pixel values; accepted values are:
 *
 * - {@link GL_STENCIL_INDEX}
 * Stencil values are read from the stencil buffer. Each index is converted to fixed point.
 *
 * - {@link GL_DEPTH_COMPONENT}
 * Depth values are read from the depth buffer. Each component is converted to floating point such that the minimum depth value maps to 0 and the maximum value maps to 1. Each component is clamped to the range [0,1].
 *
 * - {@link GL_DEPTH_STENCIL}
 * Values are taken from both the depth and stencil buffers. The **type** parameter must be {@link GL_UNSIGNED_INT_24_8} or {@link GL_FLOAT_32_UNSIGNED_INT_24_8_REV}.
 *
 * - {@link GL_RED}
 * - {@link GL_GREEN}
 * - {@link GL_BLUE}
 * - {@link GL_RGB}
 * - {@link GL_BGR}
 * - {@link GL_RGBA}
 * - {@link GL_BGRA}
 *
 * Finally, the indices or components are converted to the proper format, as specified by **type**. If **format** is {@link GL_STENCIL_INDEX} and **type** is not {@link GL_FLOAT}, each index is masked with the mask value given in the following table. If **type** is {@link GL_FLOAT}, then each integer index is converted to single-precision floating-point format.
 *
 * If **format** is {@link GL_RED}, {@link GL_GREEN}, {@link GL_BLUE}, {@link GL_RGB}, {@link GL_BGR}, {@link GL_RGBA}, or {@link GL_BGRA} and **type** is not {@link GL_FLOAT}, each component is multiplied by the multiplier shown in the following table. If type is {@link GL_FLOAT}, then each component is passed as is (or converted to the client's single-precision floating-point format if it is different from the one used by the GL).
 *
 * | **type**                                  | **Index Mask** | **Component Conversion** |
 * | :---------------------------------------- | :------------- | :----------------------- |
 * | {@link GL_UNSIGNED_BYTE}                  | 2⁸ − 1         | (2⁸ − 1)𝐜                |
 * | {@link GL_BYTE}                           | 2⁷ − 1         | (2⁸ − 1)𝐜 − 12           |
 * | {@link GL_UNSIGNED_SHORT}                 | 2¹⁶ − 1        | (2¹⁶ − 1)𝐜               |
 * | {@link GL_SHORT}                          | 2¹⁵ − 1        | ((2¹⁶ − 1)𝐜 − 1) / 2     |
 * | {@link GL_UNSIGNED_INT}                   | 2³² − 1        | (2³² − 1)𝐜               |
 * | {@link GL_INT}                            | 2³¹ − 1        | ((2³² − 1)𝐜 − 1) / 2     |
 * | {@link GL_HALF_FLOAT}                     | none           | 𝐜                        |
 * | {@link GL_FLOAT}                          | none           | 𝐜                        |
 * | {@link GL_UNSIGNED_BYTE_3_3_2}            | 2ᴺ − 1         | (2ᴺ − 1)𝐜                |
 * | {@link GL_UNSIGNED_BYTE_2_3_3_REV}        | 2ᴺ − 1         | (2ᴺ − 1)𝐜                |
 * | {@link GL_UNSIGNED_SHORT_5_6_5}           | 2ᴺ − 1         | (2ᴺ − 1)𝐜                |
 * | {@link GL_UNSIGNED_SHORT_5_6_5_REV}       | 2ᴺ − 1         | (2ᴺ − 1)𝐜                |
 * | {@link GL_UNSIGNED_SHORT_4_4_4_4}         | 2ᴺ − 1         | (2ᴺ − 1)𝐜                |
 * | {@link GL_UNSIGNED_SHORT_4_4_4_4_REV}     | 2ᴺ − 1         | (2ᴺ − 1)𝐜                |
 * | {@link GL_UNSIGNED_SHORT_5_5_5_1}         | 2ᴺ − 1         | (2ᴺ − 1)𝐜                |
 * | {@link GL_UNSIGNED_SHORT_1_5_5_5_REV}     | 2ᴺ − 1         | (2ᴺ − 1)𝐜                |
 * | {@link GL_UNSIGNED_INT_8_8_8_8}           | 2ᴺ − 1         | (2ᴺ − 1)𝐜                |
 * | {@link GL_UNSIGNED_INT_8_8_8_8_REV}       | 2ᴺ − 1         | (2ᴺ − 1)𝐜                |
 * | {@link GL_UNSIGNED_INT_10_10_10_2}        | 2ᴺ − 1         | (2ᴺ − 1)𝐜                |
 * | {@link GL_UNSIGNED_INT_2_10_10_10_REV}    | 2ᴺ − 1         | (2ᴺ − 1)𝐜                |
 * | {@link GL_UNSIGNED_INT_24_8}              | 2ᴺ − 1         | (2ᴺ − 1)𝐜                |
 * | {@link GL_UNSIGNED_INT_10F_11F_11F_REV}   | --             | Special                  |
 * | {@link GL_UNSIGNED_INT_5_9_9_9_REV}       | --             | Special                  |
 * | {@link GL_FLOAT_32_UNSIGNED_INT_24_8_REV} | none           | 𝐜 (Depth only)           |
 *
 * Return values are placed in memory as follows. If **format** is {@link GL_STENCIL_INDEX}, {@link GL_DEPTH_COMPONENT}, {@link GL_RED}, {@link GL_GREEN}, or {@link GL_BLUE}, a single value is returned and the data for the 𝐢ᵗʰ pixel in the 𝐣ᵗʰ row is placed in location (𝐣)*width* + 𝐢. {@link GL_RGB} and {@link GL_BGR} return three values, {@link GL_RGBA} and {@link GL_BGRA} return four values for each pixel, with all values corresponding to a single pixel occupying contiguous space in **data**. Storage parameters set by {@link glPixelStore}, such as {@link GL_PACK_LSB_FIRST} and {@link GL_PACK_SWAP_BYTES}, affect the way that data is written into memory. See {@link glPixelStore} for a description.
 *
 * @summary read a block of pixels from the frame buffer
 * @param x Specifies the window x coordinate of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
 * @param y Specifies the window y coordinate of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
 * @param width Specifies the width of the pixel rectangle. **width** of one correspond to a single pixel.
 * @param height Specifies the height of the pixel rectangle. **height** of one corresponds to a single pixel.
 * @param format Specifies the format of the pixel data. The following symbolic values are accepted: {@link GL_STENCIL_INDEX}, {@link GL_DEPTH_COMPONENT}, {@link GL_DEPTH_STENCIL}, {@link GL_RED}, {@link GL_GREEN}, {@link GL_BLUE}, {@link GL_RGB}, {@link GL_BGR}, {@link GL_RGBA}, and {@link GL_BGRA}.
 * @param type Specifies the data type of the pixel data. Must be one of {@link GL_UNSIGNED_BYTE}, {@link GL_BYTE}, {@link GL_UNSIGNED_SHORT}, {@link GL_SHORT}, {@link GL_UNSIGNED_INT}, {@link GL_INT}, {@link GL_HALF_FLOAT}, {@link GL_FLOAT}, {@link GL_UNSIGNED_BYTE_3_3_2}, {@link GL_UNSIGNED_BYTE_2_3_3_REV}, {@link GL_UNSIGNED_SHORT_5_6_5}, {@link GL_UNSIGNED_SHORT_5_6_5_REV}, {@link GL_UNSIGNED_SHORT_4_4_4_4}, {@link GL_UNSIGNED_SHORT_4_4_4_4_REV}, {@link GL_UNSIGNED_SHORT_5_5_5_1}, {@link GL_UNSIGNED_SHORT_1_5_5_5_REV}, {@link GL_UNSIGNED_INT_8_8_8_8}, {@link GL_UNSIGNED_INT_8_8_8_8_REV}, {@link GL_UNSIGNED_INT_10_10_10_2}, {@link GL_UNSIGNED_INT_2_10_10_10_REV}, {@link GL_UNSIGNED_INT_24_8}, {@link GL_UNSIGNED_INT_10F_11F_11F_REV}, {@link GL_UNSIGNED_INT_5_9_9_9_REV}, or {@link GL_FLOAT_32_UNSIGNED_INT_24_8_REV}.
 * @param data Returns the pixel data.
 * @tutorial [Songho - OpenGL Rendering Pipeline](https://www.songho.ca/opengl/gl_pipeline.html)
 * @see [glReadPixels](https://docs.gl/gl3/glReadPixels)
 */
export function glReadPixels(
	x: GLint,
	y: GLint,
	width: GLsizei,
	height: GLsizei,
	format: GLenum,
	type: GLenum,
	data: GLvoid
): void;

/**
 * `glRect` supports efficient specification of rectangles as two corner points. Each rectangle command takes four arguments, organized either as two consecutive pairs of (𝐱, 𝐲) coordinates or as two pointers to arrays, each containing an (𝐱, 𝐲) pair. The resulting rectangle is defined in the 𝐳 = 0 plane.
 *
 * `glRect`(**x1**, **y1**, **x2**, **y2**) is exactly equivalent to the following sequence:
 *
 * ```
 * glBegin(GL_POLYGON);
 * glVertex2(x1, y1);
 * glVertex2(x2, y1);
 * glVertex2(x2, y2);
 * glVertex2(x1, y2);
 * glEnd();
 * ```
 *
 * Note that if the second vertex is above and to the right of the first vertex, the rectangle is constructed with a counterclockwise winding.
 *
 * @summary draw a rectangle
 * @param x1 Specifies the 𝐱 coordinate of one vertex of a rectangle.
 * @param y1 Specifies the 𝐲 coordinate of one vertex of a rectangle.
 * @param x2 Specifies the 𝐱 coordinate of the opposite vertex of the rectangle
 * @param y2 Specifies the 𝐲 coordinate of the opposite vertex of the rectangle
 * @see [glRect](https://docs.gl/gl3/glRect)
 */
export function glRectd(
	x1: GLdouble,
	y1: GLdouble,
	x2: GLdouble,
	y2: GLdouble
): void;

/**
 * `glRect` supports efficient specification of rectangles as two corner points. Each rectangle command takes four arguments, organized either as two consecutive pairs of (𝐱, 𝐲) coordinates or as two pointers to arrays, each containing an (𝐱, 𝐲) pair. The resulting rectangle is defined in the 𝐳 = 0 plane.
 *
 * `glRect`(**x1**, **y1**, **x2**, **y2**) is exactly equivalent to the following sequence:
 *
 * ```
 * glBegin(GL_POLYGON);
 * glVertex2(x1, y1);
 * glVertex2(x2, y1);
 * glVertex2(x2, y2);
 * glVertex2(x1, y2);
 * glEnd();
 * ```
 *
 * Note that if the second vertex is above and to the right of the first vertex, the rectangle is constructed with a counterclockwise winding.
 *
 * @summary draw a rectangle
 * @param x1 Specifies the 𝐱 coordinate of one vertex of a rectangle.
 * @param y1 Specifies the 𝐲 coordinate of one vertex of a rectangle.
 * @param x2 Specifies the 𝐱 coordinate of the opposite vertex of the rectangle
 * @param y2 Specifies the 𝐲 coordinate of the opposite vertex of the rectangle
 * @see [glRect](https://docs.gl/gl3/glRect)
 */
export function glRectf(
	x1: GLfloat,
	y1: GLfloat,
	x2: GLfloat,
	y2: GLfloat
): void;

/**
 * `glRect` supports efficient specification of rectangles as two corner points. Each rectangle command takes four arguments, organized either as two consecutive pairs of (𝐱, 𝐲) coordinates or as two pointers to arrays, each containing an (𝐱, 𝐲) pair. The resulting rectangle is defined in the 𝐳 = 0 plane.
 *
 * `glRect`(**x1**, **y1**, **x2**, **y2**) is exactly equivalent to the following sequence:
 *
 * ```
 * glBegin(GL_POLYGON);
 * glVertex2(x1, y1);
 * glVertex2(x2, y1);
 * glVertex2(x2, y2);
 * glVertex2(x1, y2);
 * glEnd();
 * ```
 *
 * Note that if the second vertex is above and to the right of the first vertex, the rectangle is constructed with a counterclockwise winding.
 *
 * @summary draw a rectangle
 * @param x1 Specifies the 𝐱 coordinate of one vertex of a rectangle.
 * @param y1 Specifies the 𝐲 coordinate of one vertex of a rectangle.
 * @param x2 Specifies the 𝐱 coordinate of the opposite vertex of the rectangle
 * @param y2 Specifies the 𝐲 coordinate of the opposite vertex of the rectangle
 * @see [glRect](https://docs.gl/gl3/glRect)
 */
export function glRecti(x1: GLint, y1: GLint, x2: GLint, y2: GLint): void;

/**
 * `glRect` supports efficient specification of rectangles as two corner points. Each rectangle command takes four arguments, organized either as two consecutive pairs of (𝐱, 𝐲) coordinates or as two pointers to arrays, each containing an (𝐱, 𝐲) pair. The resulting rectangle is defined in the 𝐳 = 0 plane.
 *
 * `glRect`(**x1**, **y1**, **x2**, **y2**) is exactly equivalent to the following sequence:
 *
 * ```
 * glBegin(GL_POLYGON);
 * glVertex2(x1, y1);
 * glVertex2(x2, y1);
 * glVertex2(x2, y2);
 * glVertex2(x1, y2);
 * glEnd();
 * ```
 *
 * Note that if the second vertex is above and to the right of the first vertex, the rectangle is constructed with a counterclockwise winding.
 *
 * @summary draw a rectangle
 * @param x1 Specifies the 𝐱 coordinate of one vertex of a rectangle.
 * @param y1 Specifies the 𝐲 coordinate of one vertex of a rectangle.
 * @param x2 Specifies the 𝐱 coordinate of the opposite vertex of the rectangle
 * @param y2 Specifies the 𝐲 coordinate of the opposite vertex of the rectangle
 * @see [glRect](https://docs.gl/gl3/glRect)
 */
export function glRects(
	x1: GLshort,
	y1: GLshort,
	x2: GLshort,
	y2: GLshort
): void;

/**
 * `glRect` supports efficient specification of rectangles as two corner points. Each rectangle command takes four arguments, organized either as two consecutive pairs of (𝐱, 𝐲) coordinates or as two pointers to arrays, each containing an (𝐱, 𝐲) pair. The resulting rectangle is defined in the 𝐳 = 0 plane.
 *
 * `glRect`(**x1**, **y1**, **x2**, **y2**) is exactly equivalent to the following sequence:
 *
 * ```
 * glBegin(GL_POLYGON);
 * glVertex2(x1, y1);
 * glVertex2(x2, y1);
 * glVertex2(x2, y2);
 * glVertex2(x1, y2);
 * glEnd();
 * ```
 *
 * Note that if the second vertex is above and to the right of the first vertex, the rectangle is constructed with a counterclockwise winding.
 *
 * @summary draw a rectangle
 * @param v1 Specifies a pointer to one vertex of a rectangle.
 * @param v2 Specifies a pointer to the opposite vertex of a rectangle.
 * @see [glRect](https://docs.gl/gl3/glRect)
 */
export function glRectdv(v1: GLdouble, v2: GLdouble): void;

/**
 * `glRect` supports efficient specification of rectangles as two corner points. Each rectangle command takes four arguments, organized either as two consecutive pairs of (𝐱, 𝐲) coordinates or as two pointers to arrays, each containing an (𝐱, 𝐲) pair. The resulting rectangle is defined in the 𝐳 = 0 plane.
 *
 * `glRect`(**x1**, **y1**, **x2**, **y2**) is exactly equivalent to the following sequence:
 *
 * ```
 * glBegin(GL_POLYGON);
 * glVertex2(x1, y1);
 * glVertex2(x2, y1);
 * glVertex2(x2, y2);
 * glVertex2(x1, y2);
 * glEnd();
 * ```
 *
 * Note that if the second vertex is above and to the right of the first vertex, the rectangle is constructed with a counterclockwise winding.
 *
 * @summary draw a rectangle
 * @param v1 Specifies a pointer to one vertex of a rectangle.
 * @param v2 Specifies a pointer to the opposite vertex of a rectangle.
 * @see [glRect](https://docs.gl/gl3/glRect)
 */
export function glRectfv(v1: GLfloat, v2: GLfloat): void;

/**
 * `glRect` supports efficient specification of rectangles as two corner points. Each rectangle command takes four arguments, organized either as two consecutive pairs of (𝐱, 𝐲) coordinates or as two pointers to arrays, each containing an (𝐱, 𝐲) pair. The resulting rectangle is defined in the 𝐳 = 0 plane.
 *
 * `glRect`(**x1**, **y1**, **x2**, **y2**) is exactly equivalent to the following sequence:
 *
 * ```
 * glBegin(GL_POLYGON);
 * glVertex2(x1, y1);
 * glVertex2(x2, y1);
 * glVertex2(x2, y2);
 * glVertex2(x1, y2);
 * glEnd();
 * ```
 *
 * Note that if the second vertex is above and to the right of the first vertex, the rectangle is constructed with a counterclockwise winding.
 *
 * @summary draw a rectangle
 * @param v1 Specifies a pointer to one vertex of a rectangle.
 * @param v2 Specifies a pointer to the opposite vertex of a rectangle.
 * @see [glRect](https://docs.gl/gl3/glRect)
 */
export function glRectiv(v1: GLint, v2: GLint): void;

/**
 * `glRect` supports efficient specification of rectangles as two corner points. Each rectangle command takes four arguments, organized either as two consecutive pairs of (𝐱, 𝐲) coordinates or as two pointers to arrays, each containing an (𝐱, 𝐲) pair. The resulting rectangle is defined in the 𝐳 = 0 plane.
 *
 * `glRect`(**x1**, **y1**, **x2**, **y2**) is exactly equivalent to the following sequence:
 *
 * ```
 * glBegin(GL_POLYGON);
 * glVertex2(x1, y1);
 * glVertex2(x2, y1);
 * glVertex2(x2, y2);
 * glVertex2(x1, y2);
 * glEnd();
 * ```
 *
 * Note that if the second vertex is above and to the right of the first vertex, the rectangle is constructed with a counterclockwise winding.
 *
 * @summary draw a rectangle
 * @param v1 Specifies a pointer to one vertex of a rectangle.
 * @param v2 Specifies a pointer to the opposite vertex of a rectangle.
 * @see [glRect](https://docs.gl/gl3/glRect)
 */
export function glRectsv(v1: GLshort, v2: GLshort): void;

/**
 * `glRenderMode` sets the rasterization mode. It takes one argument, **mode**, which can assume one of three predefined values:
 *
 * - {@link GL_RENDER}
 * Render mode. Primitives are rasterized, producing pixel fragments, which are written into the frame buffer. This is the normal mode and also the default mode.
 *
 * - {@link GL_SELECT}
 * Selection mode. No pixel fragments are produced, and no change to the frame buffer contents is made. Instead, a record of the names of primitives that would have been drawn if the render mode had been {@link GL_RENDER} is returned in a select buffer, which must be created (see {@link glSelectBuffer}) before selection mode is entered.
 *
 * - {@link GL_FEEDBACK}
 * Feedback mode. No pixel fragments are produced, and no change to the frame buffer contents is made. Instead, the coordinates and attributes of vertices that would have been drawn if the render mode had been {@link GL_RENDER} is returned in a feedback buffer, which must be created (see {@link glFeedbackBuffer}) before feedback mode is entered.
 *
 * The return value of `glRenderMode` is determined by the render mode at the time `glRenderMode` is called, rather than by **mode**. The values returned for the three render modes are as follows:
 *
 * - {@link GL_RENDER} 0.
 *
 * - {@link GL_SELECT}
 * The number of hit records transferred to the select buffer.
 *
 * - {@link GL_FEEDBACK}
 * The number of values (not vertices) transferred to the feedback buffer.
 *
 * See the {@link glSelectBuffer} and {@link glFeedbackBuffer} reference pages for more details concerning selection and feedback operation.
 *
 * @summary set rasterization mode
 * @param mode Specifies the rasterization mode. Three values are accepted: {@link GL_RENDER}, {@link GL_SELECT}, and {@link GL_FEEDBACK}. The initial value is {@link GL_RENDER}.
 * @see [glRenderMode](https://docs.gl/gl3/glRenderMode)
 */
export function glRenderMode(mode: GLenum): GLint;

/**
 * `glRotate` produces a rotation of **angle** degrees around the vector (𝐱, 𝐲, 𝐳). The current matrix (see {@link glMatrixMode}) is multiplied by a rotation matrix with the product replacing the current matrix, as if {@link glMultMatrix} were called with the following matrix as its argument:
 *
 *
 * ⎛𝐱²(1 − 𝐜) + 𝐜ㅤㅤ𝐱𝐲(1 − 𝐜) − 𝐳𝐬ㅤㅤ𝐱𝐳(1 − 𝐜) + 𝐲𝐬ㅤㅤ0⎞
 *
 * ⎜𝐲𝐱(1 − 𝐜) + 𝐳𝐬ㅤㅤ𝐲²(1 − 𝐜) + 𝐜ㅤㅤ𝐲𝐳(1 − 𝐜) + 𝐱𝐬ㅤㅤ0 ⎜
 *
 * ⎜𝐱𝐳(1 − 𝐜) - 𝐲𝐬ㅤㅤ𝐲𝐳(1 − 𝐜) + 𝐱𝐬ㅤㅤ𝐳²(1 − 𝐜) + 𝐜ㅤ ㅤ0⎟
 *
 * ⎝ㅤㅤㅤ0ㅤㅤㅤㅤㅤㅤㅤ0ㅤㅤㅤㅤㅤㅤㅤ0ㅤㅤㅤ ㅤ 1⎠
 *
 * Where 𝐜 = cos(angle), 𝐬 = sin(angle), and ∥(𝐱, 𝐲 ,𝐳)∥ = 1 (if not, the GL will normalize this vector).
 *
 * If the matrix mode is either {@link GL_MODELVIEW} or {@link GL_PROJECTION}, all objects drawn after `glRotate` is called are rotated. Use {@link glPushMatrix} and {@link glPopMatrix} to save and restore the unrotated coordinate system.
 *
 * @summary multiply the current matrix by a rotation matrix
 * @param angle Specifies the angle of rotation, in degrees.
 * @param x Specifies the x coordinate of a vector.
 * @param y Specifies the y coordinate of a vector.
 * @param z Specifies the z coordinate of a vector.
 * @see [glRotate](https://docs.gl/gl3/glRotate)
 */
export function glRotated(
	angle: GLdouble,
	x: GLdouble,
	y: GLdouble,
	z: GLdouble
): void;

/**
 * `glRotate` produces a rotation of **angle** degrees around the vector (𝐱, 𝐲, 𝐳). The current matrix (see {@link glMatrixMode}) is multiplied by a rotation matrix with the product replacing the current matrix, as if {@link glMultMatrix} were called with the following matrix as its argument:
 *
 * ⎛𝐱²(1 − 𝐜) + 𝐜ㅤㅤ𝐱𝐲(1 − 𝐜) − 𝐳𝐬ㅤㅤ𝐱𝐳(1 − 𝐜) + 𝐲𝐬ㅤㅤ0⎞
 *
 * ⎜𝐲𝐱(1 − 𝐜) + 𝐳𝐬ㅤㅤ𝐲²(1 − 𝐜) + 𝐜ㅤㅤ𝐲𝐳(1 − 𝐜) + 𝐱𝐬ㅤㅤ0 ⎜
 *
 * ⎜𝐱𝐳(1 − 𝐜) - 𝐲𝐬ㅤㅤ𝐲𝐳(1 − 𝐜) + 𝐱𝐬ㅤㅤ𝐳²(1 − 𝐜) + 𝐜ㅤ ㅤ0⎟
 *
 * ⎝ㅤㅤㅤ0ㅤㅤㅤㅤㅤㅤㅤ0ㅤㅤㅤㅤㅤㅤㅤ0ㅤㅤㅤ ㅤ 1⎠
 *
 * Where 𝐜 = cos(angle), 𝐬 = sin(angle), and ∥(𝐱, 𝐲 ,𝐳)∥ = 1 (if not, the GL will normalize this vector).
 *
 * If the matrix mode is either {@link GL_MODELVIEW} or {@link GL_PROJECTION}, all objects drawn after `glRotate` is called are rotated. Use {@link glPushMatrix} and {@link glPopMatrix} to save and restore the unrotated coordinate system.
 *
 * @summary multiply the current matrix by a rotation matrix
 * @param angle Specifies the angle of rotation, in degrees.
 * @param x Specifies the x coordinate of a vector.
 * @param y Specifies the y coordinate of a vector.
 * @param z Specifies the z coordinate of a vector.
 * @see [glRotate](https://docs.gl/gl3/glRotate)
 */
export function glRotatef(
	angle: GLfloat,
	x: GLfloat,
	y: GLfloat,
	z: GLfloat
): void;

/**
 * `glScale` produces a nonuniform scaling along the **x**, **y**, and **z** axes. The three parameters indicate the desired scale factor along each of the three axes.
 *
 * The current matrix (see {@link glMatrixMode}) is multiplied by this scale matrix, and the product replaces the current matrix as if {@link glMultMatrix} were called with the following matrix as its argument:
 *
 * ⎛𝐱ㅤㅤ0ㅤㅤ0ㅤㅤ0⎞
 *
 * ⎜0ㅤㅤ𝐲ㅤㅤ0ㅤㅤ0 ⎜
 *
 * ⎜0ㅤㅤ0ㅤㅤ𝐳ㅤㅤ0⎟
 *
 * ⎝0ㅤㅤ0ㅤㅤ0ㅤㅤ1⎠
 *
 * If the matrix mode is either {@link GL_MODELVIEW} or {@link GL_PROJECTION}, all objects drawn after `glScale` is called are scaled.
 *
 * Use {@link glPushMatrix} and {@link glPopMatrix} to save and restore the unscaled coordinate system.
 *
 * @summary multiply the current matrix by a general scaling matrix
 * @param x Specifies scale factor along the x axis.
 * @param y Specifies scale factor along the y axis.
 * @param z Specifies scale factor along the z axis.
 * @see [glScale](https://docs.gl/gl3/glScale)
 */
export function glScaled(x: GLdouble, y: GLdouble, z: GLdouble): void;

/**
 * `glScale` produces a nonuniform scaling along the **x**, **y**, and **z** axes. The three parameters indicate the desired scale factor along each of the three axes.
 *
 * The current matrix (see {@link glMatrixMode}) is multiplied by this scale matrix, and the product replaces the current matrix as if {@link glMultMatrix} were called with the following matrix as its argument:
 *
 * ⎛𝐱ㅤㅤ0ㅤㅤ0ㅤㅤ0⎞
 *
 * ⎜0ㅤㅤ𝐲ㅤㅤ0ㅤㅤ0 ⎜
 *
 * ⎜0ㅤㅤ0ㅤㅤ𝐳ㅤㅤ0⎟
 *
 * ⎝0ㅤㅤ0ㅤㅤ0ㅤㅤ1⎠
 *
 * If the matrix mode is either {@link GL_MODELVIEW} or {@link GL_PROJECTION}, all objects drawn after `glScale` is called are scaled.
 *
 * Use {@link glPushMatrix} and {@link glPopMatrix} to save and restore the unscaled coordinate system.
 *
 * @summary multiply the current matrix by a general scaling matrix
 * @param x Specifies scale factor along the x axis.
 * @param y Specifies scale factor along the y axis.
 * @param z Specifies scale factor along the z axis.
 * @see [glScale](https://docs.gl/gl3/glScale)
 */
export function glScalef(x: GLfloat, y: GLfloat, z: GLfloat): void;

/**
 * `glScissor` defines a rectangle, called the scissor box, in window coordinates. The first two arguments, **x** and **y**, specify the lower left corner of the box. **width** and **height** specify the width and height of the box.
 *
 * To enable and disable the scissor test, call {@link glEnable} and {@link glDisable} with argument {@link GL_SCISSOR_TEST}. The test is initially disabled. While the test is enabled, only pixels that lie within the scissor box can be modified by drawing commands. Window coordinates have integer values at the shared corners of frame buffer pixels. glScissor(0,0,1,1) allows modification of only the lower left pixel in the window, and glScissor(0,0,0,0) doesn't allow modification of any pixels in the window.
 *
 * When the scissor test is disabled, it is as though the scissor box includes the entire window.
 *
 * @summary define the scissor box
 * @param x Specifies the lower left corner x of the scissor box. Initially 0.
 * @param y Specifies the lower left corner y of the scissor box. Initially 0.
 * @param width Specifies the width of the scissor box. When a GL context is first attached to a window, **width** is set to the dimensions of that window.
 * @param height Specifies the height of the scissor box. When a GL context is first attached to a window, **height** is set to the dimensions of that window.
 * @see [glScissor](https://docs.gl/gl3/glScissor)
 */
export function glScissor(
	x: GLint,
	y: GLint,
	width: GLsizei,
	height: GLsizei
): void;

/**
 * `glSelectBuffer` has two arguments: **buffer** is a pointer to an array of unsigned integers, and **size** indicates the size of the array. **buffer** returns values from the name stack (see {@link glInitNames}, {@link glLoadName}, {@link glPushName}) when the rendering mode is {@link GL_SELECT} (see {@link glRenderMode}). `glSelectBuffer` must be issued before selection mode is enabled, and it must not be issued while the rendering mode is {@link GL_SELECT}.
 *
 * A programmer can use selection to determine which primitives are drawn into some region of a window. The region is defined by the current modelview and perspective matrices.
 *
 * In selection mode, no pixel fragments are produced from rasterization. Instead, if a primitive or a raster position intersects the clipping volume defined by the viewing frustum and the user-defined clipping planes, this primitive causes a selection hit. (With polygons, no hit occurs if the polygon is culled.) When a change is made to the name stack, or when {@link glRenderMode} is called, a hit record is copied to **buffer** if any hits have occurred since the last such event (name stack change or {@link glRenderMode} call). The hit record consists of the number of names in the name stack at the time of the event, followed by the minimum and maximum depth values of all vertices that hit since the previous event, followed by the name stack contents, bottom name first.
 *
 * Depth values (which are in the range [0,1]) are multiplied by 2³² − 1, before being placed in the hit record.
 *
 * An internal index into **buffer** is reset to 0 whenever selection mode is entered. Each time a hit record is copied into **buffer**, the index is incremented to point to the cell just past the end of the block of names\(emthat is, to the next available cell If the hit record is larger than the number of remaining locations in **buffer**, as much data as can fit is copied, and the overflow flag is set. If the name stack is empty when a hit record is copied, that record consists of 0 followed by the minimum and maximum depth values.
 *
 * To exit selection mode, call {@link glRenderMode} with an argument other than {@link GL_SELECT}. Whenever {@link glRenderMode} is called while the render mode is {@link GL_SELECT}, it returns the number of hit records copied to **buffer**, resets the overflow flag and the selection buffer pointer, and initializes the name stack to be empty. If the overflow bit was set when {@link glRenderMode} was called, a negative hit record count is returned.
 *
 * @summary establish a buffer for selection mode values
 * @param size Specifies the size of **buffer**.
 * @param buffer Returns the selection data.
 * @see [glSelectBuffer](https://docs.gl/gl3/glSelectBuffer)
 */
export function glSelectBuffer(size: GLsizei, buffer: GLuint): void;

/**
 * GL primitives can have either flat or smooth shading. Smooth shading, the default, causes the computed colors of vertices to be interpolated as the primitive is rasterized, typically assigning different colors to each resulting pixel fragment. Flat shading selects the computed color of just one vertex and assigns it to all the pixel fragments generated by rasterizing a single primitive. In either case, the computed color of a vertex is the result of lighting if lighting is enabled, or it is the current color at the time the vertex was specified if lighting is disabled.
 *
 * Flat and smooth shading are indistinguishable for points. Starting when {@link glBegin} is issued and counting vertices and primitives from 1, the GL gives each flat-shaded line segment 𝐢 the computed color of vertex 𝐢 + 1, its second vertex. Counting similarly from 1, the GL gives each flat-shaded polygon the computed color of the vertex listed in the following table. This is the last vertex to specify the polygon in all cases except single polygons, where the first vertex specifies the flat-shaded color.
 *
 * Primitive Type of Polygon i
 * 	Vertex
 * Single polygon (i==1
 * ) 	1
 * Triangle strip 	i+2
 * Triangle fan 	i+2
 * Independent triangle 	3i
 * Quad strip 	2i+2
 * Independent quad 	4i
 *
 * | **Primitive Type of Polygon 𝐢** | **Vertex** |
 * | :------------------------------ | :--------- |
 * | Single polygon (𝐢 == 1)         | 1          |
 * | Triangle strip                  | 𝐢 + 2      |
 * | Triangle fan                    | 𝐢 + 2      |
 * | Independent triangle            | 3𝐢         |
 * | Quad strip                      | 2𝐢 + 2     |
 * | Independent quad                | 4𝐢         |
 *
 * Flat and smooth shading are specified by `glShadeModel` with **mode** set to {@link GL_FLAT} and {@link GL_SMOOTH}, respectively.
 *
 * @summary select flat or smooth shading
 * @param mode Specifies a symbolic value representing a shading technique. Accepted values are {@link GL_FLAT} and {@link GL_SMOOTH}. The initial value is {@link GL_SMOOTH}.
 * @see [glShadeModel](https://docs.gl/gl3/glShadeModel)
 */
export function glShadeModel(mode: GLenum): void;

/**
 * Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. Stencil planes are first drawn into using GL drawing primitives, then geometry and images are rendered using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering.
 *
 * The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the reference value and the value in the stencil buffer. To enable and disable the test, call {@link glEnable} and {@link glDisable} with argument {@link GL_STENCIL_TEST}. To specify actions based on the outcome of the stencil test, call {@link glStencilOp} or {@link glStencilOpSeparate}.
 *
 * There can be two separate sets of **func**, **ref**, and **mask** parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. {@link glStencilFunc} sets both front and back stencil state to the same values. Use {@link glStencilFuncSeparate} to set front and back stencil state to different values.
 *
 * **func** is a symbolic constant that determines the stencil comparison function. It accepts one of eight values, shown in the following list. **ref** is an integer reference value that is used in the stencil comparison. It is clamped to the range [0,2ⁿ − 1], where 𝐧 is the number of bitplanes in the stencil buffer. **mask** is bitwise ANDed with both the reference value and the stored stencil value, with the ANDed values participating in the comparison.
 *
 * If **stencil** represents the value stored in the corresponding stencil buffer location, the following list shows the effect of each comparison function that can be specified by **func**. Only if the comparison succeeds is the pixel passed through to the next stage in the rasterization process (see {@link glStencilOp}). All tests treat **stencil** values as unsigned integers in the range [0,2ⁿ − 1], where 𝐧 is the number of bitplanes in the stencil buffer.
 *
 * The following values are accepted by **func**:
 *
 * - {@link GL_NEVER}
 * Always fails.
 *
 * - {@link GL_LESS}
 * Passes if ( **ref** & **mask** ) < ( **stencil** & **mask** ).
 *
 * - {@link GL_LEQUAL}
 * Passes if ( **ref** & **mask** ) <= ( **stencil** & **mask** ).
 *
 * - {@link GL_GREATER}
 * Passes if ( **ref** & **mask** ) > ( **stencil** & **mask** ).
 *
 * - {@link GL_GEQUAL}
 * Passes if ( **ref** & **mask** ) >= ( **stencil** & **mask** ).
 *
 * - {@link GL_EQUAL}
 * Passes if ( **ref** & **mask** ) = ( **stencil** & **mask** ).
 *
 * - {@link GL_NOTEQUAL}
 * Passes if ( **ref** & **mask** ) != ( **stencil** & **mask** ).
 *
 * - {@link GL_ALWAYS}
 * Always passes.
 *
 * @summary set front and back function and reference value for stencil testing
 * @param func Specifies the test function. Eight symbolic constants are valid: {@link GL_NEVER}, {@link GL_LESS}, {@link GL_LEQUAL}, {@link GL_GREATER}, {@link GL_GEQUAL}, {@link GL_EQUAL}, {@link GL_NOTEQUAL}, and {@link GL_ALWAYS}. The initial value is {@link GL_ALWAYS}.
 * @param ref Specifies the reference value for the stencil test. **ref** is clamped to the range [0,2ⁿ − 1], where 𝐧 is the number of bitplanes in the stencil buffer. The initial value is 0.
 * @param mask Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
 * @see [glStencilFunc](https://docs.gl/gl3/glStencilFunc)
 */
export function glStencilFunc(func: GLenum, ref: GLint, mask: GLuint): void;

/**
 * `glStencilMask` controls the writing of individual bits in the stencil planes. The least significant 𝐧 bits of **mask**, where 𝐧 is the number of bits in the stencil buffer, specify a mask. Where a 1 appears in the mask, it's possible to write to the corresponding bit in the stencil buffer. Where a 0 appears, the corresponding bit is write-protected. Initially, all bits are enabled for writing.
 *
 * There can be two separate **mask** writemasks; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. {@link glStencilMask} sets both front and back stencil writemasks to the same values. Use {@link glStencilMaskSeparate} to set front and back stencil writemasks to different values.
 *
 * @summary control the front and back writing of individual bits in the stencil planes
 * @param mask Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.
 * @see [glStencilMask](https://docs.gl/gl3/glStencilMask)
 */
export function glStencilMask(mask: GLuint): void;

/**
 * Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into the stencil planes using GL drawing primitives, then render geometry and images, using the stencil planes to mask out portions of the screen. Stenciling is typically used in multipass rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry rendering.
 *
 * The stencil test conditionally eliminates a pixel based on the outcome of a comparison between the value in the stencil buffer and a reference value. To enable and disable the test, call {@link glEnable} and {@link glDisable} with argument {@link GL_STENCIL_TEST}; to control it, call {@link glStencilFunc} or {@link glStencilFuncSeparate}.
 *
 * There can be two separate sets of **sfail**, **dpfail**, and **dppass** parameters; one affects back-facing polygons, and the other affects front-facing polygons as well as other non-polygon primitives. {@link glStencilOp} sets both front and back stencil state to the same values. Use {@link glStencilOpSeparate} to set front and back stencil state to different values.
 *
 * `glStencilOp` takes three arguments that indicate what happens to the stored stencil value while stenciling is enabled. If the stencil test fails, no change is made to the pixel's color or depth buffers, and **sfail** specifies what happens to the stencil buffer contents. The following eight actions are possible.
 *
 * - {@link GL_KEEP}
 * Keeps the current value.
 *
 * - {@link GL_ZERO}
 * Sets the stencil buffer value to 0.
 *
 * - {@link GL_REPLACE}
 * Sets the stencil buffer value to **ref**, as specified by {@link glStencilFunc}.
 *
 * - {@link GL_INCR}
 * Increments the current stencil buffer value. Clamps to the maximum representable unsigned value.
 *
 * - {@link GL_INCR_WRAP}
 * Increments the current stencil buffer value. Wraps stencil buffer value to zero when incrementing the maximum representable unsigned value.
 *
 * - {@link GL_DECR}
 * Decrements the current stencil buffer value. Clamps to 0.
 *
 * - {@link GL_DECR_WRAP}
 * Decrements the current stencil buffer value. Wraps stencil buffer value to the maximum representable unsigned value when decrementing a stencil buffer value of zero.
 *
 * - {@link GL_INVERT}
 * Bitwise inverts the current stencil buffer value.
 *
 * Stencil buffer values are treated as unsigned integers. When incremented and decremented, values are clamped to 0 and 2ⁿ − 1, where 𝐧 is the value returned by querying {@link GL_STENCIL_BITS}.
 *
 * The other two arguments to `glStencilOp` specify stencil buffer actions that depend on whether subsequent depth buffer tests succeed (**dppass**) or fail (**dpfail**) (see {@link glDepthFunc}). The actions are specified using the same eight symbolic constants as **sfail**. Note that **dpfail** is ignored when there is no depth buffer, or when the depth buffer is not enabled. In these cases, **sfail** and **dppass** specify stencil action when the stencil test fails and passes, respectively.
 *
 * @summary set front and back stencil test actions
 * @param sfail Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: {@link GL_KEEP}, {@link GL_ZERO}, {@link GL_REPLACE}, {@link GL_INCR}, {@link GL_INCR_WRAP}, {@link GL_DECR}, {@link GL_DECR_WRAP}, and {@link GL_INVERT}. The initial value is {@link GL_KEEP}.
 * @param dpfail Specifies the stencil action when the stencil test passes, but the depth test fails. **dpfail** accepts the same symbolic constants as **sfail**. The initial value is {@link GL_KEEP}.
 * @param dppass Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. **dppass** accepts the same symbolic constants as **sfail**. The initial value is {@link GL_KEEP}.
 * @see [glStencilOp](https://docs.gl/gl3/glStencilOp)
 */
export function glStencilOp(
	sfail: GLenum,
	dpfail: GLenum,
	dppass: GLenum
): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param s Specifies s texture coordinate.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord1d(s: GLdouble): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param s Specifies s texture coordinate.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord1f(s: GLfloat): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param s Specifies s texture coordinate.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord1i(s: GLint): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param s Specifies s texture coordinate.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord1s(s: GLshort): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param s Specifies s texture coordinate.
 * @param t Specifies t texture coordinate.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord2d(s: GLdouble, t: GLdouble): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param s Specifies s texture coordinate.
 * @param t Specifies t texture coordinate.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord2f(s: GLfloat, t: GLfloat): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param s Specifies s texture coordinate.
 * @param t Specifies t texture coordinate.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord2i(s: GLint, t: GLint): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param s Specifies s texture coordinate.
 * @param t Specifies t texture coordinate.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord2s(s: GLshort, t: GLshort): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param s Specifies s texture coordinate.
 * @param t Specifies t texture coordinate.
 * @param r Specifies r texture coordinate.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord3d(s: GLdouble, t: GLdouble, r: GLdouble): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param s Specifies s texture coordinate.
 * @param t Specifies t texture coordinate.
 * @param r Specifies r texture coordinate.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord3f(s: GLfloat, t: GLfloat, r: GLfloat): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param s Specifies s texture coordinate.
 * @param t Specifies t texture coordinate.
 * @param r Specifies r texture coordinate.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord3i(s: GLint, t: GLint, r: GLint): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param s Specifies s texture coordinate.
 * @param t Specifies t texture coordinate.
 * @param r Specifies r texture coordinate.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord3s(s: GLshort, t: GLshort, r: GLshort): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param s Specifies s texture coordinate.
 * @param t Specifies t texture coordinate.
 * @param r Specifies r texture coordinate.
 * @param q Specifies q texture coordinate.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord4d(
	s: GLdouble,
	t: GLdouble,
	r: GLdouble,
	q: GLdouble
): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param s Specifies s texture coordinate.
 * @param t Specifies t texture coordinate.
 * @param r Specifies r texture coordinate.
 * @param q Specifies q texture coordinate.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord4f(
	s: GLfloat,
	t: GLfloat,
	r: GLfloat,
	q: GLfloat
): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param s Specifies s texture coordinate.
 * @param t Specifies t texture coordinate.
 * @param r Specifies r texture coordinate.
 * @param q Specifies q texture coordinate.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord4i(s: GLint, t: GLint, r: GLint, q: GLint): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param s Specifies s texture coordinate.
 * @param t Specifies t texture coordinate.
 * @param r Specifies r texture coordinate.
 * @param q Specifies q texture coordinate.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord4s(
	s: GLshort,
	t: GLshort,
	r: GLshort,
	q: GLshort
): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param v Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the **s**, **t**, **r**, and **q** texture coordinates.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord1dv(v: GLdouble): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param v Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the **s**, **t**, **r**, and **q** texture coordinates.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord1fv(v: GLfloat): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param v Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the **s**, **t**, **r**, and **q** texture coordinates.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord1iv(v: GLint): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param v Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the **s**, **t**, **r**, and **q** texture coordinates.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord1sv(v: GLshort): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param v Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the **s**, **t**, **r**, and **q** texture coordinates.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord2dv(v: GLdouble): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param v Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the **s**, **t**, **r**, and **q** texture coordinates.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord2fv(v: GLfloat): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param v Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the **s**, **t**, **r**, and **q** texture coordinates.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord2iv(v: GLint): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param v Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the **s**, **t**, **r**, and **q** texture coordinates.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord2sv(v: GLshort): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param v Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the **s**, **t**, **r**, and **q** texture coordinates.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord3dv(v: GLdouble): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param v Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the **s**, **t**, **r**, and **q** texture coordinates.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord3fv(v: GLfloat): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param v Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the **s**, **t**, **r**, and **q** texture coordinates.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord3iv(v: GLint): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param v Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the **s**, **t**, **r**, and **q** texture coordinates.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord3sv(v: GLshort): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param v Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the **s**, **t**, **r**, and **q** texture coordinates.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord4dv(v: GLdouble): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param v Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the **s**, **t**, **r**, and **q** texture coordinates.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord4fv(v: GLfloat): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param v Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the **s**, **t**, **r**, and **q** texture coordinates.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord4iv(v: GLint): void;

/**
 * `glTexCoord` specifies texture coordinates in one, two, three, or four dimensions. `glTexCoord1` sets the current texture coordinates to (𝐬, 0, 0, 1); a call to `glTexCoord2` sets them to (𝐬, 𝐭, 0, 1). Similarly, `glTexCoord3` specifies the texture coordinates as (𝐬, 𝐭, 𝐫, 1), and `glTexCoord4` defines all four components explicitly as (𝐬, 𝐭, 𝐫, 𝐪).
 *
 * The current texture coordinates are part of the data that is associated with each vertex and with the current raster position. Initially, the values for **s**, **t**, **r**, and **q** are (0, 0, 0, 1).
 *
 * @summary set the current texture coordinates
 * @param v Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the **s**, **t**, **r**, and **q** texture coordinates.
 * @see [glTexCoord](https://docs.gl/gl3/glTexCoord)
 */
export function glTexCoord4sv(v: GLshort): void;

/**
 * `glTexCoordPointer` specifies the location and data format of an array of texture coordinates to use when rendering. **size** specifies the number of coordinates per texture coordinate set, and must be 1, 2, 3, or 4. **type** specifies the data type of each texture coordinate, and **stride** specifies the byte stride from one texture coordinate set to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays. (Single-array storage may be more efficient on some implementations; see {@link glInterleavedArrays}.)
 *
 * If a non-zero named buffer object is bound to the {@link GL_ARRAY_BUFFER} target (see {@link glBindBuffer}) while a texture coordinate array is specified, **pointer** is treated as a byte offset into the buffer object's data store. Also, the buffer object binding ({@link GL_ARRAY_BUFFER_BINDING}) is saved as texture coordinate vertex array client-side state ({@link GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING}).
 *
 * When a texture coordinate array is specified, **size**, **type**, **stride**, and **pointer** are saved as client-side state, in addition to the current vertex array buffer object binding.
 *
 * To enable and disable a texture coordinate array, call {@link glEnableClientState} and {@link glDisableClientState} with the argument {@link GL_TEXTURE_COORD_ARRAY}. If enabled, the texture coordinate array is used when {@link glArrayElement}, {@link glDrawArrays}, {@link glMultiDrawArrays}, {@link glDrawElements}, {@link glMultiDrawElements}, or {@link glDrawRangeElements} is called.
 *
 * @summary define an array of texture coordinates
 * @param size Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4.
 * @param type Specifies the data type of each texture coordinate. Symbolic constants {@link GL_SHORT}, {@link GL_INT}, {@link GL_FLOAT}, or {@link GL_DOUBLE} are accepted. The initial value is {@link GL_FLOAT}.
 * @param stride Specifies the byte offset between consecutive texture coordinate sets. If **stride** is 0, the array elements are understood to be tightly packed. The initial value is 0.
 * @param pointer Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0.
 * @see [glTexCoordPointer](https://docs.gl/gl3/glTexCoordPointer)
 */
export function glTexCoordPointer(
	size: GLint,
	type: GLenum,
	stride: GLsizei,
	pointer: GLvoid
): void;

/**
 * A texture environment specifies how texture values are interpreted when a fragment is textured. When **target** is {@link GL_TEXTURE_FILTER_CONTROL}, **pname** must be {@link GL_TEXTURE_LOD_BIAS}. When **target** is {@link GL_TEXTURE_ENV}, **pname** can be {@link GL_TEXTURE_ENV_MODE}, {@link GL_TEXTURE_ENV_COLOR}, {@link GL_COMBINE_RGB}, {@link GL_COMBINE_ALPHA}, {@link GL_RGB_SCALE}, {@link GL_ALPHA_SCALE}, {@link GL_SRC0_RGB}, {@link GL_SRC1_RGB}, {@link GL_SRC2_RGB}, {@link GL_SRC0_ALPHA}, {@link GL_SRC1_ALPHA}, or {@link GL_SRC2_ALPHA}.
 *
 * If **pname** is {@link GL_TEXTURE_ENV_MODE}, then **params** is (or points to) the symbolic name of a texture function. Six texture functions may be specified: {@link GL_ADD}, {@link GL_MODULATE}, {@link GL_DECAL}, {@link GL_BLEND}, {@link GL_REPLACE}, or {@link GL_COMBINE}.
 *
 * The following table shows the correspondence of filtered texture values 𝐑ₜ, 𝐆ₜ, 𝐁ₜ, 𝐀ₜ, 𝐋ₜ, 𝐈ₜ to texture source components. 𝐂ₛ and 𝐀ₛ are used by the texture functions described below.
 *
 * | **Texture Base Internal Format** | **𝐂ₛ**       | **𝐀ₛ** |
 * | :------------------------------- | :----------- | :----- |
 * | {@link GL_ALPHA}                 | (0, 0, 0)    | 𝐀ₜ     |
 * | {@link GL_LUMINANCE}             | (𝐋ₜ, 𝐋ₜ, 𝐋ₜ) | 1      |
 * | {@link GL_LUMINANCE_ALPHA}       | (𝐋ₜ, 𝐋ₜ, 𝐋ₜ) | 𝐀ₜ     |
 * | {@link GL_INTENSITY}             | (𝐈ₜ, 𝐈ₜ, 𝐈ₜ) | 𝐈ₜ     |
 * | {@link GL_RGB}                   | (𝐑ₜ, 𝐆ₜ, 𝐁ₜ) | 1      |
 * | {@link GL_RGBA}                  | (𝐑ₜ, 𝐆ₜ, 𝐁ₜ) | 𝐀ₜ     |
 *
 * A texture function acts on the fragment to be textured using the texture image value that applies to the fragment (see {@link glTexParameter}) and produces an RGBA color for that fragment. The following table shows how the RGBA color is produced for each of the first five texture functions that can be chosen. 𝐂 is a triple of color values (RGB) and 𝐀 is the associated alpha value. RGBA values extracted from a texture image are in the range [0,1]. The subscript 𝐩 refers to the color computed from the previous texture stage (or the incoming fragment if processing texture stage 0), the subscript 𝐬 to the texture source color, the subscript 𝐜 to the texture environment color, and the subscript 𝐯 indicates a value produced by the texture function.
 *
 * | **Texture Base Internal Format** | **Value** | **{@link GL_REPLACE} Function** | **{@link GL_MODULATE} Function** | **{@link GL_DECAL} Function** | **{@link GL_BLEND} Function** | **{@link GL_ADD} Function** |
 * | :------------------------------- | :-------- | :------------------------------ | :--------------------------- | :-------------------------------- | :---------------------------- | :-------------------------- |
 * | {@link GL_ALPHA}                 | Cᵥ =      | Cₚ                              | Cₚ                           | undefined                         | Cₚ                            | Cₚ                          |
 * |                                  | Aᵥ =      | Aₛ                              | AₚAₛ                         |                                   | Aᵥ = AₚAₛ                     | AₚAₛ                        |
 * | {@link GL_LUMINANCE}             | Cᵥ =      | Cₛ                              | CₚCₛ                         | undefined                         | Cₚ(1 − Cₛ) + C𝑐Cₛ             | Cₚ + Cₛ                     |
 * | (or 1)                           | Aᵥ =      | Aₚ                              | Aₚ                           |                                   | Aₚ                            | Aₚ                          |
 * | {@link GL_LUMINANCE_ALPHA}       | Cᵥ =      | Cₛ                              | CₚCₛ                         | undefined                         | Cₚ(1 − Cₛ) + C𝑐Cₛ             | Cₚ + Cₛ                     |
 * | (or 2)                           | Aᵥ =      | Aₛ                              | AₚAₛ                         |                                   | AₚAₛ                          | AₚAₛ                        |
 * | {@link GL_INTENSITY}             | Cᵥ =      | Cₛ                              | CₚCₛ                         | undefined                         | Cₚ(1 − Cₛ) + C𝑐Cₛ             | Cₚ + Cₛ                     |
 * |								  | Aᵥ =      | Aₛ                              | AₚAₛ                         |                                   | Aₚ(1 − Aₛ) + A𝑐Aₛ             | Aₚ + Aₛ                     |
 * | {@link GL_RGB}                   | Cᵥ =      | Cₛ                              | CₚCₛ                         | Cₛ                                | Cₚ(1 − Cₛ) + C𝑐Cₛ             | Cₚ + Cₛ                     |
 * | (or 3)                           | Aᵥ =      | Aₚ                              | Aₚ                           | Aₚ                                | Aₚ                            | Aₚ                          |
 * | {@link GL_RGBA}                  | Cᵥ =      | Cₛ                              | CₚCₛ                         | Cₚ(1 − Aₛ) + CₛAₛ                 | Cₚ(1 − Cₛ) + C𝑐Cₛ             | Cₚ + Cₛ                     |
 * | (or 4)                           | Aᵥ =      | Aₛ                              | AₚAₛ                         | Aₚ                                | AₚAₛ                          | AₚAₛ                        |
 *
 * If **pname** is {@link GL_TEXTURE_ENV_MODE}, and **params** is {@link GL_COMBINE}, the form of the texture function depends on the values of {@link GL_COMBINE_RGB} and {@link GL_COMBINE_ALPHA}.
 *
 * The following describes how the texture sources, as specified by {@link GL_SRC0_RGB}, {@link GL_SRC1_RGB}, {@link GL_SRC2_RGB}, {@link GL_SRC0_ALPHA}, {@link GL_SRC1_ALPHA}, and {@link GL_SRC2_ALPHA}, are combined to produce a final texture color. In the following tables, {@link GL_SRC0_c} is represented by *Arg0*, {@link GL_SRC1_c} is represented by *Arg1*, and {@link GL_SRC2_c} is represented by *Arg2*.
 *
 * {@link GL_COMBINE_RGB} accepts any of {@link GL_REPLACE}, {@link GL_MODULATE}, {@link GL_ADD}, {@link GL_ADD_SIGNED}, {@link GL_INTERPOLATE}, {@link GL_SUBTRACT}, {@link GL_DOT3_RGB}, or {@link GL_DOT3_RGBA}.
 *
 * | {@link GL_COMBINE_RGB}                | **Texture Function**                                                                                      |
 * | :------------------------------------------ | :-------------------------------------------------------------------------------------------------------- |
 * | {@link GL_REPLACE}                          | Arg0                                                                                                      |
 * | {@link GL_MODULATE}                         | Arg0 × Arg1                                                                                               |
 * | {@link GL_ADD}                              | Arg0 + Arg1                                                                                               |
 * | {@link GL_ADD_SIGNED}                       | Arg0 + Arg1 − 0.5                                                                                         |
 * | {@link GL_INTERPOLATE}                      | Arg0 × Arg2 + Arg1 × (1 − Arg2)                                                                           |
 * | {@link GL_SUBTRACT}                         | Arg0 − Arg1                                                                                               |
 * | {@link GL_DOT3_RGB} or {@link GL_DOT3_RGBA} | 4 × (((Arg0ᵣ − 0.5) × (Arg1ᵣ − 0.5)) + ((Arg0𝑔 − 0.5) × (Arg1𝑔 − 0.5)) + ((Arg0𝑏 − 0.5) × (Arg1𝑏 − 0.5))) |
 *
 * The scalar results for {@link GL_DOT3_RGB} and {@link GL_DOT3_RGBA} are placed into each of the 3 (RGB) or 4 (RGBA) components on output.
 *
 * Likewise, {@link GL_COMBINE_ALPHA} accepts any of {@link GL_REPLACE}, {@link GL_MODULATE}, {@link GL_ADD}, {@link GL_ADD_SIGNED}, {@link GL_INTERPOLATE}, or {@link GL_SUBTRACT}. The following table describes how alpha values are combined:
 *
 * | {@link GL_COMBINE_ALPHA} | **Texture Function**            |
 * | :----------------------- | :------------------------------ |
 * | {@link GL_REPLACE}       | Arg0                            |
 * | {@link GL_MODULATE}      | Arg0 × Arg1                     |
 * | {@link GL_ADD}           | Arg0 + Arg1                     |
 * | {@link GL_ADD_SIGNED}    | Arg0 + Arg1 − 0.5               |
 * | {@link GL_INTERPOLATE}   | Arg0 × Arg2 + Arg1 × (1 − Arg2) |
 * | {@link GL_SUBTRACT}      | Arg0 − Arg1                     |
 *
 * In the following tables, the value Cₛ represents the color sampled from the currently bound texture, C𝑐 represents the constant texture-environment color, C𝑓 represents the primary color of the incoming fragment, and Cₚ represents the color computed from the previous texture stage or C𝑓 if processing texture stage 0. Likewise, Aₛ, A𝑐 A𝑓 and Aₚ represent the respective alpha values.
 *
 * The following table describes the values assigned to *Arg0*, *Arg1* and *Arg2* based upon the RGB sources and operands:
 *
 * | {@link GL_SRCn_RGB}      | {@link GL_OPERANDn_RGB}        | Argument Value |
 * | :----------------------- | :----------------------------- | :------------- |
 * | {@link GL_TEXTURE}       | {@link GL_SRC_COLOR}           | Cₛ			    |
 * |                          | {@link GL_ONE_MINUS_SRC_COLOR} | 1 − Cₛ         |
 * |                          | {@link GL_SRC_ALPHA}           | Aₛ             |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − Aₛ         |
 * | {@link GL_TEXTUREn}      | {@link GL_SRC_COLOR}           | Cₛ             |
 * |                          | {@link GL_ONE_MINUS_SRC_COLOR} | 1 − Cₛ         |
 * |                          | {@link GL_SRC_ALPHA}           | Aₛ             |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − Aₛ         |
 * | {@link GL_CONSTANT}      | {@link GL_SRC_COLOR}           | C𝑐             |
 * |                          | {@link GL_ONE_MINUS_SRC_COLOR} | 1 − C𝑐         |
 * |                          | {@link GL_SRC_ALPHA}           | A𝑐             |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − A𝑐         |
 * | {@link GL_PRIMARY_COLOR} | {@link GL_SRC_COLOR}           | C𝑓             |
 * |                          | {@link GL_ONE_MINUS_SRC_COLOR} | 1 − C𝑓         |
 * |                          | {@link GL_SRC_ALPHA}           | A𝑓             |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − A𝑓         |
 * | {@link GL_PREVIOUS}      | {@link GL_SRC_COLOR}           | Cₚ             |
 * |                          | {@link GL_ONE_MINUS_SRC_COLOR} | 1 − Cₚ         |
 * |                          | {@link GL_SRC_ALPHA}           | Aₚ             |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − Aₚ         |
 *
 * For {@link GL_TEXTUREn} sources, Cₛ and Aₛ represent the color and alpha, respectively, produced from texture stage 𝐧.
 *
 * The follow table describes the values assigned to *Arg0*, *Arg1*, and *Arg2* based upon the alpha sources and operands:
 *
 * | {@link GL_SRCn_ALPHA}    | {@link GL_OPERANDn_ALPHA}      | **Argument Value** |
 * | :----------------------- | :----------------------------- | :----------------- |
 * | {@link GL_TEXTURE}       | {@link GL_SRC_ALPHA}           | Aₛ                 |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − Aₛ             |
 * | {@link GL_TEXTUREn}      | {@link GL_SRC_ALPHA}           | Aₛ                 |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − Aₛ             |
 * | {@link GL_CONSTANT}      | {@link GL_SRC_ALPHA}           | A𝑐                 |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − A𝑐             |
 * | {@link GL_PRIMARY_COLOR} | {@link GL_SRC_ALPHA}           | A𝑓                 |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − A𝑓             |
 * | {@link GL_PREVIOUS}      | {@link GL_SRC_ALPHA}           | Aₚ                 |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − Aₚ             |
 *
 * The RGB and alpha results of the texture function are multipled by the values of {@link GL_RGB_SCALE} and {@link GL_ALPHA_SCALE}, respectively, and clamped to the range [0,1].
 *
 * If **pname** is {@link GL_TEXTURE_ENV_COLOR}, **params** is a pointer to an array that holds an RGBA color consisting of four values. Integer color components are interpreted linearly such that the most positive integer maps to 1.0, and the most negative integer maps to -1.0. The values are clamped to the range [0,1] when they are specified. C𝑐 takes these four values.
 *
 * If **pname** is {@link GL_TEXTURE_LOD_BIAS}, the value specified is added to the texture level-of-detail parameter, that selects which mipmap, or mipmaps depending upon the selected {@link GL_TEXTURE_MIN_FILTER}, will be sampled.
 *
 * {@link GL_TEXTURE_ENV_MODE} defaults to {@link GL_MODULATE} and {@link GL_TEXTURE_ENV_COLOR} defaults to (0, 0, 0, 0).
 *
 * If **target** is {@link GL_POINT_SPRITE} and **pname** is {@link GL_COORD_REPLACE}, the boolean value specified is used to either enable or disable point sprite texture coordinate replacement. The default value is {@link GL_FALSE}.
 *
 * @summary set texture environment parameters
 * @param target Specifies a texture environment. May be {@link GL_TEXTURE_ENV}, {@link GL_TEXTURE_FILTER_CONTROL} or {@link GL_POINT_SPRITE}.
 * @param pname Specifies the symbolic name of a single-valued texture environment parameter. May be either {@link GL_TEXTURE_ENV_MODE}, {@link GL_TEXTURE_LOD_BIAS}, {@link GL_COMBINE_RGB}, {@link GL_COMBINE_ALPHA}, {@link GL_SRC0_RGB}, {@link GL_SRC1_RGB}, {@link GL_SRC2_RGB}, {@link GL_SRC0_ALPHA}, {@link GL_SRC1_ALPHA}, {@link GL_SRC2_ALPHA}, {@link GL_OPERAND0_RGB}, {@link GL_OPERAND1_RGB}, {@link GL_OPERAND2_RGB}, {@link GL_OPERAND0_ALPHA}, {@link GL_OPERAND1_ALPHA}, {@link GL_OPERAND2_ALPHA}, {@link GL_RGB_SCALE}, {@link GL_ALPHA_SCALE}, or {@link GL_COORD_REPLACE}.
 * @param param Specifies a single symbolic constant, one of {@link GL_ADD}, {@link GL_ADD_SIGNED}, {@link GL_INTERPOLATE}, {@link GL_MODULATE}, {@link GL_DECAL}, {@link GL_BLEND}, {@link GL_REPLACE}, {@link GL_SUBTRACT}, {@link GL_COMBINE}, {@link GL_TEXTURE}, {@link GL_CONSTANT}, {@link GL_PRIMARY_COLOR}, {@link GL_PREVIOUS}, {@link GL_SRC_COLOR}, {@link GL_ONE_MINUS_SRC_COLOR}, {@link GL_SRC_ALPHA}, {@link GL_ONE_MINUS_SRC_ALPHA}, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the {@link GL_RGB_SCALE} or {@link GL_ALPHA_SCALE}.
 * @see [glTexEnv](https://docs.gl/gl3/glTexEnv)
 */
export function glTexEnvf(target: GLenum, pname: GLenum, param: GLfloat): void;

/**
 * A texture environment specifies how texture values are interpreted when a fragment is textured. When **target** is {@link GL_TEXTURE_FILTER_CONTROL}, **pname** must be {@link GL_TEXTURE_LOD_BIAS}. When **target** is {@link GL_TEXTURE_ENV}, **pname** can be {@link GL_TEXTURE_ENV_MODE}, {@link GL_TEXTURE_ENV_COLOR}, {@link GL_COMBINE_RGB}, {@link GL_COMBINE_ALPHA}, {@link GL_RGB_SCALE}, {@link GL_ALPHA_SCALE}, {@link GL_SRC0_RGB}, {@link GL_SRC1_RGB}, {@link GL_SRC2_RGB}, {@link GL_SRC0_ALPHA}, {@link GL_SRC1_ALPHA}, or {@link GL_SRC2_ALPHA}.
 *
 * If **pname** is {@link GL_TEXTURE_ENV_MODE}, then **params** is (or points to) the symbolic name of a texture function. Six texture functions may be specified: {@link GL_ADD}, {@link GL_MODULATE}, {@link GL_DECAL}, {@link GL_BLEND}, {@link GL_REPLACE}, or {@link GL_COMBINE}.
 *
 * The following table shows the correspondence of filtered texture values 𝐑ₜ, 𝐆ₜ, 𝐁ₜ, 𝐀ₜ, 𝐋ₜ, 𝐈ₜ to texture source components. 𝐂ₛ and 𝐀ₛ are used by the texture functions described below.
 *
 * | **Texture Base Internal Format** | **𝐂ₛ**       | **𝐀ₛ** |
 * | :------------------------------- | :----------- | :----- |
 * | {@link GL_ALPHA}                 | (0, 0, 0)    | 𝐀ₜ     |
 * | {@link GL_LUMINANCE}             | (𝐋ₜ, 𝐋ₜ, 𝐋ₜ) | 1      |
 * | {@link GL_LUMINANCE_ALPHA}       | (𝐋ₜ, 𝐋ₜ, 𝐋ₜ) | 𝐀ₜ     |
 * | {@link GL_INTENSITY}             | (𝐈ₜ, 𝐈ₜ, 𝐈ₜ) | 𝐈ₜ     |
 * | {@link GL_RGB}                   | (𝐑ₜ, 𝐆ₜ, 𝐁ₜ) | 1      |
 * | {@link GL_RGBA}                  | (𝐑ₜ, 𝐆ₜ, 𝐁ₜ) | 𝐀ₜ     |
 *
 * A texture function acts on the fragment to be textured using the texture image value that applies to the fragment (see {@link glTexParameter}) and produces an RGBA color for that fragment. The following table shows how the RGBA color is produced for each of the first five texture functions that can be chosen. 𝐂 is a triple of color values (RGB) and 𝐀 is the associated alpha value. RGBA values extracted from a texture image are in the range [0,1]. The subscript 𝐩 refers to the color computed from the previous texture stage (or the incoming fragment if processing texture stage 0), the subscript 𝐬 to the texture source color, the subscript 𝐜 to the texture environment color, and the subscript 𝐯 indicates a value produced by the texture function.
 *
 * | **Texture Base Internal Format** | **Value** | **{@link GL_REPLACE} Function** | **{@link GL_MODULATE} Function** | **{@link GL_DECAL} Function** | **{@link GL_BLEND} Function** | **{@link GL_ADD} Function** |
 * | :------------------------------- | :-------- | :------------------------------ | :--------------------------- | :-------------------------------- | :---------------------------- | :-------------------------- |
 * | {@link GL_ALPHA}                 | Cᵥ =      | Cₚ                              | Cₚ                           | undefined                         | Cₚ                            | Cₚ                          |
 * |                                  | Aᵥ =      | Aₛ                              | AₚAₛ                         |                                   | Aᵥ = AₚAₛ                     | AₚAₛ                        |
 * | {@link GL_LUMINANCE}             | Cᵥ =      | Cₛ                              | CₚCₛ                         | undefined                         | Cₚ(1 − Cₛ) + C𝑐Cₛ             | Cₚ + Cₛ                     |
 * | (or 1)                           | Aᵥ =      | Aₚ                              | Aₚ                           |                                   | Aₚ                            | Aₚ                          |
 * | {@link GL_LUMINANCE_ALPHA}       | Cᵥ =      | Cₛ                              | CₚCₛ                         | undefined                         | Cₚ(1 − Cₛ) + C𝑐Cₛ             | Cₚ + Cₛ                     |
 * | (or 2)                           | Aᵥ =      | Aₛ                              | AₚAₛ                         |                                   | AₚAₛ                          | AₚAₛ                        |
 * | {@link GL_INTENSITY}             | Cᵥ =      | Cₛ                              | CₚCₛ                         | undefined                         | Cₚ(1 − Cₛ) + C𝑐Cₛ             | Cₚ + Cₛ                     |
 * |								  | Aᵥ =      | Aₛ                              | AₚAₛ                         |                                   | Aₚ(1 − Aₛ) + A𝑐Aₛ             | Aₚ + Aₛ                     |
 * | {@link GL_RGB}                   | Cᵥ =      | Cₛ                              | CₚCₛ                         | Cₛ                                | Cₚ(1 − Cₛ) + C𝑐Cₛ             | Cₚ + Cₛ                     |
 * | (or 3)                           | Aᵥ =      | Aₚ                              | Aₚ                           | Aₚ                                | Aₚ                            | Aₚ                          |
 * | {@link GL_RGBA}                  | Cᵥ =      | Cₛ                              | CₚCₛ                         | Cₚ(1 − Aₛ) + CₛAₛ                 | Cₚ(1 − Cₛ) + C𝑐Cₛ             | Cₚ + Cₛ                     |
 * | (or 4)                           | Aᵥ =      | Aₛ                              | AₚAₛ                         | Aₚ                                | AₚAₛ                          | AₚAₛ                        |
 *
 * If **pname** is {@link GL_TEXTURE_ENV_MODE}, and **params** is {@link GL_COMBINE}, the form of the texture function depends on the values of {@link GL_COMBINE_RGB} and {@link GL_COMBINE_ALPHA}.
 *
 * The following describes how the texture sources, as specified by {@link GL_SRC0_RGB}, {@link GL_SRC1_RGB}, {@link GL_SRC2_RGB}, {@link GL_SRC0_ALPHA}, {@link GL_SRC1_ALPHA}, and {@link GL_SRC2_ALPHA}, are combined to produce a final texture color. In the following tables, {@link GL_SRC0_c} is represented by *Arg0*, {@link GL_SRC1_c} is represented by *Arg1*, and {@link GL_SRC2_c} is represented by *Arg2*.
 *
 * {@link GL_COMBINE_RGB} accepts any of {@link GL_REPLACE}, {@link GL_MODULATE}, {@link GL_ADD}, {@link GL_ADD_SIGNED}, {@link GL_INTERPOLATE}, {@link GL_SUBTRACT}, {@link GL_DOT3_RGB}, or {@link GL_DOT3_RGBA}.
 *
 * | {@link GL_COMBINE_RGB}                | **Texture Function**                                                                                      |
 * | :------------------------------------------ | :-------------------------------------------------------------------------------------------------------- |
 * | {@link GL_REPLACE}                          | Arg0                                                                                                      |
 * | {@link GL_MODULATE}                         | Arg0 × Arg1                                                                                               |
 * | {@link GL_ADD}                              | Arg0 + Arg1                                                                                               |
 * | {@link GL_ADD_SIGNED}                       | Arg0 + Arg1 − 0.5                                                                                         |
 * | {@link GL_INTERPOLATE}                      | Arg0 × Arg2 + Arg1 × (1 − Arg2)                                                                           |
 * | {@link GL_SUBTRACT}                         | Arg0 − Arg1                                                                                               |
 * | {@link GL_DOT3_RGB} or {@link GL_DOT3_RGBA} | 4 × (((Arg0ᵣ − 0.5) × (Arg1ᵣ − 0.5)) + ((Arg0𝑔 − 0.5) × (Arg1𝑔 − 0.5)) + ((Arg0𝑏 − 0.5) × (Arg1𝑏 − 0.5))) |
 *
 * The scalar results for {@link GL_DOT3_RGB} and {@link GL_DOT3_RGBA} are placed into each of the 3 (RGB) or 4 (RGBA) components on output.
 *
 * Likewise, {@link GL_COMBINE_ALPHA} accepts any of {@link GL_REPLACE}, {@link GL_MODULATE}, {@link GL_ADD}, {@link GL_ADD_SIGNED}, {@link GL_INTERPOLATE}, or {@link GL_SUBTRACT}. The following table describes how alpha values are combined:
 *
 * | {@link GL_COMBINE_ALPHA} | **Texture Function**            |
 * | :----------------------- | :------------------------------ |
 * | {@link GL_REPLACE}       | Arg0                            |
 * | {@link GL_MODULATE}      | Arg0 × Arg1                     |
 * | {@link GL_ADD}           | Arg0 + Arg1                     |
 * | {@link GL_ADD_SIGNED}    | Arg0 + Arg1 − 0.5               |
 * | {@link GL_INTERPOLATE}   | Arg0 × Arg2 + Arg1 × (1 − Arg2) |
 * | {@link GL_SUBTRACT}      | Arg0 − Arg1                     |
 *
 * In the following tables, the value Cₛ represents the color sampled from the currently bound texture, C𝑐 represents the constant texture-environment color, C𝑓 represents the primary color of the incoming fragment, and Cₚ represents the color computed from the previous texture stage or C𝑓 if processing texture stage 0. Likewise, Aₛ, A𝑐 A𝑓 and Aₚ represent the respective alpha values.
 *
 * The following table describes the values assigned to *Arg0*, *Arg1* and *Arg2* based upon the RGB sources and operands:
 *
 * | {@link GL_SRCn_RGB}      | {@link GL_OPERANDn_RGB}        | Argument Value |
 * | :----------------------- | :----------------------------- | :------------- |
 * | {@link GL_TEXTURE}       | {@link GL_SRC_COLOR}           | Cₛ			    |
 * |                          | {@link GL_ONE_MINUS_SRC_COLOR} | 1 − Cₛ         |
 * |                          | {@link GL_SRC_ALPHA}           | Aₛ             |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − Aₛ         |
 * | {@link GL_TEXTUREn}      | {@link GL_SRC_COLOR}           | Cₛ             |
 * |                          | {@link GL_ONE_MINUS_SRC_COLOR} | 1 − Cₛ         |
 * |                          | {@link GL_SRC_ALPHA}           | Aₛ             |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − Aₛ         |
 * | {@link GL_CONSTANT}      | {@link GL_SRC_COLOR}           | C𝑐             |
 * |                          | {@link GL_ONE_MINUS_SRC_COLOR} | 1 − C𝑐         |
 * |                          | {@link GL_SRC_ALPHA}           | A𝑐             |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − A𝑐         |
 * | {@link GL_PRIMARY_COLOR} | {@link GL_SRC_COLOR}           | C𝑓             |
 * |                          | {@link GL_ONE_MINUS_SRC_COLOR} | 1 − C𝑓         |
 * |                          | {@link GL_SRC_ALPHA}           | A𝑓             |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − A𝑓         |
 * | {@link GL_PREVIOUS}      | {@link GL_SRC_COLOR}           | Cₚ             |
 * |                          | {@link GL_ONE_MINUS_SRC_COLOR} | 1 − Cₚ         |
 * |                          | {@link GL_SRC_ALPHA}           | Aₚ             |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − Aₚ         |
 *
 * For {@link GL_TEXTUREn} sources, Cₛ and Aₛ represent the color and alpha, respectively, produced from texture stage 𝐧.
 *
 * The follow table describes the values assigned to *Arg0*, *Arg1*, and *Arg2* based upon the alpha sources and operands:
 *
 * | {@link GL_SRCn_ALPHA}    | {@link GL_OPERANDn_ALPHA}      | **Argument Value** |
 * | :----------------------- | :----------------------------- | :----------------- |
 * | {@link GL_TEXTURE}       | {@link GL_SRC_ALPHA}           | Aₛ                 |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − Aₛ             |
 * | {@link GL_TEXTUREn}      | {@link GL_SRC_ALPHA}           | Aₛ                 |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − Aₛ             |
 * | {@link GL_CONSTANT}      | {@link GL_SRC_ALPHA}           | A𝑐                 |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − A𝑐             |
 * | {@link GL_PRIMARY_COLOR} | {@link GL_SRC_ALPHA}           | A𝑓                 |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − A𝑓             |
 * | {@link GL_PREVIOUS}      | {@link GL_SRC_ALPHA}           | Aₚ                 |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − Aₚ             |
 *
 * The RGB and alpha results of the texture function are multipled by the values of {@link GL_RGB_SCALE} and {@link GL_ALPHA_SCALE}, respectively, and clamped to the range [0,1].
 *
 * If **pname** is {@link GL_TEXTURE_ENV_COLOR}, **params** is a pointer to an array that holds an RGBA color consisting of four values. Integer color components are interpreted linearly such that the most positive integer maps to 1.0, and the most negative integer maps to -1.0. The values are clamped to the range [0,1] when they are specified. C𝑐 takes these four values.
 *
 * If **pname** is {@link GL_TEXTURE_LOD_BIAS}, the value specified is added to the texture level-of-detail parameter, that selects which mipmap, or mipmaps depending upon the selected {@link GL_TEXTURE_MIN_FILTER}, will be sampled.
 *
 * {@link GL_TEXTURE_ENV_MODE} defaults to {@link GL_MODULATE} and {@link GL_TEXTURE_ENV_COLOR} defaults to (0, 0, 0, 0).
 *
 * If **target** is {@link GL_POINT_SPRITE} and **pname** is {@link GL_COORD_REPLACE}, the boolean value specified is used to either enable or disable point sprite texture coordinate replacement. The default value is {@link GL_FALSE}.
 *
 * @summary set texture environment parameters
 * @param target Specifies a texture environment. May be {@link GL_TEXTURE_ENV}, {@link GL_TEXTURE_FILTER_CONTROL} or {@link GL_POINT_SPRITE}.
 * @param pname Specifies the symbolic name of a single-valued texture environment parameter. May be either {@link GL_TEXTURE_ENV_MODE}, {@link GL_TEXTURE_LOD_BIAS}, {@link GL_COMBINE_RGB}, {@link GL_COMBINE_ALPHA}, {@link GL_SRC0_RGB}, {@link GL_SRC1_RGB}, {@link GL_SRC2_RGB}, {@link GL_SRC0_ALPHA}, {@link GL_SRC1_ALPHA}, {@link GL_SRC2_ALPHA}, {@link GL_OPERAND0_RGB}, {@link GL_OPERAND1_RGB}, {@link GL_OPERAND2_RGB}, {@link GL_OPERAND0_ALPHA}, {@link GL_OPERAND1_ALPHA}, {@link GL_OPERAND2_ALPHA}, {@link GL_RGB_SCALE}, {@link GL_ALPHA_SCALE}, or {@link GL_COORD_REPLACE}.
 * @param param Specifies a single symbolic constant, one of {@link GL_ADD}, {@link GL_ADD_SIGNED}, {@link GL_INTERPOLATE}, {@link GL_MODULATE}, {@link GL_DECAL}, {@link GL_BLEND}, {@link GL_REPLACE}, {@link GL_SUBTRACT}, {@link GL_COMBINE}, {@link GL_TEXTURE}, {@link GL_CONSTANT}, {@link GL_PRIMARY_COLOR}, {@link GL_PREVIOUS}, {@link GL_SRC_COLOR}, {@link GL_ONE_MINUS_SRC_COLOR}, {@link GL_SRC_ALPHA}, {@link GL_ONE_MINUS_SRC_ALPHA}, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the {@link GL_RGB_SCALE} or {@link GL_ALPHA_SCALE}.
 * @see [glTexEnv](https://docs.gl/gl3/glTexEnv)
 */
export function glTexEnvi(target: GLenum, pname: GLenum, param: GLint): void;

/**
 * A texture environment specifies how texture values are interpreted when a fragment is textured. When **target** is {@link GL_TEXTURE_FILTER_CONTROL}, **pname** must be {@link GL_TEXTURE_LOD_BIAS}. When **target** is {@link GL_TEXTURE_ENV}, **pname** can be {@link GL_TEXTURE_ENV_MODE}, {@link GL_TEXTURE_ENV_COLOR}, {@link GL_COMBINE_RGB}, {@link GL_COMBINE_ALPHA}, {@link GL_RGB_SCALE}, {@link GL_ALPHA_SCALE}, {@link GL_SRC0_RGB}, {@link GL_SRC1_RGB}, {@link GL_SRC2_RGB}, {@link GL_SRC0_ALPHA}, {@link GL_SRC1_ALPHA}, or {@link GL_SRC2_ALPHA}.
 *
 * If **pname** is {@link GL_TEXTURE_ENV_MODE}, then **params** is (or points to) the symbolic name of a texture function. Six texture functions may be specified: {@link GL_ADD}, {@link GL_MODULATE}, {@link GL_DECAL}, {@link GL_BLEND}, {@link GL_REPLACE}, or {@link GL_COMBINE}.
 *
 * The following table shows the correspondence of filtered texture values 𝐑ₜ, 𝐆ₜ, 𝐁ₜ, 𝐀ₜ, 𝐋ₜ, 𝐈ₜ to texture source components. 𝐂ₛ and 𝐀ₛ are used by the texture functions described below.
 *
 * | **Texture Base Internal Format** | **𝐂ₛ**       | **𝐀ₛ** |
 * | :------------------------------- | :----------- | :----- |
 * | {@link GL_ALPHA}                 | (0, 0, 0)    | 𝐀ₜ     |
 * | {@link GL_LUMINANCE}             | (𝐋ₜ, 𝐋ₜ, 𝐋ₜ) | 1      |
 * | {@link GL_LUMINANCE_ALPHA}       | (𝐋ₜ, 𝐋ₜ, 𝐋ₜ) | 𝐀ₜ     |
 * | {@link GL_INTENSITY}             | (𝐈ₜ, 𝐈ₜ, 𝐈ₜ) | 𝐈ₜ     |
 * | {@link GL_RGB}                   | (𝐑ₜ, 𝐆ₜ, 𝐁ₜ) | 1      |
 * | {@link GL_RGBA}                  | (𝐑ₜ, 𝐆ₜ, 𝐁ₜ) | 𝐀ₜ     |
 *
 * A texture function acts on the fragment to be textured using the texture image value that applies to the fragment (see {@link glTexParameter}) and produces an RGBA color for that fragment. The following table shows how the RGBA color is produced for each of the first five texture functions that can be chosen. 𝐂 is a triple of color values (RGB) and 𝐀 is the associated alpha value. RGBA values extracted from a texture image are in the range [0,1]. The subscript 𝐩 refers to the color computed from the previous texture stage (or the incoming fragment if processing texture stage 0), the subscript 𝐬 to the texture source color, the subscript 𝐜 to the texture environment color, and the subscript 𝐯 indicates a value produced by the texture function.
 *
 * | **Texture Base Internal Format** | **Value** | **{@link GL_REPLACE} Function** | **{@link GL_MODULATE} Function** | **{@link GL_DECAL} Function** | **{@link GL_BLEND} Function** | **{@link GL_ADD} Function** |
 * | :------------------------------- | :-------- | :------------------------------ | :--------------------------- | :-------------------------------- | :---------------------------- | :-------------------------- |
 * | {@link GL_ALPHA}                 | Cᵥ =      | Cₚ                              | Cₚ                           | undefined                         | Cₚ                            | Cₚ                          |
 * |                                  | Aᵥ =      | Aₛ                              | AₚAₛ                         |                                   | Aᵥ = AₚAₛ                     | AₚAₛ                        |
 * | {@link GL_LUMINANCE}             | Cᵥ =      | Cₛ                              | CₚCₛ                         | undefined                         | Cₚ(1 − Cₛ) + C𝑐Cₛ             | Cₚ + Cₛ                     |
 * | (or 1)                           | Aᵥ =      | Aₚ                              | Aₚ                           |                                   | Aₚ                            | Aₚ                          |
 * | {@link GL_LUMINANCE_ALPHA}       | Cᵥ =      | Cₛ                              | CₚCₛ                         | undefined                         | Cₚ(1 − Cₛ) + C𝑐Cₛ             | Cₚ + Cₛ                     |
 * | (or 2)                           | Aᵥ =      | Aₛ                              | AₚAₛ                         |                                   | AₚAₛ                          | AₚAₛ                        |
 * | {@link GL_INTENSITY}             | Cᵥ =      | Cₛ                              | CₚCₛ                         | undefined                         | Cₚ(1 − Cₛ) + C𝑐Cₛ             | Cₚ + Cₛ                     |
 * |								  | Aᵥ =      | Aₛ                              | AₚAₛ                         |                                   | Aₚ(1 − Aₛ) + A𝑐Aₛ             | Aₚ + Aₛ                     |
 * | {@link GL_RGB}                   | Cᵥ =      | Cₛ                              | CₚCₛ                         | Cₛ                                | Cₚ(1 − Cₛ) + C𝑐Cₛ             | Cₚ + Cₛ                     |
 * | (or 3)                           | Aᵥ =      | Aₚ                              | Aₚ                           | Aₚ                                | Aₚ                            | Aₚ                          |
 * | {@link GL_RGBA}                  | Cᵥ =      | Cₛ                              | CₚCₛ                         | Cₚ(1 − Aₛ) + CₛAₛ                 | Cₚ(1 − Cₛ) + C𝑐Cₛ             | Cₚ + Cₛ                     |
 * | (or 4)                           | Aᵥ =      | Aₛ                              | AₚAₛ                         | Aₚ                                | AₚAₛ                          | AₚAₛ                        |
 *
 * If **pname** is {@link GL_TEXTURE_ENV_MODE}, and **params** is {@link GL_COMBINE}, the form of the texture function depends on the values of {@link GL_COMBINE_RGB} and {@link GL_COMBINE_ALPHA}.
 *
 * The following describes how the texture sources, as specified by {@link GL_SRC0_RGB}, {@link GL_SRC1_RGB}, {@link GL_SRC2_RGB}, {@link GL_SRC0_ALPHA}, {@link GL_SRC1_ALPHA}, and {@link GL_SRC2_ALPHA}, are combined to produce a final texture color. In the following tables, {@link GL_SRC0_c} is represented by *Arg0*, {@link GL_SRC1_c} is represented by *Arg1*, and {@link GL_SRC2_c} is represented by *Arg2*.
 *
 * {@link GL_COMBINE_RGB} accepts any of {@link GL_REPLACE}, {@link GL_MODULATE}, {@link GL_ADD}, {@link GL_ADD_SIGNED}, {@link GL_INTERPOLATE}, {@link GL_SUBTRACT}, {@link GL_DOT3_RGB}, or {@link GL_DOT3_RGBA}.
 *
 * | {@link GL_COMBINE_RGB}                | **Texture Function**                                                                                      |
 * | :------------------------------------------ | :-------------------------------------------------------------------------------------------------------- |
 * | {@link GL_REPLACE}                          | Arg0                                                                                                      |
 * | {@link GL_MODULATE}                         | Arg0 × Arg1                                                                                               |
 * | {@link GL_ADD}                              | Arg0 + Arg1                                                                                               |
 * | {@link GL_ADD_SIGNED}                       | Arg0 + Arg1 − 0.5                                                                                         |
 * | {@link GL_INTERPOLATE}                      | Arg0 × Arg2 + Arg1 × (1 − Arg2)                                                                           |
 * | {@link GL_SUBTRACT}                         | Arg0 − Arg1                                                                                               |
 * | {@link GL_DOT3_RGB} or {@link GL_DOT3_RGBA} | 4 × (((Arg0ᵣ − 0.5) × (Arg1ᵣ − 0.5)) + ((Arg0𝑔 − 0.5) × (Arg1𝑔 − 0.5)) + ((Arg0𝑏 − 0.5) × (Arg1𝑏 − 0.5))) |
 *
 * The scalar results for {@link GL_DOT3_RGB} and {@link GL_DOT3_RGBA} are placed into each of the 3 (RGB) or 4 (RGBA) components on output.
 *
 * Likewise, {@link GL_COMBINE_ALPHA} accepts any of {@link GL_REPLACE}, {@link GL_MODULATE}, {@link GL_ADD}, {@link GL_ADD_SIGNED}, {@link GL_INTERPOLATE}, or {@link GL_SUBTRACT}. The following table describes how alpha values are combined:
 *
 * | {@link GL_COMBINE_ALPHA} | **Texture Function**            |
 * | :----------------------- | :------------------------------ |
 * | {@link GL_REPLACE}       | Arg0                            |
 * | {@link GL_MODULATE}      | Arg0 × Arg1                     |
 * | {@link GL_ADD}           | Arg0 + Arg1                     |
 * | {@link GL_ADD_SIGNED}    | Arg0 + Arg1 − 0.5               |
 * | {@link GL_INTERPOLATE}   | Arg0 × Arg2 + Arg1 × (1 − Arg2) |
 * | {@link GL_SUBTRACT}      | Arg0 − Arg1                     |
 *
 * In the following tables, the value Cₛ represents the color sampled from the currently bound texture, C𝑐 represents the constant texture-environment color, C𝑓 represents the primary color of the incoming fragment, and Cₚ represents the color computed from the previous texture stage or C𝑓 if processing texture stage 0. Likewise, Aₛ, A𝑐 A𝑓 and Aₚ represent the respective alpha values.
 *
 * The following table describes the values assigned to *Arg0*, *Arg1* and *Arg2* based upon the RGB sources and operands:
 *
 * | {@link GL_SRCn_RGB}      | {@link GL_OPERANDn_RGB}        | Argument Value |
 * | :----------------------- | :----------------------------- | :------------- |
 * | {@link GL_TEXTURE}       | {@link GL_SRC_COLOR}           | Cₛ			    |
 * |                          | {@link GL_ONE_MINUS_SRC_COLOR} | 1 − Cₛ         |
 * |                          | {@link GL_SRC_ALPHA}           | Aₛ             |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − Aₛ         |
 * | {@link GL_TEXTUREn}      | {@link GL_SRC_COLOR}           | Cₛ             |
 * |                          | {@link GL_ONE_MINUS_SRC_COLOR} | 1 − Cₛ         |
 * |                          | {@link GL_SRC_ALPHA}           | Aₛ             |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − Aₛ         |
 * | {@link GL_CONSTANT}      | {@link GL_SRC_COLOR}           | C𝑐             |
 * |                          | {@link GL_ONE_MINUS_SRC_COLOR} | 1 − C𝑐         |
 * |                          | {@link GL_SRC_ALPHA}           | A𝑐             |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − A𝑐         |
 * | {@link GL_PRIMARY_COLOR} | {@link GL_SRC_COLOR}           | C𝑓             |
 * |                          | {@link GL_ONE_MINUS_SRC_COLOR} | 1 − C𝑓         |
 * |                          | {@link GL_SRC_ALPHA}           | A𝑓             |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − A𝑓         |
 * | {@link GL_PREVIOUS}      | {@link GL_SRC_COLOR}           | Cₚ             |
 * |                          | {@link GL_ONE_MINUS_SRC_COLOR} | 1 − Cₚ         |
 * |                          | {@link GL_SRC_ALPHA}           | Aₚ             |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − Aₚ         |
 *
 * For {@link GL_TEXTUREn} sources, Cₛ and Aₛ represent the color and alpha, respectively, produced from texture stage 𝐧.
 *
 * The follow table describes the values assigned to *Arg0*, *Arg1*, and *Arg2* based upon the alpha sources and operands:
 *
 * | {@link GL_SRCn_ALPHA}    | {@link GL_OPERANDn_ALPHA}      | **Argument Value** |
 * | :----------------------- | :----------------------------- | :----------------- |
 * | {@link GL_TEXTURE}       | {@link GL_SRC_ALPHA}           | Aₛ                 |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − Aₛ             |
 * | {@link GL_TEXTUREn}      | {@link GL_SRC_ALPHA}           | Aₛ                 |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − Aₛ             |
 * | {@link GL_CONSTANT}      | {@link GL_SRC_ALPHA}           | A𝑐                 |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − A𝑐             |
 * | {@link GL_PRIMARY_COLOR} | {@link GL_SRC_ALPHA}           | A𝑓                 |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − A𝑓             |
 * | {@link GL_PREVIOUS}      | {@link GL_SRC_ALPHA}           | Aₚ                 |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − Aₚ             |
 *
 * The RGB and alpha results of the texture function are multipled by the values of {@link GL_RGB_SCALE} and {@link GL_ALPHA_SCALE}, respectively, and clamped to the range [0,1].
 *
 * If **pname** is {@link GL_TEXTURE_ENV_COLOR}, **params** is a pointer to an array that holds an RGBA color consisting of four values. Integer color components are interpreted linearly such that the most positive integer maps to 1.0, and the most negative integer maps to -1.0. The values are clamped to the range [0,1] when they are specified. C𝑐 takes these four values.
 *
 * If **pname** is {@link GL_TEXTURE_LOD_BIAS}, the value specified is added to the texture level-of-detail parameter, that selects which mipmap, or mipmaps depending upon the selected {@link GL_TEXTURE_MIN_FILTER}, will be sampled.
 *
 * {@link GL_TEXTURE_ENV_MODE} defaults to {@link GL_MODULATE} and {@link GL_TEXTURE_ENV_COLOR} defaults to (0, 0, 0, 0).
 *
 * If **target** is {@link GL_POINT_SPRITE} and **pname** is {@link GL_COORD_REPLACE}, the boolean value specified is used to either enable or disable point sprite texture coordinate replacement. The default value is {@link GL_FALSE}.
 *
 * @summary set texture environment parameters
 * @param target Specifies a texture environment. May be either {@link GL_TEXTURE_ENV}, or {@link GL_TEXTURE_FILTER_CONTROL}.
 * @param pname Specifies the symbolic name of a texture environment parameter. Accepted values are {@link GL_TEXTURE_ENV_MODE}, {@link GL_TEXTURE_ENV_COLOR}, or {@link GL_TEXTURE_LOD_BIAS}.
 * @param params Specifies a pointer to a parameter array that contains either a single symbolic constant, single floating-point number, or an RGBA color.
 * @see [glTexEnv](https://docs.gl/gl3/glTexEnv)
 */
export function glTexEnvfv(
	target: GLenum,
	pname: GLenum,
	params: GLfloat
): void;

/**
 * A texture environment specifies how texture values are interpreted when a fragment is textured. When **target** is {@link GL_TEXTURE_FILTER_CONTROL}, **pname** must be {@link GL_TEXTURE_LOD_BIAS}. When **target** is {@link GL_TEXTURE_ENV}, **pname** can be {@link GL_TEXTURE_ENV_MODE}, {@link GL_TEXTURE_ENV_COLOR}, {@link GL_COMBINE_RGB}, {@link GL_COMBINE_ALPHA}, {@link GL_RGB_SCALE}, {@link GL_ALPHA_SCALE}, {@link GL_SRC0_RGB}, {@link GL_SRC1_RGB}, {@link GL_SRC2_RGB}, {@link GL_SRC0_ALPHA}, {@link GL_SRC1_ALPHA}, or {@link GL_SRC2_ALPHA}.
 *
 * If **pname** is {@link GL_TEXTURE_ENV_MODE}, then **params** is (or points to) the symbolic name of a texture function. Six texture functions may be specified: {@link GL_ADD}, {@link GL_MODULATE}, {@link GL_DECAL}, {@link GL_BLEND}, {@link GL_REPLACE}, or {@link GL_COMBINE}.
 *
 * The following table shows the correspondence of filtered texture values 𝐑ₜ, 𝐆ₜ, 𝐁ₜ, 𝐀ₜ, 𝐋ₜ, 𝐈ₜ to texture source components. 𝐂ₛ and 𝐀ₛ are used by the texture functions described below.
 *
 * | **Texture Base Internal Format** | **𝐂ₛ**       | **𝐀ₛ** |
 * | :------------------------------- | :----------- | :----- |
 * | {@link GL_ALPHA}                 | (0, 0, 0)    | 𝐀ₜ     |
 * | {@link GL_LUMINANCE}             | (𝐋ₜ, 𝐋ₜ, 𝐋ₜ) | 1      |
 * | {@link GL_LUMINANCE_ALPHA}       | (𝐋ₜ, 𝐋ₜ, 𝐋ₜ) | 𝐀ₜ     |
 * | {@link GL_INTENSITY}             | (𝐈ₜ, 𝐈ₜ, 𝐈ₜ) | 𝐈ₜ     |
 * | {@link GL_RGB}                   | (𝐑ₜ, 𝐆ₜ, 𝐁ₜ) | 1      |
 * | {@link GL_RGBA}                  | (𝐑ₜ, 𝐆ₜ, 𝐁ₜ) | 𝐀ₜ     |
 *
 * A texture function acts on the fragment to be textured using the texture image value that applies to the fragment (see {@link glTexParameter}) and produces an RGBA color for that fragment. The following table shows how the RGBA color is produced for each of the first five texture functions that can be chosen. 𝐂 is a triple of color values (RGB) and 𝐀 is the associated alpha value. RGBA values extracted from a texture image are in the range [0,1]. The subscript 𝐩 refers to the color computed from the previous texture stage (or the incoming fragment if processing texture stage 0), the subscript 𝐬 to the texture source color, the subscript 𝐜 to the texture environment color, and the subscript 𝐯 indicates a value produced by the texture function.
 *
 * | **Texture Base Internal Format** | **Value** | **{@link GL_REPLACE} Function** | **{@link GL_MODULATE} Function** | **{@link GL_DECAL} Function** | **{@link GL_BLEND} Function** | **{@link GL_ADD} Function** |
 * | :------------------------------- | :-------- | :------------------------------ | :--------------------------- | :-------------------------------- | :---------------------------- | :-------------------------- |
 * | {@link GL_ALPHA}                 | Cᵥ =      | Cₚ                              | Cₚ                           | undefined                         | Cₚ                            | Cₚ                          |
 * |                                  | Aᵥ =      | Aₛ                              | AₚAₛ                         |                                   | Aᵥ = AₚAₛ                     | AₚAₛ                        |
 * | {@link GL_LUMINANCE}             | Cᵥ =      | Cₛ                              | CₚCₛ                         | undefined                         | Cₚ(1 − Cₛ) + C𝑐Cₛ             | Cₚ + Cₛ                     |
 * | (or 1)                           | Aᵥ =      | Aₚ                              | Aₚ                           |                                   | Aₚ                            | Aₚ                          |
 * | {@link GL_LUMINANCE_ALPHA}       | Cᵥ =      | Cₛ                              | CₚCₛ                         | undefined                         | Cₚ(1 − Cₛ) + C𝑐Cₛ             | Cₚ + Cₛ                     |
 * | (or 2)                           | Aᵥ =      | Aₛ                              | AₚAₛ                         |                                   | AₚAₛ                          | AₚAₛ                        |
 * | {@link GL_INTENSITY}             | Cᵥ =      | Cₛ                              | CₚCₛ                         | undefined                         | Cₚ(1 − Cₛ) + C𝑐Cₛ             | Cₚ + Cₛ                     |
 * |								  | Aᵥ =      | Aₛ                              | AₚAₛ                         |                                   | Aₚ(1 − Aₛ) + A𝑐Aₛ             | Aₚ + Aₛ                     |
 * | {@link GL_RGB}                   | Cᵥ =      | Cₛ                              | CₚCₛ                         | Cₛ                                | Cₚ(1 − Cₛ) + C𝑐Cₛ             | Cₚ + Cₛ                     |
 * | (or 3)                           | Aᵥ =      | Aₚ                              | Aₚ                           | Aₚ                                | Aₚ                            | Aₚ                          |
 * | {@link GL_RGBA}                  | Cᵥ =      | Cₛ                              | CₚCₛ                         | Cₚ(1 − Aₛ) + CₛAₛ                 | Cₚ(1 − Cₛ) + C𝑐Cₛ             | Cₚ + Cₛ                     |
 * | (or 4)                           | Aᵥ =      | Aₛ                              | AₚAₛ                         | Aₚ                                | AₚAₛ                          | AₚAₛ                        |
 *
 * If **pname** is {@link GL_TEXTURE_ENV_MODE}, and **params** is {@link GL_COMBINE}, the form of the texture function depends on the values of {@link GL_COMBINE_RGB} and {@link GL_COMBINE_ALPHA}.
 *
 * The following describes how the texture sources, as specified by {@link GL_SRC0_RGB}, {@link GL_SRC1_RGB}, {@link GL_SRC2_RGB}, {@link GL_SRC0_ALPHA}, {@link GL_SRC1_ALPHA}, and {@link GL_SRC2_ALPHA}, are combined to produce a final texture color. In the following tables, {@link GL_SRC0_c} is represented by *Arg0*, {@link GL_SRC1_c} is represented by *Arg1*, and {@link GL_SRC2_c} is represented by *Arg2*.
 *
 * {@link GL_COMBINE_RGB} accepts any of {@link GL_REPLACE}, {@link GL_MODULATE}, {@link GL_ADD}, {@link GL_ADD_SIGNED}, {@link GL_INTERPOLATE}, {@link GL_SUBTRACT}, {@link GL_DOT3_RGB}, or {@link GL_DOT3_RGBA}.
 *
 * | {@link GL_COMBINE_RGB}                | **Texture Function**                                                                                      |
 * | :------------------------------------------ | :-------------------------------------------------------------------------------------------------------- |
 * | {@link GL_REPLACE}                          | Arg0                                                                                                      |
 * | {@link GL_MODULATE}                         | Arg0 × Arg1                                                                                               |
 * | {@link GL_ADD}                              | Arg0 + Arg1                                                                                               |
 * | {@link GL_ADD_SIGNED}                       | Arg0 + Arg1 − 0.5                                                                                         |
 * | {@link GL_INTERPOLATE}                      | Arg0 × Arg2 + Arg1 × (1 − Arg2)                                                                           |
 * | {@link GL_SUBTRACT}                         | Arg0 − Arg1                                                                                               |
 * | {@link GL_DOT3_RGB} or {@link GL_DOT3_RGBA} | 4 × (((Arg0ᵣ − 0.5) × (Arg1ᵣ − 0.5)) + ((Arg0𝑔 − 0.5) × (Arg1𝑔 − 0.5)) + ((Arg0𝑏 − 0.5) × (Arg1𝑏 − 0.5))) |
 *
 * The scalar results for {@link GL_DOT3_RGB} and {@link GL_DOT3_RGBA} are placed into each of the 3 (RGB) or 4 (RGBA) components on output.
 *
 * Likewise, {@link GL_COMBINE_ALPHA} accepts any of {@link GL_REPLACE}, {@link GL_MODULATE}, {@link GL_ADD}, {@link GL_ADD_SIGNED}, {@link GL_INTERPOLATE}, or {@link GL_SUBTRACT}. The following table describes how alpha values are combined:
 *
 * | {@link GL_COMBINE_ALPHA} | **Texture Function**            |
 * | :----------------------- | :------------------------------ |
 * | {@link GL_REPLACE}       | Arg0                            |
 * | {@link GL_MODULATE}      | Arg0 × Arg1                     |
 * | {@link GL_ADD}           | Arg0 + Arg1                     |
 * | {@link GL_ADD_SIGNED}    | Arg0 + Arg1 − 0.5               |
 * | {@link GL_INTERPOLATE}   | Arg0 × Arg2 + Arg1 × (1 − Arg2) |
 * | {@link GL_SUBTRACT}      | Arg0 − Arg1                     |
 *
 * In the following tables, the value Cₛ represents the color sampled from the currently bound texture, C𝑐 represents the constant texture-environment color, C𝑓 represents the primary color of the incoming fragment, and Cₚ represents the color computed from the previous texture stage or C𝑓 if processing texture stage 0. Likewise, Aₛ, A𝑐 A𝑓 and Aₚ represent the respective alpha values.
 *
 * The following table describes the values assigned to *Arg0*, *Arg1* and *Arg2* based upon the RGB sources and operands:
 *
 * | {@link GL_SRCn_RGB}      | {@link GL_OPERANDn_RGB}        | Argument Value |
 * | :----------------------- | :----------------------------- | :------------- |
 * | {@link GL_TEXTURE}       | {@link GL_SRC_COLOR}           | Cₛ			    |
 * |                          | {@link GL_ONE_MINUS_SRC_COLOR} | 1 − Cₛ         |
 * |                          | {@link GL_SRC_ALPHA}           | Aₛ             |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − Aₛ         |
 * | {@link GL_TEXTUREn}      | {@link GL_SRC_COLOR}           | Cₛ             |
 * |                          | {@link GL_ONE_MINUS_SRC_COLOR} | 1 − Cₛ         |
 * |                          | {@link GL_SRC_ALPHA}           | Aₛ             |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − Aₛ         |
 * | {@link GL_CONSTANT}      | {@link GL_SRC_COLOR}           | C𝑐             |
 * |                          | {@link GL_ONE_MINUS_SRC_COLOR} | 1 − C𝑐         |
 * |                          | {@link GL_SRC_ALPHA}           | A𝑐             |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − A𝑐         |
 * | {@link GL_PRIMARY_COLOR} | {@link GL_SRC_COLOR}           | C𝑓             |
 * |                          | {@link GL_ONE_MINUS_SRC_COLOR} | 1 − C𝑓         |
 * |                          | {@link GL_SRC_ALPHA}           | A𝑓             |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − A𝑓         |
 * | {@link GL_PREVIOUS}      | {@link GL_SRC_COLOR}           | Cₚ             |
 * |                          | {@link GL_ONE_MINUS_SRC_COLOR} | 1 − Cₚ         |
 * |                          | {@link GL_SRC_ALPHA}           | Aₚ             |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − Aₚ         |
 *
 * For {@link GL_TEXTUREn} sources, Cₛ and Aₛ represent the color and alpha, respectively, produced from texture stage 𝐧.
 *
 * The follow table describes the values assigned to *Arg0*, *Arg1*, and *Arg2* based upon the alpha sources and operands:
 *
 * | {@link GL_SRCn_ALPHA}    | {@link GL_OPERANDn_ALPHA}      | **Argument Value** |
 * | :----------------------- | :----------------------------- | :----------------- |
 * | {@link GL_TEXTURE}       | {@link GL_SRC_ALPHA}           | Aₛ                 |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − Aₛ             |
 * | {@link GL_TEXTUREn}      | {@link GL_SRC_ALPHA}           | Aₛ                 |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − Aₛ             |
 * | {@link GL_CONSTANT}      | {@link GL_SRC_ALPHA}           | A𝑐                 |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − A𝑐             |
 * | {@link GL_PRIMARY_COLOR} | {@link GL_SRC_ALPHA}           | A𝑓                 |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − A𝑓             |
 * | {@link GL_PREVIOUS}      | {@link GL_SRC_ALPHA}           | Aₚ                 |
 * |                          | {@link GL_ONE_MINUS_SRC_ALPHA} | 1 − Aₚ             |
 *
 * The RGB and alpha results of the texture function are multipled by the values of {@link GL_RGB_SCALE} and {@link GL_ALPHA_SCALE}, respectively, and clamped to the range [0,1].
 *
 * If **pname** is {@link GL_TEXTURE_ENV_COLOR}, **params** is a pointer to an array that holds an RGBA color consisting of four values. Integer color components are interpreted linearly such that the most positive integer maps to 1.0, and the most negative integer maps to -1.0. The values are clamped to the range [0,1] when they are specified. C𝑐 takes these four values.
 *
 * If **pname** is {@link GL_TEXTURE_LOD_BIAS}, the value specified is added to the texture level-of-detail parameter, that selects which mipmap, or mipmaps depending upon the selected {@link GL_TEXTURE_MIN_FILTER}, will be sampled.
 *
 * {@link GL_TEXTURE_ENV_MODE} defaults to {@link GL_MODULATE} and {@link GL_TEXTURE_ENV_COLOR} defaults to (0, 0, 0, 0).
 *
 * If **target** is {@link GL_POINT_SPRITE} and **pname** is {@link GL_COORD_REPLACE}, the boolean value specified is used to either enable or disable point sprite texture coordinate replacement. The default value is {@link GL_FALSE}.
 *
 * @summary set texture environment parameters
 * @param target Specifies a texture environment. May be either {@link GL_TEXTURE_ENV}, or {@link GL_TEXTURE_FILTER_CONTROL}.
 * @param pname Specifies the symbolic name of a texture environment parameter. Accepted values are {@link GL_TEXTURE_ENV_MODE}, {@link GL_TEXTURE_ENV_COLOR}, or {@link GL_TEXTURE_LOD_BIAS}.
 * @param params Specifies a pointer to a parameter array that contains either a single symbolic constant, single floating-point number, or an RGBA color.
 * @see [glTexEnv](https://docs.gl/gl3/glTexEnv)
 */
export function glTexEnviv(target: GLenum, pname: GLenum, params: GLint): void;

/**
 * `glTexGen` selects a texture-coordinate generation function or supplies coefficients for one of the functions. **coord** names one of the (**s**, **t**, **r**, **q**) texture coordinates; it must be one of the symbols {@link GL_S}, {@link GL_T}, {@link GL_R}, or {@link GL_Q}. **pname** must be one of three symbolic constants: {@link GL_TEXTURE_GEN_MODE}, {@link GL_OBJECT_PLANE}, or {@link GL_EYE_PLANE}. If **pname** is {@link GL_TEXTURE_GEN_MODE}, then **params** chooses a mode, one of {@link GL_OBJECT_LINEAR}, {@link GL_EYE_LINEAR}, {@link GL_SPHERE_MAP}, {@link GL_NORMAL_MAP}, or {@link GL_REFLECTION_MAP}. If **pname** is either {@link GL_OBJECT_PLANE} or {@link GL_EYE_PLANE}, **params** contains coefficients for the corresponding texture generation function.
 *
 * If the texture generation function is {@link GL_OBJECT_LINEAR}, the function
 *
 * 𝐠 = 𝐩₁ × 𝐱ₒ + 𝐩₂ × 𝐲ₒ + 𝐩₃ × 𝐳ₒ + 𝐩₄ × 𝐰ₒ
 *
 * is used, where 𝐠 is the value computed for the coordinate named in **coord**, 𝐩₁, 𝐩₂, 𝐩₃, and 𝐩₄ are the four values supplied in **params**, and 𝐱ₒ, 𝐲ₒ, 𝐳ₒ, and 𝐰ₒ are the object coordinates of the vertex. This function can be used, for example, to texture-map terrain using sea level as a reference plane (defined by 𝐩₁, 𝐩₂, 𝐩₃, and 𝐩₄). The altitude of a terrain vertex is computed by the {@link GL_OBJECT_LINEAR} coordinate generation function as its distance from sea level; that altitude can then be used to index the texture image to map white snow onto peaks and green grass onto foothills.
 *
 * If the texture generation function is {@link GL_EYE_LINEAR}, the function
 *
 * 𝐠 = 𝐩₁′′ × 𝐱ₑ + 𝐩₂′′ × 𝐲ₑ + 𝐩₃′′ × 𝐳ₑ + 𝐩₄′′ × 𝐰ₑ
 *
 *  is used, where
 *
 * (𝐩₁′′𝐩₂′′𝐩₃′′𝐩₄′′) = (𝐩₁𝐩₂𝐩₃𝐩₄)ᴹ^⁻¹
 *
 * and 𝐱ₑ, 𝐲ₑ, 𝐳ₑ, and 𝐰ₑ are the eye coordinates of the vertex, 𝐩₁, 𝐩₂, 𝐩₃, and 𝐩₄ are the values supplied in **params**, and 𝐌 is the modelview matrix when `glTexGen` is invoked. If 𝐌 is poorly conditioned or singular, texture coordinates generated by the resulting function may be inaccurate or undefined.
 *
 * Note that the values in **params** define a reference plane in eye coordinates. The modelview matrix that is applied to them may not be the same one in effect when the polygon vertices are transformed. This function establishes a field of texture coordinates that can produce dynamic contour lines on moving objects.
 *
 * If the texture generation function is {@link GL_SPHERE_MAP} and **coord** is either {@link GL_S} or {@link GL_T}, 𝐬 and 𝐭 texture coordinates are generated as follows. Let **u** be the unit vector pointing from the origin to the polygon vertex (in eye coordinates). Let **n** sup prime be the current normal, after transformation to eye coordinates. Let
 *
 * 𝐟 = (𝐟ₓ𝐟ᵧ𝐟𝑧)ᵀ be the reflection vector such that
 *
 * 𝐟 = 𝐮 - 2𝐧′′𝐧′′ᵀ𝐮
 *
 * Finally, let 𝐦 = 2√(𝐟ₓ² + 𝐟ᵧ² + (𝐟𝑧 + 1)²). Then the values assigned to the 𝐬 and 𝐭 texture coordinates are
 *
 * 𝐬 = 𝐟ₓ / 𝐦 + 1 / 2
 *
 * 𝐭 = 𝐟ᵧ / 𝐦 + 1 / 2
 *
 * To enable or disable a texture-coordinate generation function, call {@link glEnable} or {@link glDisable} with one of the symbolic texture-coordinate names ({@link GL_TEXTURE_GEN_S}, {@link GL_TEXTURE_GEN_T}, {@link GL_TEXTURE_GEN_R}, or {@link GL_TEXTURE_GEN_Q}) as the argument. When enabled, the specified texture coordinate is computed according to the generating function associated with that coordinate. When disabled, subsequent vertices take the specified texture coordinate from the current set of texture coordinates. Initially, all texture generation functions are set to {@link GL_EYE_LINEAR} and are disabled. Both 𝐬 plane equations are (1, 0, 0, 0), both 𝐭 plane equations are (0, 1, 0, 0), and all 𝐫 and 𝐪 plane equations are (0, 0, 0, 0).
 *
 * When the ARB_multitexture extension is supported, `glTexGen` sets the texture generation parameters for the currently active texture unit, selected with {@link glActiveTexture}.
 *
 * @summary control the generation of texture coordinates
 * @param coord Specifies a texture coordinate. Must be one of {@link GL_S}, {@link GL_T}, {@link GL_R}, or {@link GL_Q}.
 * @param pname Specifies the symbolic name of the texture-coordinate generation function. Must be {@link GL_TEXTURE_GEN_MODE}.
 * @param param Specifies a single-valued texture generation parameter, one of {@link GL_OBJECT_LINEAR}, {@link GL_EYE_LINEAR}, {@link GL_SPHERE_MAP}, {@link GL_NORMAL_MAP}, or {@link GL_REFLECTION_MAP}.
 * @see [glTexGen](https://docs.gl/gl3/glTexGen)
 */
export function glTexGend(coord: GLenum, pname: GLenum, param: GLdouble): void;

/**
 * `glTexGen` selects a texture-coordinate generation function or supplies coefficients for one of the functions. **coord** names one of the (**s**, **t**, **r**, **q**) texture coordinates; it must be one of the symbols {@link GL_S}, {@link GL_T}, {@link GL_R}, or {@link GL_Q}. **pname** must be one of three symbolic constants: {@link GL_TEXTURE_GEN_MODE}, {@link GL_OBJECT_PLANE}, or {@link GL_EYE_PLANE}. If **pname** is {@link GL_TEXTURE_GEN_MODE}, then **params** chooses a mode, one of {@link GL_OBJECT_LINEAR}, {@link GL_EYE_LINEAR}, {@link GL_SPHERE_MAP}, {@link GL_NORMAL_MAP}, or {@link GL_REFLECTION_MAP}. If **pname** is either {@link GL_OBJECT_PLANE} or {@link GL_EYE_PLANE}, **params** contains coefficients for the corresponding texture generation function.
 *
 * If the texture generation function is {@link GL_OBJECT_LINEAR}, the function
 *
 * 𝐠 = 𝐩₁ × 𝐱ₒ + 𝐩₂ × 𝐲ₒ + 𝐩₃ × 𝐳ₒ + 𝐩₄ × 𝐰ₒ
 *
 * is used, where 𝐠 is the value computed for the coordinate named in **coord**, 𝐩₁, 𝐩₂, 𝐩₃, and 𝐩₄ are the four values supplied in **params**, and 𝐱ₒ, 𝐲ₒ, 𝐳ₒ, and 𝐰ₒ are the object coordinates of the vertex. This function can be used, for example, to texture-map terrain using sea level as a reference plane (defined by 𝐩₁, 𝐩₂, 𝐩₃, and 𝐩₄). The altitude of a terrain vertex is computed by the {@link GL_OBJECT_LINEAR} coordinate generation function as its distance from sea level; that altitude can then be used to index the texture image to map white snow onto peaks and green grass onto foothills.
 *
 * If the texture generation function is {@link GL_EYE_LINEAR}, the function
 *
 * 𝐠 = 𝐩₁′′ × 𝐱ₑ + 𝐩₂′′ × 𝐲ₑ + 𝐩₃′′ × 𝐳ₑ + 𝐩₄′′ × 𝐰ₑ
 *
 *  is used, where
 *
 * (𝐩₁′′𝐩₂′′𝐩₃′′𝐩₄′′) = (𝐩₁𝐩₂𝐩₃𝐩₄)ᴹ^⁻¹
 *
 * and 𝐱ₑ, 𝐲ₑ, 𝐳ₑ, and 𝐰ₑ are the eye coordinates of the vertex, 𝐩₁, 𝐩₂, 𝐩₃, and 𝐩₄ are the values supplied in **params**, and 𝐌 is the modelview matrix when `glTexGen` is invoked. If 𝐌 is poorly conditioned or singular, texture coordinates generated by the resulting function may be inaccurate or undefined.
 *
 * Note that the values in **params** define a reference plane in eye coordinates. The modelview matrix that is applied to them may not be the same one in effect when the polygon vertices are transformed. This function establishes a field of texture coordinates that can produce dynamic contour lines on moving objects.
 *
 * If the texture generation function is {@link GL_SPHERE_MAP} and **coord** is either {@link GL_S} or {@link GL_T}, 𝐬 and 𝐭 texture coordinates are generated as follows. Let **u** be the unit vector pointing from the origin to the polygon vertex (in eye coordinates). Let **n** sup prime be the current normal, after transformation to eye coordinates. Let
 *
 * 𝐟 = (𝐟ₓ𝐟ᵧ𝐟𝑧)ᵀ be the reflection vector such that
 *
 * 𝐟 = 𝐮 - 2𝐧′′𝐧′′ᵀ𝐮
 *
 * Finally, let 𝐦 = 2√(𝐟ₓ² + 𝐟ᵧ² + (𝐟𝑧 + 1)²). Then the values assigned to the 𝐬 and 𝐭 texture coordinates are
 *
 * 𝐬 = 𝐟ₓ / 𝐦 + 1 / 2
 *
 * 𝐭 = 𝐟ᵧ / 𝐦 + 1 / 2
 *
 * To enable or disable a texture-coordinate generation function, call {@link glEnable} or {@link glDisable} with one of the symbolic texture-coordinate names ({@link GL_TEXTURE_GEN_S}, {@link GL_TEXTURE_GEN_T}, {@link GL_TEXTURE_GEN_R}, or {@link GL_TEXTURE_GEN_Q}) as the argument. When enabled, the specified texture coordinate is computed according to the generating function associated with that coordinate. When disabled, subsequent vertices take the specified texture coordinate from the current set of texture coordinates. Initially, all texture generation functions are set to {@link GL_EYE_LINEAR} and are disabled. Both 𝐬 plane equations are (1, 0, 0, 0), both 𝐭 plane equations are (0, 1, 0, 0), and all 𝐫 and 𝐪 plane equations are (0, 0, 0, 0).
 *
 * When the ARB_multitexture extension is supported, `glTexGen` sets the texture generation parameters for the currently active texture unit, selected with {@link glActiveTexture}.
 *
 * @summary control the generation of texture coordinates
 * @param coord Specifies a texture coordinate. Must be one of {@link GL_S}, {@link GL_T}, {@link GL_R}, or {@link GL_Q}.
 * @param pname Specifies the symbolic name of the texture-coordinate generation function. Must be {@link GL_TEXTURE_GEN_MODE}.
 * @param param Specifies a single-valued texture generation parameter, one of {@link GL_OBJECT_LINEAR}, {@link GL_EYE_LINEAR}, {@link GL_SPHERE_MAP}, {@link GL_NORMAL_MAP}, or {@link GL_REFLECTION_MAP}.
 * @see [glTexGen](https://docs.gl/gl3/glTexGen)
 */
export function glTexGenf(coord: GLenum, pname: GLenum, param: GLfloat): void;

/**
 * `glTexGen` selects a texture-coordinate generation function or supplies coefficients for one of the functions. **coord** names one of the (**s**, **t**, **r**, **q**) texture coordinates; it must be one of the symbols {@link GL_S}, {@link GL_T}, {@link GL_R}, or {@link GL_Q}. **pname** must be one of three symbolic constants: {@link GL_TEXTURE_GEN_MODE}, {@link GL_OBJECT_PLANE}, or {@link GL_EYE_PLANE}. If **pname** is {@link GL_TEXTURE_GEN_MODE}, then **params** chooses a mode, one of {@link GL_OBJECT_LINEAR}, {@link GL_EYE_LINEAR}, {@link GL_SPHERE_MAP}, {@link GL_NORMAL_MAP}, or {@link GL_REFLECTION_MAP}. If **pname** is either {@link GL_OBJECT_PLANE} or {@link GL_EYE_PLANE}, **params** contains coefficients for the corresponding texture generation function.
 *
 * If the texture generation function is {@link GL_OBJECT_LINEAR}, the function
 *
 * 𝐠 = 𝐩₁ × 𝐱ₒ + 𝐩₂ × 𝐲ₒ + 𝐩₃ × 𝐳ₒ + 𝐩₄ × 𝐰ₒ
 *
 * is used, where 𝐠 is the value computed for the coordinate named in **coord**, 𝐩₁, 𝐩₂, 𝐩₃, and 𝐩₄ are the four values supplied in **params**, and 𝐱ₒ, 𝐲ₒ, 𝐳ₒ, and 𝐰ₒ are the object coordinates of the vertex. This function can be used, for example, to texture-map terrain using sea level as a reference plane (defined by 𝐩₁, 𝐩₂, 𝐩₃, and 𝐩₄). The altitude of a terrain vertex is computed by the {@link GL_OBJECT_LINEAR} coordinate generation function as its distance from sea level; that altitude can then be used to index the texture image to map white snow onto peaks and green grass onto foothills.
 *
 * If the texture generation function is {@link GL_EYE_LINEAR}, the function
 *
 * 𝐠 = 𝐩₁′′ × 𝐱ₑ + 𝐩₂′′ × 𝐲ₑ + 𝐩₃′′ × 𝐳ₑ + 𝐩₄′′ × 𝐰ₑ
 *
 *  is used, where
 *
 * (𝐩₁′′𝐩₂′′𝐩₃′′𝐩₄′′) = (𝐩₁𝐩₂𝐩₃𝐩₄)ᴹ^⁻¹
 *
 * and 𝐱ₑ, 𝐲ₑ, 𝐳ₑ, and 𝐰ₑ are the eye coordinates of the vertex, 𝐩₁, 𝐩₂, 𝐩₃, and 𝐩₄ are the values supplied in **params**, and 𝐌 is the modelview matrix when `glTexGen` is invoked. If 𝐌 is poorly conditioned or singular, texture coordinates generated by the resulting function may be inaccurate or undefined.
 *
 * Note that the values in **params** define a reference plane in eye coordinates. The modelview matrix that is applied to them may not be the same one in effect when the polygon vertices are transformed. This function establishes a field of texture coordinates that can produce dynamic contour lines on moving objects.
 *
 * If the texture generation function is {@link GL_SPHERE_MAP} and **coord** is either {@link GL_S} or {@link GL_T}, 𝐬 and 𝐭 texture coordinates are generated as follows. Let **u** be the unit vector pointing from the origin to the polygon vertex (in eye coordinates). Let **n** sup prime be the current normal, after transformation to eye coordinates. Let
 *
 * 𝐟 = (𝐟ₓ𝐟ᵧ𝐟𝑧)ᵀ be the reflection vector such that
 *
 * 𝐟 = 𝐮 - 2𝐧′′𝐧′′ᵀ𝐮
 *
 * Finally, let 𝐦 = 2√(𝐟ₓ² + 𝐟ᵧ² + (𝐟𝑧 + 1)²). Then the values assigned to the 𝐬 and 𝐭 texture coordinates are
 *
 * 𝐬 = 𝐟ₓ / 𝐦 + 1 / 2
 *
 * 𝐭 = 𝐟ᵧ / 𝐦 + 1 / 2
 *
 * To enable or disable a texture-coordinate generation function, call {@link glEnable} or {@link glDisable} with one of the symbolic texture-coordinate names ({@link GL_TEXTURE_GEN_S}, {@link GL_TEXTURE_GEN_T}, {@link GL_TEXTURE_GEN_R}, or {@link GL_TEXTURE_GEN_Q}) as the argument. When enabled, the specified texture coordinate is computed according to the generating function associated with that coordinate. When disabled, subsequent vertices take the specified texture coordinate from the current set of texture coordinates. Initially, all texture generation functions are set to {@link GL_EYE_LINEAR} and are disabled. Both 𝐬 plane equations are (1, 0, 0, 0), both 𝐭 plane equations are (0, 1, 0, 0), and all 𝐫 and 𝐪 plane equations are (0, 0, 0, 0).
 *
 * When the ARB_multitexture extension is supported, `glTexGen` sets the texture generation parameters for the currently active texture unit, selected with {@link glActiveTexture}.
 *
 * @summary control the generation of texture coordinates
 * @param coord Specifies a texture coordinate. Must be one of {@link GL_S}, {@link GL_T}, {@link GL_R}, or {@link GL_Q}.
 * @param pname Specifies the symbolic name of the texture-coordinate generation function. Must be {@link GL_TEXTURE_GEN_MODE}.
 * @param param Specifies a single-valued texture generation parameter, one of {@link GL_OBJECT_LINEAR}, {@link GL_EYE_LINEAR}, {@link GL_SPHERE_MAP}, {@link GL_NORMAL_MAP}, or {@link GL_REFLECTION_MAP}.
 * @see [glTexGen](https://docs.gl/gl3/glTexGen)
 */
export function glTexGeni(coord: GLenum, pname: GLenum, param: GLint): void;

/**
 * `glTexGen` selects a texture-coordinate generation function or supplies coefficients for one of the functions. **coord** names one of the (**s**, **t**, **r**, **q**) texture coordinates; it must be one of the symbols {@link GL_S}, {@link GL_T}, {@link GL_R}, or {@link GL_Q}. **pname** must be one of three symbolic constants: {@link GL_TEXTURE_GEN_MODE}, {@link GL_OBJECT_PLANE}, or {@link GL_EYE_PLANE}. If **pname** is {@link GL_TEXTURE_GEN_MODE}, then **params** chooses a mode, one of {@link GL_OBJECT_LINEAR}, {@link GL_EYE_LINEAR}, {@link GL_SPHERE_MAP}, {@link GL_NORMAL_MAP}, or {@link GL_REFLECTION_MAP}. If **pname** is either {@link GL_OBJECT_PLANE} or {@link GL_EYE_PLANE}, **params** contains coefficients for the corresponding texture generation function.
 *
 * If the texture generation function is {@link GL_OBJECT_LINEAR}, the function
 *
 * 𝐠 = 𝐩₁ × 𝐱ₒ + 𝐩₂ × 𝐲ₒ + 𝐩₃ × 𝐳ₒ + 𝐩₄ × 𝐰ₒ
 *
 * is used, where 𝐠 is the value computed for the coordinate named in **coord**, 𝐩₁, 𝐩₂, 𝐩₃, and 𝐩₄ are the four values supplied in **params**, and 𝐱ₒ, 𝐲ₒ, 𝐳ₒ, and 𝐰ₒ are the object coordinates of the vertex. This function can be used, for example, to texture-map terrain using sea level as a reference plane (defined by 𝐩₁, 𝐩₂, 𝐩₃, and 𝐩₄). The altitude of a terrain vertex is computed by the {@link GL_OBJECT_LINEAR} coordinate generation function as its distance from sea level; that altitude can then be used to index the texture image to map white snow onto peaks and green grass onto foothills.
 *
 * If the texture generation function is {@link GL_EYE_LINEAR}, the function
 *
 * 𝐠 = 𝐩₁′′ × 𝐱ₑ + 𝐩₂′′ × 𝐲ₑ + 𝐩₃′′ × 𝐳ₑ + 𝐩₄′′ × 𝐰ₑ
 *
 *  is used, where
 *
 * (𝐩₁′′𝐩₂′′𝐩₃′′𝐩₄′′) = (𝐩₁𝐩₂𝐩₃𝐩₄)ᴹ^⁻¹
 *
 * and 𝐱ₑ, 𝐲ₑ, 𝐳ₑ, and 𝐰ₑ are the eye coordinates of the vertex, 𝐩₁, 𝐩₂, 𝐩₃, and 𝐩₄ are the values supplied in **params**, and 𝐌 is the modelview matrix when `glTexGen` is invoked. If 𝐌 is poorly conditioned or singular, texture coordinates generated by the resulting function may be inaccurate or undefined.
 *
 * Note that the values in **params** define a reference plane in eye coordinates. The modelview matrix that is applied to them may not be the same one in effect when the polygon vertices are transformed. This function establishes a field of texture coordinates that can produce dynamic contour lines on moving objects.
 *
 * If the texture generation function is {@link GL_SPHERE_MAP} and **coord** is either {@link GL_S} or {@link GL_T}, 𝐬 and 𝐭 texture coordinates are generated as follows. Let **u** be the unit vector pointing from the origin to the polygon vertex (in eye coordinates). Let **n** sup prime be the current normal, after transformation to eye coordinates. Let
 *
 * 𝐟 = (𝐟ₓ𝐟ᵧ𝐟𝑧)ᵀ be the reflection vector such that
 *
 * 𝐟 = 𝐮 - 2𝐧′′𝐧′′ᵀ𝐮
 *
 * Finally, let 𝐦 = 2√(𝐟ₓ² + 𝐟ᵧ² + (𝐟𝑧 + 1)²). Then the values assigned to the 𝐬 and 𝐭 texture coordinates are
 *
 * 𝐬 = 𝐟ₓ / 𝐦 + 1 / 2
 *
 * 𝐭 = 𝐟ᵧ / 𝐦 + 1 / 2
 *
 * To enable or disable a texture-coordinate generation function, call {@link glEnable} or {@link glDisable} with one of the symbolic texture-coordinate names ({@link GL_TEXTURE_GEN_S}, {@link GL_TEXTURE_GEN_T}, {@link GL_TEXTURE_GEN_R}, or {@link GL_TEXTURE_GEN_Q}) as the argument. When enabled, the specified texture coordinate is computed according to the generating function associated with that coordinate. When disabled, subsequent vertices take the specified texture coordinate from the current set of texture coordinates. Initially, all texture generation functions are set to {@link GL_EYE_LINEAR} and are disabled. Both 𝐬 plane equations are (1, 0, 0, 0), both 𝐭 plane equations are (0, 1, 0, 0), and all 𝐫 and 𝐪 plane equations are (0, 0, 0, 0).
 *
 * When the ARB_multitexture extension is supported, `glTexGen` sets the texture generation parameters for the currently active texture unit, selected with {@link glActiveTexture}.
 *
 * @summary control the generation of texture coordinates
 * @param coord Specifies a texture coordinate. Must be one of {@link GL_S}, {@link GL_T}, {@link GL_R}, or {@link GL_Q}.
 * @param pname Specifies the symbolic name of the texture-coordinate generation function or function parameters. Must be {@link GL_TEXTURE_GEN_MODE}, {@link GL_OBJECT_PLANE}, or {@link GL_EYE_PLANE}.
 * @param params Specifies a pointer to an array of texture generation parameters. If **pname** is {@link GL_TEXTURE_GEN_MODE}, then the array must contain a single symbolic constant, one of {@link GL_OBJECT_LINEAR}, {@link GL_EYE_LINEAR}, {@link GL_SPHERE_MAP}, {@link GL_NORMAL_MAP}, or {@link GL_REFLECTION_MAP}. Otherwise, **params** holds the coefficients for the texture-coordinate generation function specified by **pname**.
 * @see [glTexGen](https://docs.gl/gl3/glTexGen)
 */
export function glTexGendv(
	coord: GLenum,
	pname: GLenum,
	params: GLdouble
): void;

/**
 * `glTexGen` selects a texture-coordinate generation function or supplies coefficients for one of the functions. **coord** names one of the (**s**, **t**, **r**, **q**) texture coordinates; it must be one of the symbols {@link GL_S}, {@link GL_T}, {@link GL_R}, or {@link GL_Q}. **pname** must be one of three symbolic constants: {@link GL_TEXTURE_GEN_MODE}, {@link GL_OBJECT_PLANE}, or {@link GL_EYE_PLANE}. If **pname** is {@link GL_TEXTURE_GEN_MODE}, then **params** chooses a mode, one of {@link GL_OBJECT_LINEAR}, {@link GL_EYE_LINEAR}, {@link GL_SPHERE_MAP}, {@link GL_NORMAL_MAP}, or {@link GL_REFLECTION_MAP}. If **pname** is either {@link GL_OBJECT_PLANE} or {@link GL_EYE_PLANE}, **params** contains coefficients for the corresponding texture generation function.
 *
 * If the texture generation function is {@link GL_OBJECT_LINEAR}, the function
 *
 * 𝐠 = 𝐩₁ × 𝐱ₒ + 𝐩₂ × 𝐲ₒ + 𝐩₃ × 𝐳ₒ + 𝐩₄ × 𝐰ₒ
 *
 * is used, where 𝐠 is the value computed for the coordinate named in **coord**, 𝐩₁, 𝐩₂, 𝐩₃, and 𝐩₄ are the four values supplied in **params**, and 𝐱ₒ, 𝐲ₒ, 𝐳ₒ, and 𝐰ₒ are the object coordinates of the vertex. This function can be used, for example, to texture-map terrain using sea level as a reference plane (defined by 𝐩₁, 𝐩₂, 𝐩₃, and 𝐩₄). The altitude of a terrain vertex is computed by the {@link GL_OBJECT_LINEAR} coordinate generation function as its distance from sea level; that altitude can then be used to index the texture image to map white snow onto peaks and green grass onto foothills.
 *
 * If the texture generation function is {@link GL_EYE_LINEAR}, the function
 *
 * 𝐠 = 𝐩₁′′ × 𝐱ₑ + 𝐩₂′′ × 𝐲ₑ + 𝐩₃′′ × 𝐳ₑ + 𝐩₄′′ × 𝐰ₑ
 *
 *  is used, where
 *
 * (𝐩₁′′𝐩₂′′𝐩₃′′𝐩₄′′) = (𝐩₁𝐩₂𝐩₃𝐩₄)ᴹ^⁻¹
 *
 * and 𝐱ₑ, 𝐲ₑ, 𝐳ₑ, and 𝐰ₑ are the eye coordinates of the vertex, 𝐩₁, 𝐩₂, 𝐩₃, and 𝐩₄ are the values supplied in **params**, and 𝐌 is the modelview matrix when `glTexGen` is invoked. If 𝐌 is poorly conditioned or singular, texture coordinates generated by the resulting function may be inaccurate or undefined.
 *
 * Note that the values in **params** define a reference plane in eye coordinates. The modelview matrix that is applied to them may not be the same one in effect when the polygon vertices are transformed. This function establishes a field of texture coordinates that can produce dynamic contour lines on moving objects.
 *
 * If the texture generation function is {@link GL_SPHERE_MAP} and **coord** is either {@link GL_S} or {@link GL_T}, 𝐬 and 𝐭 texture coordinates are generated as follows. Let **u** be the unit vector pointing from the origin to the polygon vertex (in eye coordinates). Let **n** sup prime be the current normal, after transformation to eye coordinates. Let
 *
 * 𝐟 = (𝐟ₓ𝐟ᵧ𝐟𝑧)ᵀ be the reflection vector such that
 *
 * 𝐟 = 𝐮 - 2𝐧′′𝐧′′ᵀ𝐮
 *
 * Finally, let 𝐦 = 2√(𝐟ₓ² + 𝐟ᵧ² + (𝐟𝑧 + 1)²). Then the values assigned to the 𝐬 and 𝐭 texture coordinates are
 *
 * 𝐬 = 𝐟ₓ / 𝐦 + 1 / 2
 *
 * 𝐭 = 𝐟ᵧ / 𝐦 + 1 / 2
 *
 * To enable or disable a texture-coordinate generation function, call {@link glEnable} or {@link glDisable} with one of the symbolic texture-coordinate names ({@link GL_TEXTURE_GEN_S}, {@link GL_TEXTURE_GEN_T}, {@link GL_TEXTURE_GEN_R}, or {@link GL_TEXTURE_GEN_Q}) as the argument. When enabled, the specified texture coordinate is computed according to the generating function associated with that coordinate. When disabled, subsequent vertices take the specified texture coordinate from the current set of texture coordinates. Initially, all texture generation functions are set to {@link GL_EYE_LINEAR} and are disabled. Both 𝐬 plane equations are (1, 0, 0, 0), both 𝐭 plane equations are (0, 1, 0, 0), and all 𝐫 and 𝐪 plane equations are (0, 0, 0, 0).
 *
 * When the ARB_multitexture extension is supported, `glTexGen` sets the texture generation parameters for the currently active texture unit, selected with {@link glActiveTexture}.
 *
 * @summary control the generation of texture coordinates
 * @param coord Specifies a texture coordinate. Must be one of {@link GL_S}, {@link GL_T}, {@link GL_R}, or {@link GL_Q}.
 * @param pname Specifies the symbolic name of the texture-coordinate generation function or function parameters. Must be {@link GL_TEXTURE_GEN_MODE}, {@link GL_OBJECT_PLANE}, or {@link GL_EYE_PLANE}.
 * @param params Specifies a pointer to an array of texture generation parameters. If **pname** is {@link GL_TEXTURE_GEN_MODE}, then the array must contain a single symbolic constant, one of {@link GL_OBJECT_LINEAR}, {@link GL_EYE_LINEAR}, {@link GL_SPHERE_MAP}, {@link GL_NORMAL_MAP}, or {@link GL_REFLECTION_MAP}. Otherwise, **params** holds the coefficients for the texture-coordinate generation function specified by **pname**.
 * @see [glTexGen](https://docs.gl/gl3/glTexGen)
 */
export function glTexGenfv(coord: GLenum, pname: GLenum, params: GLfloat): void;

/**
 * `glTexGen` selects a texture-coordinate generation function or supplies coefficients for one of the functions. **coord** names one of the (**s**, **t**, **r**, **q**) texture coordinates; it must be one of the symbols {@link GL_S}, {@link GL_T}, {@link GL_R}, or {@link GL_Q}. **pname** must be one of three symbolic constants: {@link GL_TEXTURE_GEN_MODE}, {@link GL_OBJECT_PLANE}, or {@link GL_EYE_PLANE}. If **pname** is {@link GL_TEXTURE_GEN_MODE}, then **params** chooses a mode, one of {@link GL_OBJECT_LINEAR}, {@link GL_EYE_LINEAR}, {@link GL_SPHERE_MAP}, {@link GL_NORMAL_MAP}, or {@link GL_REFLECTION_MAP}. If **pname** is either {@link GL_OBJECT_PLANE} or {@link GL_EYE_PLANE}, **params** contains coefficients for the corresponding texture generation function.
 *
 * If the texture generation function is {@link GL_OBJECT_LINEAR}, the function
 *
 * 𝐠 = 𝐩₁ × 𝐱ₒ + 𝐩₂ × 𝐲ₒ + 𝐩₃ × 𝐳ₒ + 𝐩₄ × 𝐰ₒ
 *
 * is used, where 𝐠 is the value computed for the coordinate named in **coord**, 𝐩₁, 𝐩₂, 𝐩₃, and 𝐩₄ are the four values supplied in **params**, and 𝐱ₒ, 𝐲ₒ, 𝐳ₒ, and 𝐰ₒ are the object coordinates of the vertex. This function can be used, for example, to texture-map terrain using sea level as a reference plane (defined by 𝐩₁, 𝐩₂, 𝐩₃, and 𝐩₄). The altitude of a terrain vertex is computed by the {@link GL_OBJECT_LINEAR} coordinate generation function as its distance from sea level; that altitude can then be used to index the texture image to map white snow onto peaks and green grass onto foothills.
 *
 * If the texture generation function is {@link GL_EYE_LINEAR}, the function
 *
 * 𝐠 = 𝐩₁′′ × 𝐱ₑ + 𝐩₂′′ × 𝐲ₑ + 𝐩₃′′ × 𝐳ₑ + 𝐩₄′′ × 𝐰ₑ
 *
 *  is used, where
 *
 * (𝐩₁′′𝐩₂′′𝐩₃′′𝐩₄′′) = (𝐩₁𝐩₂𝐩₃𝐩₄)ᴹ^⁻¹
 *
 * and 𝐱ₑ, 𝐲ₑ, 𝐳ₑ, and 𝐰ₑ are the eye coordinates of the vertex, 𝐩₁, 𝐩₂, 𝐩₃, and 𝐩₄ are the values supplied in **params**, and 𝐌 is the modelview matrix when `glTexGen` is invoked. If 𝐌 is poorly conditioned or singular, texture coordinates generated by the resulting function may be inaccurate or undefined.
 *
 * Note that the values in **params** define a reference plane in eye coordinates. The modelview matrix that is applied to them may not be the same one in effect when the polygon vertices are transformed. This function establishes a field of texture coordinates that can produce dynamic contour lines on moving objects.
 *
 * If the texture generation function is {@link GL_SPHERE_MAP} and **coord** is either {@link GL_S} or {@link GL_T}, 𝐬 and 𝐭 texture coordinates are generated as follows. Let **u** be the unit vector pointing from the origin to the polygon vertex (in eye coordinates). Let **n** sup prime be the current normal, after transformation to eye coordinates. Let
 *
 * 𝐟 = (𝐟ₓ𝐟ᵧ𝐟𝑧)ᵀ be the reflection vector such that
 *
 * 𝐟 = 𝐮 - 2𝐧′′𝐧′′ᵀ𝐮
 *
 * Finally, let 𝐦 = 2√(𝐟ₓ² + 𝐟ᵧ² + (𝐟𝑧 + 1)²). Then the values assigned to the 𝐬 and 𝐭 texture coordinates are
 *
 * 𝐬 = 𝐟ₓ / 𝐦 + 1 / 2
 *
 * 𝐭 = 𝐟ᵧ / 𝐦 + 1 / 2
 *
 * To enable or disable a texture-coordinate generation function, call {@link glEnable} or {@link glDisable} with one of the symbolic texture-coordinate names ({@link GL_TEXTURE_GEN_S}, {@link GL_TEXTURE_GEN_T}, {@link GL_TEXTURE_GEN_R}, or {@link GL_TEXTURE_GEN_Q}) as the argument. When enabled, the specified texture coordinate is computed according to the generating function associated with that coordinate. When disabled, subsequent vertices take the specified texture coordinate from the current set of texture coordinates. Initially, all texture generation functions are set to {@link GL_EYE_LINEAR} and are disabled. Both 𝐬 plane equations are (1, 0, 0, 0), both 𝐭 plane equations are (0, 1, 0, 0), and all 𝐫 and 𝐪 plane equations are (0, 0, 0, 0).
 *
 * When the ARB_multitexture extension is supported, `glTexGen` sets the texture generation parameters for the currently active texture unit, selected with {@link glActiveTexture}.
 *
 * @summary control the generation of texture coordinates
 * @param coord Specifies a texture coordinate. Must be one of {@link GL_S}, {@link GL_T}, {@link GL_R}, or {@link GL_Q}.
 * @param pname Specifies the symbolic name of the texture-coordinate generation function or function parameters. Must be {@link GL_TEXTURE_GEN_MODE}, {@link GL_OBJECT_PLANE}, or {@link GL_EYE_PLANE}.
 * @param params Specifies a pointer to an array of texture generation parameters. If **pname** is {@link GL_TEXTURE_GEN_MODE}, then the array must contain a single symbolic constant, one of {@link GL_OBJECT_LINEAR}, {@link GL_EYE_LINEAR}, {@link GL_SPHERE_MAP}, {@link GL_NORMAL_MAP}, or {@link GL_REFLECTION_MAP}. Otherwise, **params** holds the coefficients for the texture-coordinate generation function specified by **pname**.
 * @see [glTexGen](https://docs.gl/gl3/glTexGen)
 */
export function glTexGeniv(coord: GLenum, pname: GLenum, params: GLint): void;

/**
 * Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. To enable and disable one-dimensional texturing, call {@link glEnable} and {@link glDisable} with argument {@link GL_TEXTURE_1D}.
 *
 * Texture images are defined with `glTexImage1D`. The arguments describe the parameters of the texture image, such as width, width of the border, level-of-detail number (see {@link glTexParameter}), and the internal resolution and format used to store the image. The last three arguments describe how the image is represented in memory.
 *
 * If **target** is {@link GL_PROXY_TEXTURE_1D}, no data is read from **data**, but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see {@link glGetError}). To query for an entire mipmap array, use an image array level greater than or equal to 1.
 *
 * If **target** is {@link GL_TEXTURE_1D}, data is read from **data** as a sequence of signed or unsigned bytes, shorts, or longs, or single-precision floating-point values, depending on **type**. These values are grouped into sets of one, two, three, or four values, depending on **format**, to form elements. Each data byte is treated as eight 1-bit elements, with bit ordering determined by {@link GL_UNPACK_LSB_FIRST} (see {@link glPixelStore}).
 *
 * If a non-zero named buffer object is bound to the {@link GL_PIXEL_UNPACK_BUFFER} target (see {@link glBindBuffer}) while a texture image is specified, **data** is treated as a byte offset into the buffer object's data store.
 *
 * The first element corresponds to the left end of the texture array. Subsequent elements progress left-to-right through the remaining texels in the texture array. The final element corresponds to the right end of the texture array.
 *
 * **format** determines the composition of each element in **data**. It can assume one of these symbolic values:
 *
 * - {@link GL_RED}
 * Each element is a single red component. The GL converts it to floating point and assembles it into an RGBA element by attaching 0 for green and blue, and 1 for alpha. Each component is clamped to the range [0,1].
 *
 * - {@link GL_RG}
 * Each element is a single red/green double The GL converts it to floating point and assembles it into an RGBA element by attaching 0 for blue, and 1 for alpha. Each component is clamped to the range [0,1].
 *
 * - {@link GL_RGB}, {@link GL_BGR}
 * Each element is an RGB triple. The GL converts it to floating point and assembles it into an RGBA element by attaching 1 for alpha. Each component is clamped to the range [0,1].
 *
 * - {@link GL_RGBA}, {@link GL_BGRA}
 * Each element contains all four components. Each component is clamped to the range [0,1].
 *
 * - {@link GL_DEPTH_COMPONENT}
 * Each element is a single depth value. The GL converts it to floating point and clamps to the range [0,1].
 *
 * If an application wants to store the texture at a certain resolution or in a certain format, it can request the resolution and format with **internalFormat**. The GL will choose an internal representation that closely approximates that requested by **internalFormat**, but it may not match exactly. (The representations specified by {@link GL_RED}, {@link GL_RG}, {@link GL_RGB} and {@link GL_RGBA} must match exactly.)
 *
 * If the **internalFormat** parameter is one of the generic compressed formats, {@link GL_COMPRESSED_RED}, {@link GL_COMPRESSED_RG}, {@link GL_COMPRESSED_RGB}, or {@link GL_COMPRESSED_RGBA}, the GL will replace the internal format with the symbolic constant for a specific internal format and compress the texture before storage. If no corresponding internal format is available, or the GL can not compress that image for any reason, the internal format is instead replaced with a corresponding base internal format.
 *
 * If the **internalFormat** parameter is {@link GL_SRGB}, {@link GL_SRGB8}, {@link GL_SRGB_ALPHA}or {@link GL_SRGB8_ALPHA8}, the texture is treated as if the red, green, or blue components are encoded in the sRGB color space. Any alpha component is left unchanged. The conversion from the sRGB encoded component 𝐜ₛ to a linear component 𝐜ₗ is:
 *
 * ㅤㅤ⎧ 𝐜ₛ / 12.92ㅤㅤㅤㅤㅤㅤㅤif 𝐜ₛ ≤ 0.04045
 *
 * 𝐜ₗ = ⎨
 *
 * ㅤㅤ⎩ (𝐜ₛ + 0.055 / 1.055)²·⁴ㅤㅤif 𝐜ₛ > 0.04045
 *
 * Assume 𝐜ₛ is the sRGB component in the range [0,1].
 *
 * Use the {@link GL_PROXY_TEXTURE_1D} target to try out a resolution and format. The implementation will update and recompute its best match for the requested storage resolution and format. To then query this state, call {@link glGetTexLevelParameter}. If the texture cannot be accommodated, texture state is set to 0.
 *
 * A one-component texture image uses only the red component of the RGBA color from **data**. A two-component image uses the R and A values. A three-component image uses the R, G, and B values. A four-component image uses all of the RGBA components.
 *
 * Image-based shadowing can be enabled by comparing texture r coordinates to depth texture values to generate a boolean result. See {@link glTexParameter} for details on texture comparison.
 *
 * @summary specify a one-dimensional texture image
 * @param target Specifies the target texture. Must be {@link GL_TEXTURE_1D} or {@link GL_PROXY_TEXTURE_1D}.
 * @param level Specifies the level-of-detail number. Level 0 is the base image level. Level **n** is the **n**ᵗʰ mipmap reduction image.
 * @param internalFormat Specifies the number of color components in the texture. Must be one of the following symbolic constants: {@link GL_COMPRESSED_RED}, {@link GL_COMPRESSED_RG}, {@link GL_COMPRESSED_RGB}, {@link GL_COMPRESSED_RGBA}, {@link GL_COMPRESSED_SRGB}, {@link GL_COMPRESSED_SRGB_ALPHA}, {@link GL_DEPTH_COMPONENT}, {@link GL_DEPTH_COMPONENT16}, {@link GL_DEPTH_COMPONENT24}, {@link GL_DEPTH_COMPONENT32}, {@link GL_R3_G3_B2}, {@link GL_RED}, {@link GL_RG}, {@link GL_RGB}, {@link GL_RGB4}, {@link GL_RGB5}, {@link GL_RGB8}, {@link GL_RGB10}, {@link GL_RGB12}, {@link GL_RGB16}, {@link GL_RGBA}, {@link GL_RGBA2}, {@link GL_RGBA4}, {@link GL_RGB5_A1}, {@link GL_RGBA8}, {@link GL_RGB10_A2}, {@link GL_RGBA12}, {@link GL_RGBA16}, {@link GL_SRGB}, {@link GL_SRGB8}, {@link GL_SRGB_ALPHA}, or {@link GL_SRGB8_ALPHA8}.
 * @param width Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide. The height of the 1D texture image is 1.
 * @param border This value must be 0.
 * @param format Specifies the format of the pixel data. The following symbolic values are accepted: {@link GL_RED}, {@link GL_RG}, {@link GL_RGB}, {@link GL_BGR}, {@link GL_RGBA}, and {@link GL_BGRA}.
 * @param type Specifies the data type of the pixel data. The following symbolic values are accepted: {@link GL_UNSIGNED_BYTE}, {@link GL_BYTE}, {@link GL_UNSIGNED_SHORT}, {@link GL_SHORT}, {@link GL_UNSIGNED_INT}, {@link GL_INT}, {@link GL_FLOAT}, {@link GL_UNSIGNED_BYTE_3_3_2}, {@link GL_UNSIGNED_BYTE_2_3_3_REV}, {@link GL_UNSIGNED_SHORT_5_6_5}, {@link GL_UNSIGNED_SHORT_5_6_5_REV}, {@link GL_UNSIGNED_SHORT_4_4_4_4}, {@link GL_UNSIGNED_SHORT_4_4_4_4_REV}, {@link GL_UNSIGNED_SHORT_5_5_5_1}, {@link GL_UNSIGNED_SHORT_1_5_5_5_REV}, {@link GL_UNSIGNED_INT_8_8_8_8}, {@link GL_UNSIGNED_INT_8_8_8_8_REV}, {@link GL_UNSIGNED_INT_10_10_10_2}, and {@link GL_UNSIGNED_INT_2_10_10_10_REV}.
 * @param data Specifies a pointer to the image data in memory.
 * @see [glTexImage1D](https://docs.gl/gl3/glTexImage1D)
 */
export function glTexImage1D(
	target: GLenum,
	level: GLint,
	internalFormat: GLint,
	width: GLsizei,
	border: GLint,
	format: GLenum,
	type: GLenum,
	data: GLvoid
): void;

/**
 * Texturing allows elements of an image array to be read by shaders.
 *
 * To define texture images, call `glTexImage2D`. The arguments describe the parameters of the texture image, such as height, width, width of the border, level-of-detail number (see {@link glTexParameter}), and number of color components provided. The last three arguments describe how the image is represented in memory.
 *
 * If **target** is {@link GL_PROXY_TEXTURE_2D}, {@link GL_PROXY_TEXTURE_1D_ARRAY}, {@link GL_PROXY_TEXTURE_CUBE_MAP}, or {@link GL_PROXY_TEXTURE_RECTANGLE}, no data is read from **data**, but all of the texture image state is recalculated, checked for consistency, and checked against the implementation's capabilities. If the implementation cannot handle a texture of the requested texture size, it sets all of the image state to 0, but does not generate an error (see {@link glGetError}). To query for an entire mipmap array, use an image array level greater than or equal to 1.
 *
 * If **target** is {@link GL_TEXTURE_2D}, {@link GL_TEXTURE_RECTANGLE} or one of the {@link GL_TEXTURE_CUBE_MAP} targets, data is read from **data** as a sequence of signed or unsigned bytes, shorts, or longs, or single-precision floating-point values, depending on **type**. These values are grouped into sets of one, two, three, or four values, depending on **format**, to form elements. Each data byte is treated as eight 1-bit elements, with bit ordering determined by {@link GL_UNPACK_LSB_FIRST} (see {@link glPixelStore}).
 *
 * If **target** is {@link GL_TEXTURE_1D_ARRAY}, data is interpreted as an array of one-dimensional images.
 *
 * If a non-zero named buffer object is bound to the {@link GL_PIXEL_UNPACK_BUFFER} target (see {@link glBindBuffer}) while a texture image is specified, **data** is treated as a byte offset into the buffer object's data store.
 *
 * The first element corresponds to the lower left corner of the texture image. Subsequent elements progress left-to-right through the remaining texels in the lowest row of the texture image, and then in successively higher rows of the texture image. The final element corresponds to the upper right corner of the texture image.
 *
 * **format** determines the composition of each element in **data**. It can assume one of these symbolic values:
 *
 * - {@link GL_RED}
 * Each element is a single red component. The GL converts it to floating point and assembles it into an RGBA element by attaching 0 for green and blue, and 1 for alpha. Each component is clamped to the range [0,1].
 *
 * - {@link GL_RG}
 * Each element is a single red/green double The GL converts it to floating point and assembles it into an RGBA element by attaching 0 for blue, and 1 for alpha. Each component is clamped to the range [0,1].
 *
 * - {@link GL_RGB}, {@link GL_BGR}
 * Each element is an RGB triple. The GL converts it to floating point and assembles it into an RGBA element by attaching 1 for alpha. Each component is clamped to the range [0,1].
 *
 * - {@link GL_RGBA}, {@link GL_BGRA}
 * Each element contains all four components. Each component is clamped to the range [0,1].
 *
 * - {@link GL_DEPTH_COMPONENT}
 * Each element is a single depth value. The GL converts it to floating point and clamps to the range [0,1].
 *
 * - {@link GL_DEPTH_STENCIL}
 * Each element is a pair of depth and stencil values. The depth component of the pair is interpreted as in {@link GL_DEPTH_COMPONENT}. The stencil component is interpreted based on specified the depth + stencil internal format.
 *
 * If an application wants to store the texture at a certain resolution or in a certain format, it can request the resolution and format with **internalFormat**. The GL will choose an internal representation that closely approximates that requested by **internalFormat**, but it may not match exactly. (The representations specified by {@link GL_RED}, {@link GL_RG}, {@link GL_RGB}, and {@link GL_RGBA} must match exactly.)
 *
 * If the **internalFormat** parameter is one of the generic compressed formats, {@link GL_COMPRESSED_RED}, {@link GL_COMPRESSED_RG}, {@link GL_COMPRESSED_RGB}, or {@link GL_COMPRESSED_RGBA}, the GL will replace the internal format with the symbolic constant for a specific internal format and compress the texture before storage. If no corresponding internal format is available, or the GL can not compress that image for any reason, the internal format is instead replaced with a corresponding base internal format.
 *
 *  If the **internalFormat** parameter is {@link GL_SRGB}, {@link GL_SRGB8}, {@link GL_SRGB_ALPHA}, or {@link GL_SRGB8_ALPHA8}, the texture is treated as if the red, green, or blue components are encoded in the sRGB color space. Any alpha component is left unchanged. The conversion from the sRGB encoded component 𝐜ₛ to a linear component 𝐜ₗ is:
 *
 * ㅤㅤ⎧ 𝐜ₛ / 12.92ㅤㅤㅤㅤㅤㅤㅤif 𝐜ₛ ≤ 0.04045
 *
 * 𝐜ₗ = ⎨
 *
 * ㅤㅤ⎩ (𝐜ₛ + 0.055 / 1.055)²·⁴ㅤㅤif 𝐜ₛ > 0.04045
 *
 * Assume 𝐜ₛ is the sRGB component in the range [0,1].
 *
 * Use the {@link GL_PROXY_TEXTURE_2D}, {@link GL_PROXY_TEXTURE_1D_ARRAY}, {@link GL_PROXY_TEXTURE_RECTANGLE}, or {@link GL_PROXY_TEXTURE_CUBE_MAP} target to try out a resolution and format. The implementation will update and recompute its best match for the requested storage resolution and format. To then query this state, call {@link glGetTexLevelParameter}. If the texture cannot be accommodated, texture state is set to 0.
 *
 * A one-component texture image uses only the red component of the RGBA color extracted from **data**. A two-component image uses the R and G values. A three-component image uses the R, G, and B values. A four-component image uses all of the RGBA components.
 *
 * Image-based shadowing can be enabled by comparing texture r coordinates to depth texture values to generate a boolean result. See {@link glTexParameter} for details on texture comparison.
 *
 * @summary specify a two-dimensional texture image
 * @param target Specifies the target texture. Must be {@link GL_TEXTURE_2D}, {@link GL_PROXY_TEXTURE_2D}, {@link GL_TEXTURE_1D_ARRAY}, {@link GL_PROXY_TEXTURE_1D_ARRAY}, {@link GL_TEXTURE_RECTANGLE}, {@link GL_PROXY_TEXTURE_RECTANGLE}, {@link GL_TEXTURE_CUBE_MAP_POSITIVE_X}, {@link GL_TEXTURE_CUBE_MAP_NEGATIVE_X}, {@link GL_TEXTURE_CUBE_MAP_POSITIVE_Y}, {@link GL_TEXTURE_CUBE_MAP_NEGATIVE_Y}, {@link GL_TEXTURE_CUBE_MAP_POSITIVE_Z}, {@link GL_TEXTURE_CUBE_MAP_NEGATIVE_Z}, or {@link GL_PROXY_TEXTURE_CUBE_MAP}.
 * @param level Specifies the level-of-detail number. Level 0 is the base image level. Level **n** is the **n**ᵗʰ mipmap reduction image. If **target** is {@link GL_TEXTURE_RECTANGLE} or {@link GL_PROXY_TEXTURE_RECTANGLE}, **level** must be 0.
 * @param internalFormat Specifies the number of color components in the texture. Must be one of the following symbolic constants: {@link GL_RGBA32F}, {@link GL_RGBA32I}, {@link GL_RGBA32UI}, {@link GL_RGBA16}, {@link GL_RGBA16F}, {@link GL_RGBA16I}, {@link GL_RGBA16UI}, {@link GL_RGBA8}, {@link GL_RGBA8UI}, {@link GL_SRGB8_ALPHA8}, {@link GL_RGB10_A2}, {@link GL_RGB10_A2UI}, {@link GL_R11F_G11F_B10F}, {@link GL_RG32F}, {@link GL_RG32I}, {@link GL_RG32UI}, {@link GL_RG16}, {@link GL_RG16F}, {@link GL_RGB16I}, {@link GL_RGB16UI}, {@link GL_RG8}, {@link GL_RG8I}, {@link GL_RG8UI}, {@link GL_R32F}, {@link GL_R32I}, {@link GL_R32UI}, {@link GL_R16F}, {@link GL_R16I}, {@link GL_R16UI}, {@link GL_R8}, {@link GL_R8I}, {@link GL_R8UI}, {@link GL_RGBA16_SNORM}, {@link GL_RGBA8_SNORM}, {@link GL_RGB32F}, {@link GL_RGB32I}, {@link GL_RGB32UI}, {@link GL_RGB16_SNORM}, {@link GL_RGB16F}, {@link GL_RGB16I}, {@link GL_RGB16UI}, {@link GL_RGB16}, {@link GL_RGB8_SNORM}, {@link GL_RGB8}, {@link GL_RGB8I}, {@link GL_RGB8UI}, {@link GL_SRGB8}, {@link GL_RGB9_E5}, {@link GL_RG16_SNORM}, {@link GL_RG8_SNORM}, {@link GL_COMPRESSED_RG_RGTC2}, {@link GL_COMPRESSED_SIGNED_RG_RGTC2}, {@link GL_R16_SNORM}, {@link GL_R8_SNORM}, {@link GL_COMPRESSED_RED_RGTC1}, {@link GL_COMPRESSED_SIGNED_RED_RGTC1}, {@link GL_DEPTH_COMPONENT32F}, {@link GL_DEPTH_COMPONENT24}, {@link GL_DEPTH_COMPONENT16}, {@link GL_DEPTH32F_STENCIL8}, {@link GL_DEPTH24_STENCIL8}.
 * @param width Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.
 * @param height Specifies the height of the texture image, or the number of layers in a texture array, in the case of the {@link GL_TEXTURE_1D_ARRAY} and {@link GL_PROXY_TEXTURE_1D_ARRAY} targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.
 * @param border This value must be 0.
 * @param format Specifies the format of the pixel data. The following symbolic values are accepted: {@link GL_RED}, {@link GL_RG}, {@link GL_RGB}, {@link GL_BGR}, {@link GL_RGBA}, and {@link GL_BGRA}.
 * @param type Specifies the data type of the pixel data. The following symbolic values are accepted: {@link GL_UNSIGNED_BYTE}, {@link GL_BYTE}, {@link GL_UNSIGNED_SHORT}, {@link GL_SHORT}, {@link GL_UNSIGNED_INT}, {@link GL_INT}, {@link GL_FLOAT}, {@link GL_UNSIGNED_BYTE_3_3_2}, {@link GL_UNSIGNED_BYTE_2_3_3_REV}, {@link GL_UNSIGNED_SHORT_5_6_5}, {@link GL_UNSIGNED_SHORT_5_6_5_REV}, {@link GL_UNSIGNED_SHORT_4_4_4_4}, {@link GL_UNSIGNED_SHORT_4_4_4_4_REV}, {@link GL_UNSIGNED_SHORT_5_5_5_1}, {@link GL_UNSIGNED_SHORT_1_5_5_5_REV}, {@link GL_UNSIGNED_INT_8_8_8_8}, {@link GL_UNSIGNED_INT_8_8_8_8_REV}, {@link GL_UNSIGNED_INT_10_10_10_2}, and {@link GL_UNSIGNED_INT_2_10_10_10_REV}.
 * @param data Specifies a pointer to the image data in memory.
 * @example Create a framebuffer object with a texture-based color attachment and a texture-based depth attachment. Using texture-based attachments allows sampling of those textures in shaders.
 * ```
 * // fbo_width and fbo_height are the desired width and height of the FBO.
 * // For Opengl <= 4.4 or if the GL_ARB_texture_non_power_of_two extension
 * // is present, fbo_width and fbo_height can be values other than 2^n for
 * // some integer n.
 *
 * // Build the texture that will serve as the color attachment for the framebuffer.
 * let texture_map: GLuint;
 * glGenTextures(1, texture_map);
 * glBindTexture(GL_TEXTURE_2D, texture_map);
 *
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);
 *
 * glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, fbo_width, fbo_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
 *
 * glBindTexture(GL_TEXTURE_2D, 0);
 *
 * // Build the texture that will serve as the depth attachment for the framebuffer.
 * let depth_texture: GLuint;
 * glGenTextures(1, depth_texture);
 * glBindTexture(GL_TEXTURE_2D, depth_texture);
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
 * glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, fbo_width, fbo_height, 0, GL_DEPTH_COMPONENT, GL_UNSIGNED_BYTE, NULL);
 * glBindTexture(GL_TEXTURE_2D, 0);
 *
 * // Build the framebuffer.
 * let framebuffer: GLuint;
 * glGenFramebuffers(1, framebuffer);
 * glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);
 * glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture_map, 0);
 * glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depth_texture, 0);
 *
 * let status: GLenum = glCheckFramebufferStatus(GL_FRAMEBUFFER);
 * if (status != GL_FRAMEBUFFER_COMPLETE)
 *     // Error
 *
 * glBindFramebuffer(GL_FRAMEBUFFER, 0);
 * ```
 *
 * @example Create a texture object with linear mipmaps and edge clamping.
 * ```
 * let texture_id: GLuint;
 * glGenTextures(1, texture_id);
 * glBindTexture(GL_TEXTURE_2D, texture_id);
 *
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
 *
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
 *
 * // texture_data is the source data of your texture, in this case
 * // its size is sizeof(unsigned char) * texture_width * texture_height * 4
 * glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, texture_width, texture_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, texture_data);
 * glGenerateMipmap(GL_TEXTURE_2D); // Unavailable in OpenGL 2.1, use gluBuild2DMipmaps() instead
 *
 * glBindTexture(GL_TEXTURE_2D, 0);
 * ```
 *
 * @tutorial [Songho - OpenGL Frame Buffer Object (FBO)](https://www.songho.ca/opengl/gl_fbo.html)
 * @tutorial [open.gl - Framebuffers](https://open.gl/framebuffers)
 * @tutorial [open.gl - Textures Objects and Parameters](https://open.gl/textures)
 * @tutorial [opengl-tutorial.org - Tutorial 14 : Render To Texture](https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-14-render-to-texture/)
 * @tutorial [opengl-tutorial.org - Tutorial 16 : Shadow mapping](https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/)
 * @tutorial [opengl-tutorial.org - Tutorial 5 : A Textured Cube](https://www.opengl-tutorial.org/beginners-tutorials/tutorial-5-a-textured-cube/)
 * @see [glTexImage2D](https://docs.gl/gl3/glTexImage2D)
 */
export function glTexImage2D(
	target: GLenum,
	level: GLint,
	internalFormat: GLint,
	width: GLsizei,
	height: GLsizei,
	border: GLint,
	format: GLenum,
	type: GLenum,
	data: GLvoid
): void;

/**
 * `glTexParameter` assigns the value or values in **params** to the texture parameter specified as **pname**. **target** defines the target texture, either {@link GL_TEXTURE_1D}, {@link GL_TEXTURE_2D}, {@link GL_TEXTURE_1D_ARRAY}, {@link GL_TEXTURE_2D_ARRAY}, {@link GL_TEXTURE_RECTANGLE}, or {@link GL_TEXTURE_3D}. The following symbols are accepted in **pname**:
 *
 * - {@link GL_TEXTURE_BASE_LEVEL}
 * Specifies the index of the lowest defined mipmap level. This is an integer value. The initial value is 0.
 *
 * - {@link GL_TEXTURE_BORDER_COLOR}
 * The data in **params** specifies four values that define the border values that should be used for border texels. If a texel is sampled from the border of the texture, the values of {@link GL_TEXTURE_BORDER_COLOR} are interpreted as an RGBA color to match the texture's internal format and substituted for the non-existent texel data. If the texture contains depth components, the first component of {@link GL_TEXTURE_BORDER_COLOR} is interpreted as a depth value. The initial value is (0.0,0.0,0.0,0.0).
 *  If the values for {@link GL_TEXTURE_BORDER_COLOR} are specified with `glTexParameterIiv` or `glTexParameterIuiv`, the values are stored unmodified with an internal data type of integer. If specified with `glTexParameteriv`, they are converted to floating point with the following equation: 𝐟 = 2𝑐 + 1 / 2ᵇ − 1. If specified with `glTexParameterfv`, they are stored unmodified as floating-point values.
 *
 * - {@link GL_TEXTURE_COMPARE_FUNC}
 * Specifies the comparison operator used when {@link GL_TEXTURE_COMPARE_MODE} is set to {@link GL_COMPARE_REF_TO_TEXTURE}. Permissible values are:
 *
 * | **Texture Comparison Function** | **Computed result**   |
 * | :------------------------------ | :-------------------- |
 * |                                 |ㅤㅤㅤㅤ⎧ 1.0𝐫 <= 𝐃ₜ     |
 * | {@link GL_LEQUAL}               | result = ⎨            |
 * |                                 |ㅤㅤㅤㅤ⎩ 0.0𝐫 > 𝐃ₜ      |
 * |                                 |ㅤㅤㅤㅤ⎧ 1.0𝐫 >= 𝐃ₜ     |
 * | {@link GL_GEQUAL}               | result = ⎨            |
 * |                                 |ㅤㅤㅤㅤ⎩ 0.0𝐫 < 𝐃ₜ      |
 * |                                 |ㅤㅤㅤㅤ⎧ 1.0𝐫 < 𝐃ₜ      |
 * | {@link GL_LESS}                 | result = ⎨            |
 * |                                 |ㅤㅤㅤㅤ⎩ 0.0𝐫 >= 𝐃ₜ     |
 * |                                 |ㅤㅤㅤㅤ⎧ 1.0𝐫 > 𝐃ₜ      |
 * | {@link GL_GREATER}              | result = ⎨            |
 * |                                 |ㅤㅤㅤㅤ⎩ 0.0𝐫 <= 𝐃ₜ     |
 * |                                 |ㅤㅤㅤㅤ⎧ 1.0𝐫 = 𝐃ₜ      |
 * | {@link GL_EQUAL}                | result = ⎨            |
 * |                                 |ㅤㅤㅤㅤ⎩ 0.0𝐫 ≠ 𝐃ₜ     |
 * |                                 |ㅤㅤㅤㅤ⎧ 1.0𝐫 ≠ 𝐃ₜ     |
 * | {@link GL_NOTEQUAL}             | result = ⎨            |
 * |                                 |ㅤㅤㅤㅤ⎩ 0.0𝐫 = 𝐃ₜ      |
 * | {@link GL_ALWAYS}               | result = 1.0          |
 * | {@link GL_NEVER}                | result = 0.0          |
 *
 * where 𝐫 is the current interpolated texture coordinate, and 𝐃ₜ is the depth texture value sampled from the currently bound depth texture. *result* is assigned to the the red channel.
 *
 * - {@link GL_TEXTURE_COMPARE_MODE}
 * Specifies the texture comparison mode for currently bound depth textures. That is, a texture whose internal format is {@link GL_DEPTH_COMPONENT_*}; see {@link glTexImage2D}) Permissible values are:
 * - - {@link GL_COMPARE_REF_TO_TEXTURE} Specifies that the interpolated and clamped 𝐫 texture coordinate should be compared to the value in the currently bound depth texture. See the discussion of {@link GL_TEXTURE_COMPARE_FUNC} for details of how the comparison is evaluated. The result of the comparison is assigned to the red channel.
 * - - {@link GL_NONE} Specifies that the red channel should be assigned the appropriate value from the currently bound depth texture.
 *
 * - {@link GL_TEXTURE_LOD_BIAS}
 * **params** specifies a fixed bias value that is to be added to the level-of-detail parameter for the texture before texture sampling. The specified value is added to the shader-supplied bias value (if any) and subsequently clamped into the implementation-defined range [−biasₘₐₓ, biasₘₐₓ], where biasₘₐₓ is the value of the implementation defined constant {@link GL_MAX_TEXTURE_LOD_BIAS}. The initial value is 0.0.
 *
 * - {@link GL_TEXTURE_MIN_FILTER}
 *
 * The texture minifying function is used whenever the level-of-detail function used when sampling from the texture determines that the texture should be minified. There are six defined minifying functions. Two of them use either the nearest texture elements or a weighted average of multiple texture elements to compute the texture value. The other four use mipmaps.
 *
 * A mipmap is an ordered set of arrays representing the same image at progressively lower resolutions. If the texture has dimensions 2ⁿ × 2ᵐ, there are max(𝐧, 𝐦) + 1 mipmaps. The first mipmap is the original texture, with dimensions 2ⁿ × 2ᵐ. Each subsequent mipmap has dimensions 2ᵏ⁻¹ 2ᶩ⁻¹, where 2ᵏ × 2ᶩ are the dimensions of the previous mipmap, until either 𝐤 = 0 or 𝐥 = 0. At that point, subsequent mipmaps have dimension 1 × 2ᶩ⁻¹ or 2ᵏ⁻¹ × 1 until the final mipmap, which has dimension 1 × 1. To define the mipmaps, call {@link glTexImage1D}, {@link glTexImage2D}, {@link glTexImage3D}, {@link glCopyTexImage1D}, or {@link glCopyTexImage2D} with the **level** argument indicating the order of the mipmaps. Level 0 is the original texture; level max(𝐧, 𝐦) is the final 1 × 1 mipmap.
 *
 * **params** supplies a function for minifying the texture as one of the following:
 *
 * - - {@link GL_NEAREST}
 * Returns the value of the texture element that is nearest (in Manhattan distance) to the specified texture coordinates.
 *
 * - - {@link GL_LINEAR}
 * Returns the weighted average of the four texture elements that are closest to the specified texture coordinates. These can include items wrapped or repeated from other parts of a texture, depending on the values of {@link GL_TEXTURE_WRAP_S} and {@link GL_TEXTURE_WRAP_T}, and on the exact mapping.
 *
 * - - {@link GL_NEAREST_MIPMAP_NEAREST}
 * Chooses the mipmap that most closely matches the size of the pixel being textured and uses the {@link GL_NEAREST} criterion (the texture element closest to the specified texture coordinates) to produce a texture value.
 *
 * - - {@link GL_LINEAR_MIPMAP_NEAREST}
 * Chooses the mipmap that most closely matches the size of the pixel being textured and uses the {@link GL_LINEAR} criterion (a weighted average of the four texture elements that are closest to the specified texture coordinates) to produce a texture value.
 *
 * - - {@link GL_NEAREST_MIPMAP_LINEAR}
 * Chooses the two mipmaps that most closely match the size of the pixel being textured and uses the {@link GL_NEAREST} criterion (the texture element closest to the specified texture coordinates ) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values.
 *
 * - - {@link GL_LINEAR_MIPMAP_LINEAR}
 * Chooses the two mipmaps that most closely match the size of the pixel being textured and uses the {@link GL_LINEAR} criterion (a weighted average of the texture elements that are closest to the specified texture coordinates) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values.
 *
 * As more texture elements are sampled in the minification process, fewer aliasing artifacts will be apparent. While the {@link GL_NEAREST} and {@link GL_LINEAR} minification functions can be faster than the other four, they sample only one or multiple texture elements to determine the texture value of the pixel being rendered and can produce moire patterns or ragged transitions. The initial value of {@link GL_TEXTURE_MIN_FILTER} is {@link GL_NEAREST_MIPMAP_LINEAR}.
 *
 * - {@link GL_TEXTURE_MAG_FILTER}
 * The texture magnification function is used whenever the level-of-detail function used when sampling from the texture determines that the texture should be magified. It sets the texture magnification function to either {@link GL_NEAREST} or {@link GL_LINEAR} (see below). {@link GL_NEAREST} is generally faster than {@link GL_LINEAR}, but it can produce textured images with sharper edges because the transition between texture elements is not as smooth. The initial value of {@link GL_TEXTURE_MAG_FILTER} is {@link GL_LINEAR}.
 *
 * - - {@link GL_NEAREST}
 * Returns the value of the texture element that is nearest (in Manhattan distance) to the specified texture coordinates.
 *
 * - - {@link GL_LINEAR}
 * Returns the weighted average of the texture elements that are closest to the specified texture coordinates. These can include items wrapped or repeated from other parts of a texture, depending on the values of {@link GL_TEXTURE_WRAP_S} and {@link GL_TEXTURE_WRAP_T}, and on the exact mapping.
 *
 * - {@link GL_TEXTURE_MIN_LOD}
 * Sets the minimum level-of-detail parameter. This floating-point value limits the selection of highest resolution mipmap (lowest mipmap level). The initial value is -1000.
 *
 * - {@link GL_TEXTURE_MAX_LOD}
 * Sets the maximum level-of-detail parameter. This floating-point value limits the selection of the lowest resolution mipmap (highest mipmap level). The initial value is 1000.
 *
 * - {@link GL_TEXTURE_MAX_LEVEL}
 * Sets the index of the highest defined mipmap level. This is an integer value. The initial value is 1000.
 *
 * - {@link GL_TEXTURE_SWIZZLE_R}
 * Sets the swizzle that will be applied to the 𝐫 component of a texel before it is returned to the shader. Valid values for **param** are {@link GL_RED}, {@link GL_GREEN}, {@link GL_BLUE}, {@link GL_ALPHA}, {@link GL_ZERO} and {@link GL_ONE}. If {@link GL_TEXTURE_SWIZZLE_R} is {@link GL_RED}, the value for 𝐫 will be taken from the first channel of the fetched texel. If {@link GL_TEXTURE_SWIZZLE_R} is {@link GL_GREEN}, the value for 𝐫 will be taken from the second channel of the fetched texel. If {@link GL_TEXTURE_SWIZZLE_R} is {@link GL_BLUE}, the value for 𝐫 will be taken from the third channel of the fetched texel. If {@link GL_TEXTURE_SWIZZLE_R} is {@link GL_ALPHA}, the value for 𝐫 will be taken from the fourth channel of the fetched texel. If {@link GL_TEXTURE_SWIZZLE_R} is {@link GL_ZERO}, the value for 𝐫 will be subtituted with 0.0. If {@link GL_TEXTURE_SWIZZLE_R} is {@link GL_ONE}, the value for 𝐫 will be subtituted with 1.0. The initial value is {@link GL_RED}.
 *
 * - {@link GL_TEXTURE_SWIZZLE_G}
 * Sets the swizzle that will be applied to the 𝐠 component of a texel before it is returned to the shader. Valid values for **param** and their effects are similar to those of {@link GL_TEXTURE_SWIZZLE_R}. The initial value is {@link GL_GREEN}.
 *
 * - {@link GL_TEXTURE_SWIZZLE_B}
 * Sets the swizzle that will be applied to the 𝐛 component of a texel before it is returned to the shader. Valid values for **param** and their effects are similar to those of {@link GL_TEXTURE_SWIZZLE_R}. The initial value is {@link GL_BLUE}.
 *
 * - {@link GL_TEXTURE_SWIZZLE_A}
 * Sets the swizzle that will be applied to the 𝐚 component of a texel before it is returned to the shader. Valid values for **param** and their effects are similar to those of {@link GL_TEXTURE_SWIZZLE_R}. The initial value is {@link GL_ALPHA}.
 *
 * - {@link GL_TEXTURE_SWIZZLE_RGBA}
 * Sets the swizzles that will be applied to the 𝐫, 𝐠, 𝐛, and 𝐚 components of a texel before they are returned to the shader. Valid values for **params** and their effects are similar to those of {@link GL_TEXTURE_SWIZZLE_R}, except that all channels are specified simultaneously. Setting the value of {@link GL_TEXTURE_SWIZZLE_RGBA} is equivalent (assuming no errors are generated) to setting the parameters of each of {@link GL_TEXTURE_SWIZZLE_R}, {@link GL_TEXTURE_SWIZZLE_G}, {@link GL_TEXTURE_SWIZZLE_B}, and {@link GL_TEXTURE_SWIZZLE_A} successively.
 *
 * - {@link GL_TEXTURE_WRAP_S}
 * Sets the wrap parameter for texture coordinate 𝐬 to either {@link GL_CLAMP_TO_EDGE}, {@link GL_CLAMP_TO_BORDER}, {@link GL_MIRRORED_REPEAT}, or {@link GL_REPEAT}. {@link GL_CLAMP_TO_EDGE} causes 𝐬 coordinates to be clamped to the range [1/2𝐍, 1 − 1/2𝐍], where 𝐍 is the size of the texture in the direction of clamping. {@link GL_CLAMP_TO_BORDER} evaluates 𝐬 coordinates in a similar manner to {@link GL_CLAMP_TO_EDGE}. However, in cases where clamping would have occurred in {@link GL_CLAMP_TO_EDGE} mode, the fetched texel data is substituted with the values specified by {@link GL_TEXTURE_BORDER_COLOR}. {@link GL_REPEAT} causes the integer part of the 𝐬 coordinate to be ignored; the GL uses only the fractional part, thereby creating a repeating pattern. {@link GL_MIRRORED_REPEAT} causes the 𝐬 coordinate to be set to the fractional part of the texture coordinate if the integer part of 𝐬 is even; if the integer part of 𝐬 is odd, then the 𝐬 texture coordinate is set to 1 − frac(𝐬), where frac(𝐬) represents the fractional part of 𝐬. Initially, {@link GL_TEXTURE_WRAP_S} is set to {@link GL_REPEAT}.
 *
 * - {@link GL_TEXTURE_WRAP_T}
 * Sets the wrap parameter for texture coordinate 𝐭 to either {@link GL_CLAMP_TO_EDGE}, {@link GL_CLAMP_TO_BORDER}, {@link GL_MIRRORED_REPEAT}, or {@link GL_REPEAT}. See the discussion under {@link GL_TEXTURE_WRAP_S}. Initially, {@link GL_TEXTURE_WRAP_T} is set to {@link GL_REPEAT}.
 *
 * - {@link GL_TEXTURE_WRAP_R}
 *  Sets the wrap parameter for texture coordinate 𝐫 to either {@link GL_CLAMP_TO_EDGE}, {@link GL_CLAMP_TO_BORDER}, {@link GL_MIRRORED_REPEAT}, or {@link GL_REPEAT}. See the discussion under {@link GL_TEXTURE_WRAP_S}. Initially, {@link GL_TEXTURE_WRAP_R} is set to {@link GL_REPEAT}.
 *
 * @summary set texture parameters
 * @param target Specifies the target texture, which must be either {@link GL_TEXTURE_1D}, {@link GL_TEXTURE_2D}, {@link GL_TEXTURE_3D}, {@link GL_TEXTURE_1D_ARRAY}, {@link GL_TEXTURE_2D_ARRAY}, {@link GL_TEXTURE_RECTANGLE}, or {@link GL_TEXTURE_CUBE_MAP}.
 * @param pname Specifies the symbolic name of a single-valued texture parameter. **pname** can be one of the following: {@link GL_TEXTURE_BASE_LEVEL}, {@link GL_TEXTURE_COMPARE_FUNC}, {@link GL_TEXTURE_COMPARE_MODE}, {@link GL_TEXTURE_LOD_BIAS}, {@link GL_TEXTURE_MIN_FILTER}, {@link GL_TEXTURE_MAG_FILTER}, {@link GL_TEXTURE_MIN_LOD}, {@link GL_TEXTURE_MAX_LOD}, {@link GL_TEXTURE_MAX_LEVEL}, {@link GL_TEXTURE_SWIZZLE_R}, {@link GL_TEXTURE_SWIZZLE_G}, {@link GL_TEXTURE_SWIZZLE_B}, {@link GL_TEXTURE_SWIZZLE_A}, {@link GL_TEXTURE_WRAP_S}, {@link GL_TEXTURE_WRAP_T}, or {@link GL_TEXTURE_WRAP_R}.
 * @param param Specifies the value of **pname**.
 * @example Create a framebuffer object with a texture-based color attachment and a texture-based depth attachment. Using texture-based attachments allows sampling of those textures in shaders.
 * ```
 * // fbo_width and fbo_height are the desired width and height of the FBO.
 * // For Opengl <= 4.4 or if the  GL_ARB_texture_non_power_of_two extension
 * // is present, fbo_width and fbo_height can be values other than 2^n for
 * // some integer n.
 *
 * // Build the texture that will serve as the color attachment for the framebuffer.
 * let texture_map: GLuint;
 * glGenTextures(1, texture_map);
 * glBindTexture(GL_TEXTURE_2D, texture_map);
 *
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_MIN_FILTER,  GL_LINEAR);
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_MAG_FILTER,  GL_LINEAR);
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_WRAP_S,  GL_CLAMP_TO_BORDER);
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_WRAP_T,  GL_CLAMP_TO_BORDER);
 *
 * glTexImage2D(GL_TEXTURE_2D, 0,  GL_RGBA, fbo_width, fbo_height, 0,  GL_RGBA,  GL_UNSIGNED_BYTE, NULL);
 *
 * glBindTexture(GL_TEXTURE_2D, 0);
 *
 * // Build the texture that will serve as the depth attachment for the framebuffer.
 * let depth_texture: GLuint;
 * glGenTextures(1, depth_texture);
 * glBindTexture(GL_TEXTURE_2D, depth_texture);
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_MIN_FILTER,  GL_NEAREST);
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_MAG_FILTER,  GL_NEAREST);
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_WRAP_S,  GL_CLAMP_TO_EDGE);
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_WRAP_T,  GL_CLAMP_TO_EDGE);
 * glTexImage2D(GL_TEXTURE_2D, 0,  GL_DEPTH_COMPONENT, fbo_width, fbo_height, 0,  GL_DEPTH_COMPONENT,  GL_UNSIGNED_BYTE, NULL);
 * glBindTexture(GL_TEXTURE_2D, 0);
 *
 * // Build the framebuffer.
 * let framebuffer: GLuint;
 * glGenFramebuffers(1, framebuffer);
 * glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);
 * glFramebufferTexture2D(GL_FRAMEBUFFER,  GL_COLOR_ATTACHMENT0,  GL_TEXTURE_2D, texture_map, 0);
 * glFramebufferTexture2D(GL_FRAMEBUFFER,  GL_DEPTH_ATTACHMENT,  GL_TEXTURE_2D, depth_texture, 0);
 *
 * let status: GLenum = glCheckFramebufferStatus(GL_FRAMEBUFFER);
 * if (status !=  GL_FRAMEBUFFER_COMPLETE)
 *     // Error
 *
 * glBindFramebuffer(GL_FRAMEBUFFER, 0);
 * ```
 *
 * @example Create a texture object with linear mipmaps and edge clamping.
 * ```
 * let texture_id: GLuint;
 * glGenTextures(1, texture_id);
 * glBindTexture(GL_TEXTURE_2D, texture_id);
 *
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
 *
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
 *
 * // texture_data is the source data of your texture, in this case
 * // its size is sizeof(unsigned char) * texture_width * texture_height * 4
 * glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, texture_width, texture_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, texture_data);
 * glGenerateMipmap(GL_TEXTURE_2D); // Unavailable in OpenGL 2.1, use gluBuild2DMipmaps() instead
 *
 * glBindTexture(GL_TEXTURE_2D, 0);
 * ```
 *
 * @tutorial [Songho - OpenGL Frame Buffer Object (FBO)](https://www.songho.ca/opengl/gl_fbo.html)
 * @tutorial [open.gl - Framebuffers](https://open.gl/framebuffers)
 * @tutorial [open.gl - Textures Objects and Parameters](https://open.gl/textures)
 * @tutorial [opengl-tutorial.org - Tutorial 14 : Render To Texture](https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-14-render-to-texture/)
 * @tutorial [opengl-tutorial.org - Tutorial 16 : Shadow mapping](https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/)
 * @tutorial [opengl-tutorial.org - Tutorial 5 : A Textured Cube](https://www.opengl-tutorial.org/beginners-tutorials/tutorial-5-a-textured-cube/)
 * @see [glTexParameter](https://docs.gl/gl3/glTexParameter)
 */
export function glTexParameterf(
	target: GLenum,
	pname: GLenum,
	param: GLfloat
): void;

/**
 * `glTexParameter` assigns the value or values in **params** to the texture parameter specified as **pname**. **target** defines the target texture, either {@link GL_TEXTURE_1D}, {@link GL_TEXTURE_2D}, {@link GL_TEXTURE_1D_ARRAY}, {@link GL_TEXTURE_2D_ARRAY}, {@link GL_TEXTURE_RECTANGLE}, or {@link GL_TEXTURE_3D}. The following symbols are accepted in **pname**:
 *
 * - {@link GL_TEXTURE_BASE_LEVEL}
 * Specifies the index of the lowest defined mipmap level. This is an integer value. The initial value is 0.
 *
 * - {@link GL_TEXTURE_BORDER_COLOR}
 * The data in **params** specifies four values that define the border values that should be used for border texels. If a texel is sampled from the border of the texture, the values of {@link GL_TEXTURE_BORDER_COLOR} are interpreted as an RGBA color to match the texture's internal format and substituted for the non-existent texel data. If the texture contains depth components, the first component of {@link GL_TEXTURE_BORDER_COLOR} is interpreted as a depth value. The initial value is (0.0,0.0,0.0,0.0).
 *  If the values for {@link GL_TEXTURE_BORDER_COLOR} are specified with `glTexParameterIiv` or `glTexParameterIuiv`, the values are stored unmodified with an internal data type of integer. If specified with `glTexParameteriv`, they are converted to floating point with the following equation: 𝐟 = 2𝑐 + 1 / 2ᵇ − 1. If specified with `glTexParameterfv`, they are stored unmodified as floating-point values.
 *
 * - {@link GL_TEXTURE_COMPARE_FUNC}
 * Specifies the comparison operator used when {@link GL_TEXTURE_COMPARE_MODE} is set to {@link GL_COMPARE_REF_TO_TEXTURE}. Permissible values are:
 *
 * | **Texture Comparison Function** | **Computed result**   |
 * | :------------------------------ | :-------------------- |
 * |                                 |ㅤㅤㅤㅤ⎧ 1.0𝐫 <= 𝐃ₜ     |
 * | {@link GL_LEQUAL}               | result = ⎨            |
 * |                                 |ㅤㅤㅤㅤ⎩ 0.0𝐫 > 𝐃ₜ      |
 * |                                 |ㅤㅤㅤㅤ⎧ 1.0𝐫 >= 𝐃ₜ     |
 * | {@link GL_GEQUAL}               | result = ⎨            |
 * |                                 |ㅤㅤㅤㅤ⎩ 0.0𝐫 < 𝐃ₜ      |
 * |                                 |ㅤㅤㅤㅤ⎧ 1.0𝐫 < 𝐃ₜ      |
 * | {@link GL_LESS}                 | result = ⎨            |
 * |                                 |ㅤㅤㅤㅤ⎩ 0.0𝐫 >= 𝐃ₜ     |
 * |                                 |ㅤㅤㅤㅤ⎧ 1.0𝐫 > 𝐃ₜ      |
 * | {@link GL_GREATER}              | result = ⎨            |
 * |                                 |ㅤㅤㅤㅤ⎩ 0.0𝐫 <= 𝐃ₜ     |
 * |                                 |ㅤㅤㅤㅤ⎧ 1.0𝐫 = 𝐃ₜ      |
 * | {@link GL_EQUAL}                | result = ⎨            |
 * |                                 |ㅤㅤㅤㅤ⎩ 0.0𝐫 ≠ 𝐃ₜ     |
 * |                                 |ㅤㅤㅤㅤ⎧ 1.0𝐫 ≠ 𝐃ₜ     |
 * | {@link GL_NOTEQUAL}             | result = ⎨            |
 * |                                 |ㅤㅤㅤㅤ⎩ 0.0𝐫 = 𝐃ₜ      |
 * | {@link GL_ALWAYS}               | result = 1.0          |
 * | {@link GL_NEVER}                | result = 0.0          |
 *
 * where 𝐫 is the current interpolated texture coordinate, and 𝐃ₜ is the depth texture value sampled from the currently bound depth texture. *result* is assigned to the the red channel.
 *
 * - {@link GL_TEXTURE_COMPARE_MODE}
 * Specifies the texture comparison mode for currently bound depth textures. That is, a texture whose internal format is {@link GL_DEPTH_COMPONENT_*}; see {@link glTexImage2D}) Permissible values are:
 * - - {@link GL_COMPARE_REF_TO_TEXTURE} Specifies that the interpolated and clamped 𝐫 texture coordinate should be compared to the value in the currently bound depth texture. See the discussion of {@link GL_TEXTURE_COMPARE_FUNC} for details of how the comparison is evaluated. The result of the comparison is assigned to the red channel.
 * - - {@link GL_NONE} Specifies that the red channel should be assigned the appropriate value from the currently bound depth texture.
 *
 * - {@link GL_TEXTURE_LOD_BIAS}
 * **params** specifies a fixed bias value that is to be added to the level-of-detail parameter for the texture before texture sampling. The specified value is added to the shader-supplied bias value (if any) and subsequently clamped into the implementation-defined range [−biasₘₐₓ, biasₘₐₓ], where biasₘₐₓ is the value of the implementation defined constant {@link GL_MAX_TEXTURE_LOD_BIAS}. The initial value is 0.0.
 *
 * - {@link GL_TEXTURE_MIN_FILTER}
 *
 * The texture minifying function is used whenever the level-of-detail function used when sampling from the texture determines that the texture should be minified. There are six defined minifying functions. Two of them use either the nearest texture elements or a weighted average of multiple texture elements to compute the texture value. The other four use mipmaps.
 *
 * A mipmap is an ordered set of arrays representing the same image at progressively lower resolutions. If the texture has dimensions 2ⁿ × 2ᵐ, there are max(𝐧, 𝐦) + 1 mipmaps. The first mipmap is the original texture, with dimensions 2ⁿ × 2ᵐ. Each subsequent mipmap has dimensions 2ᵏ⁻¹ 2ᶩ⁻¹, where 2ᵏ × 2ᶩ are the dimensions of the previous mipmap, until either 𝐤 = 0 or 𝐥 = 0. At that point, subsequent mipmaps have dimension 1 × 2ᶩ⁻¹ or 2ᵏ⁻¹ × 1 until the final mipmap, which has dimension 1 × 1. To define the mipmaps, call {@link glTexImage1D}, {@link glTexImage2D}, {@link glTexImage3D}, {@link glCopyTexImage1D}, or {@link glCopyTexImage2D} with the **level** argument indicating the order of the mipmaps. Level 0 is the original texture; level max(𝐧, 𝐦) is the final 1 × 1 mipmap.
 *
 * **params** supplies a function for minifying the texture as one of the following:
 *
 * - - {@link GL_NEAREST}
 * Returns the value of the texture element that is nearest (in Manhattan distance) to the specified texture coordinates.
 *
 * - - {@link GL_LINEAR}
 * Returns the weighted average of the four texture elements that are closest to the specified texture coordinates. These can include items wrapped or repeated from other parts of a texture, depending on the values of {@link GL_TEXTURE_WRAP_S} and {@link GL_TEXTURE_WRAP_T}, and on the exact mapping.
 *
 * - - {@link GL_NEAREST_MIPMAP_NEAREST}
 * Chooses the mipmap that most closely matches the size of the pixel being textured and uses the {@link GL_NEAREST} criterion (the texture element closest to the specified texture coordinates) to produce a texture value.
 *
 * - - {@link GL_LINEAR_MIPMAP_NEAREST}
 * Chooses the mipmap that most closely matches the size of the pixel being textured and uses the {@link GL_LINEAR} criterion (a weighted average of the four texture elements that are closest to the specified texture coordinates) to produce a texture value.
 *
 * - - {@link GL_NEAREST_MIPMAP_LINEAR}
 * Chooses the two mipmaps that most closely match the size of the pixel being textured and uses the {@link GL_NEAREST} criterion (the texture element closest to the specified texture coordinates ) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values.
 *
 * - - {@link GL_LINEAR_MIPMAP_LINEAR}
 * Chooses the two mipmaps that most closely match the size of the pixel being textured and uses the {@link GL_LINEAR} criterion (a weighted average of the texture elements that are closest to the specified texture coordinates) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values.
 *
 * As more texture elements are sampled in the minification process, fewer aliasing artifacts will be apparent. While the {@link GL_NEAREST} and {@link GL_LINEAR} minification functions can be faster than the other four, they sample only one or multiple texture elements to determine the texture value of the pixel being rendered and can produce moire patterns or ragged transitions. The initial value of {@link GL_TEXTURE_MIN_FILTER} is {@link GL_NEAREST_MIPMAP_LINEAR}.
 *
 * - {@link GL_TEXTURE_MAG_FILTER}
 * The texture magnification function is used whenever the level-of-detail function used when sampling from the texture determines that the texture should be magified. It sets the texture magnification function to either {@link GL_NEAREST} or {@link GL_LINEAR} (see below). {@link GL_NEAREST} is generally faster than {@link GL_LINEAR}, but it can produce textured images with sharper edges because the transition between texture elements is not as smooth. The initial value of {@link GL_TEXTURE_MAG_FILTER} is {@link GL_LINEAR}.
 *
 * - - {@link GL_NEAREST}
 * Returns the value of the texture element that is nearest (in Manhattan distance) to the specified texture coordinates.
 *
 * - - {@link GL_LINEAR}
 * Returns the weighted average of the texture elements that are closest to the specified texture coordinates. These can include items wrapped or repeated from other parts of a texture, depending on the values of {@link GL_TEXTURE_WRAP_S} and {@link GL_TEXTURE_WRAP_T}, and on the exact mapping.
 *
 * - {@link GL_TEXTURE_MIN_LOD}
 * Sets the minimum level-of-detail parameter. This floating-point value limits the selection of highest resolution mipmap (lowest mipmap level). The initial value is -1000.
 *
 * - {@link GL_TEXTURE_MAX_LOD}
 * Sets the maximum level-of-detail parameter. This floating-point value limits the selection of the lowest resolution mipmap (highest mipmap level). The initial value is 1000.
 *
 * - {@link GL_TEXTURE_MAX_LEVEL}
 * Sets the index of the highest defined mipmap level. This is an integer value. The initial value is 1000.
 *
 * - {@link GL_TEXTURE_SWIZZLE_R}
 * Sets the swizzle that will be applied to the 𝐫 component of a texel before it is returned to the shader. Valid values for **param** are {@link GL_RED}, {@link GL_GREEN}, {@link GL_BLUE}, {@link GL_ALPHA}, {@link GL_ZERO} and {@link GL_ONE}. If {@link GL_TEXTURE_SWIZZLE_R} is {@link GL_RED}, the value for 𝐫 will be taken from the first channel of the fetched texel. If {@link GL_TEXTURE_SWIZZLE_R} is {@link GL_GREEN}, the value for 𝐫 will be taken from the second channel of the fetched texel. If {@link GL_TEXTURE_SWIZZLE_R} is {@link GL_BLUE}, the value for 𝐫 will be taken from the third channel of the fetched texel. If {@link GL_TEXTURE_SWIZZLE_R} is {@link GL_ALPHA}, the value for 𝐫 will be taken from the fourth channel of the fetched texel. If {@link GL_TEXTURE_SWIZZLE_R} is {@link GL_ZERO}, the value for 𝐫 will be subtituted with 0.0. If {@link GL_TEXTURE_SWIZZLE_R} is {@link GL_ONE}, the value for 𝐫 will be subtituted with 1.0. The initial value is {@link GL_RED}.
 *
 * - {@link GL_TEXTURE_SWIZZLE_G}
 * Sets the swizzle that will be applied to the 𝐠 component of a texel before it is returned to the shader. Valid values for **param** and their effects are similar to those of {@link GL_TEXTURE_SWIZZLE_R}. The initial value is {@link GL_GREEN}.
 *
 * - {@link GL_TEXTURE_SWIZZLE_B}
 * Sets the swizzle that will be applied to the 𝐛 component of a texel before it is returned to the shader. Valid values for **param** and their effects are similar to those of {@link GL_TEXTURE_SWIZZLE_R}. The initial value is {@link GL_BLUE}.
 *
 * - {@link GL_TEXTURE_SWIZZLE_A}
 * Sets the swizzle that will be applied to the 𝐚 component of a texel before it is returned to the shader. Valid values for **param** and their effects are similar to those of {@link GL_TEXTURE_SWIZZLE_R}. The initial value is {@link GL_ALPHA}.
 *
 * - {@link GL_TEXTURE_SWIZZLE_RGBA}
 * Sets the swizzles that will be applied to the 𝐫, 𝐠, 𝐛, and 𝐚 components of a texel before they are returned to the shader. Valid values for **params** and their effects are similar to those of {@link GL_TEXTURE_SWIZZLE_R}, except that all channels are specified simultaneously. Setting the value of {@link GL_TEXTURE_SWIZZLE_RGBA} is equivalent (assuming no errors are generated) to setting the parameters of each of {@link GL_TEXTURE_SWIZZLE_R}, {@link GL_TEXTURE_SWIZZLE_G}, {@link GL_TEXTURE_SWIZZLE_B}, and {@link GL_TEXTURE_SWIZZLE_A} successively.
 *
 * - {@link GL_TEXTURE_WRAP_S}
 * Sets the wrap parameter for texture coordinate 𝐬 to either {@link GL_CLAMP_TO_EDGE}, {@link GL_CLAMP_TO_BORDER}, {@link GL_MIRRORED_REPEAT}, or {@link GL_REPEAT}. {@link GL_CLAMP_TO_EDGE} causes 𝐬 coordinates to be clamped to the range [1/2𝐍, 1 − 1/2𝐍], where 𝐍 is the size of the texture in the direction of clamping. {@link GL_CLAMP_TO_BORDER} evaluates 𝐬 coordinates in a similar manner to {@link GL_CLAMP_TO_EDGE}. However, in cases where clamping would have occurred in {@link GL_CLAMP_TO_EDGE} mode, the fetched texel data is substituted with the values specified by {@link GL_TEXTURE_BORDER_COLOR}. {@link GL_REPEAT} causes the integer part of the 𝐬 coordinate to be ignored; the GL uses only the fractional part, thereby creating a repeating pattern. {@link GL_MIRRORED_REPEAT} causes the 𝐬 coordinate to be set to the fractional part of the texture coordinate if the integer part of 𝐬 is even; if the integer part of 𝐬 is odd, then the 𝐬 texture coordinate is set to 1 − frac(𝐬), where frac(𝐬) represents the fractional part of 𝐬. Initially, {@link GL_TEXTURE_WRAP_S} is set to {@link GL_REPEAT}.
 *
 * - {@link GL_TEXTURE_WRAP_T}
 * Sets the wrap parameter for texture coordinate 𝐭 to either {@link GL_CLAMP_TO_EDGE}, {@link GL_CLAMP_TO_BORDER}, {@link GL_MIRRORED_REPEAT}, or {@link GL_REPEAT}. See the discussion under {@link GL_TEXTURE_WRAP_S}. Initially, {@link GL_TEXTURE_WRAP_T} is set to {@link GL_REPEAT}.
 *
 * - {@link GL_TEXTURE_WRAP_R}
 *  Sets the wrap parameter for texture coordinate 𝐫 to either {@link GL_CLAMP_TO_EDGE}, {@link GL_CLAMP_TO_BORDER}, {@link GL_MIRRORED_REPEAT}, or {@link GL_REPEAT}. See the discussion under {@link GL_TEXTURE_WRAP_S}. Initially, {@link GL_TEXTURE_WRAP_R} is set to {@link GL_REPEAT}.
 *
 * @summary set texture parameters
 * @param target Specifies the target texture, which must be either {@link GL_TEXTURE_1D}, {@link GL_TEXTURE_2D}, {@link GL_TEXTURE_3D}, {@link GL_TEXTURE_1D_ARRAY}, {@link GL_TEXTURE_2D_ARRAY}, {@link GL_TEXTURE_RECTANGLE}, or {@link GL_TEXTURE_CUBE_MAP}.
 * @param pname Specifies the symbolic name of a single-valued texture parameter. **pname** can be one of the following: {@link GL_TEXTURE_BASE_LEVEL}, {@link GL_TEXTURE_COMPARE_FUNC}, {@link GL_TEXTURE_COMPARE_MODE}, {@link GL_TEXTURE_LOD_BIAS}, {@link GL_TEXTURE_MIN_FILTER}, {@link GL_TEXTURE_MAG_FILTER}, {@link GL_TEXTURE_MIN_LOD}, {@link GL_TEXTURE_MAX_LOD}, {@link GL_TEXTURE_MAX_LEVEL}, {@link GL_TEXTURE_SWIZZLE_R}, {@link GL_TEXTURE_SWIZZLE_G}, {@link GL_TEXTURE_SWIZZLE_B}, {@link GL_TEXTURE_SWIZZLE_A}, {@link GL_TEXTURE_WRAP_S}, {@link GL_TEXTURE_WRAP_T}, or {@link GL_TEXTURE_WRAP_R}.
 * @param param Specifies the value of **pname**.
 * @example Create a framebuffer object with a texture-based color attachment and a texture-based depth attachment. Using texture-based attachments allows sampling of those textures in shaders.
 * ```
 * // fbo_width and fbo_height are the desired width and height of the FBO.
 * // For Opengl <= 4.4 or if the  GL_ARB_texture_non_power_of_two extension
 * // is present, fbo_width and fbo_height can be values other than 2^n for
 * // some integer n.
 *
 * // Build the texture that will serve as the color attachment for the framebuffer.
 * let texture_map: GLuint;
 * glGenTextures(1, texture_map);
 * glBindTexture(GL_TEXTURE_2D, texture_map);
 *
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_MIN_FILTER,  GL_LINEAR);
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_MAG_FILTER,  GL_LINEAR);
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_WRAP_S,  GL_CLAMP_TO_BORDER);
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_WRAP_T,  GL_CLAMP_TO_BORDER);
 *
 * glTexImage2D(GL_TEXTURE_2D, 0,  GL_RGBA, fbo_width, fbo_height, 0,  GL_RGBA,  GL_UNSIGNED_BYTE, NULL);
 *
 * glBindTexture(GL_TEXTURE_2D, 0);
 *
 * // Build the texture that will serve as the depth attachment for the framebuffer.
 * let depth_texture: GLuint;
 * glGenTextures(1, depth_texture);
 * glBindTexture(GL_TEXTURE_2D, depth_texture);
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_MIN_FILTER,  GL_NEAREST);
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_MAG_FILTER,  GL_NEAREST);
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_WRAP_S,  GL_CLAMP_TO_EDGE);
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_WRAP_T,  GL_CLAMP_TO_EDGE);
 * glTexImage2D(GL_TEXTURE_2D, 0,  GL_DEPTH_COMPONENT, fbo_width, fbo_height, 0,  GL_DEPTH_COMPONENT,  GL_UNSIGNED_BYTE, NULL);
 * glBindTexture(GL_TEXTURE_2D, 0);
 *
 * // Build the framebuffer.
 * let framebuffer: GLuint;
 * glGenFramebuffers(1, framebuffer);
 * glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);
 * glFramebufferTexture2D(GL_FRAMEBUFFER,  GL_COLOR_ATTACHMENT0,  GL_TEXTURE_2D, texture_map, 0);
 * glFramebufferTexture2D(GL_FRAMEBUFFER,  GL_DEPTH_ATTACHMENT,  GL_TEXTURE_2D, depth_texture, 0);
 *
 * let status: GLenum = glCheckFramebufferStatus(GL_FRAMEBUFFER);
 * if (status !=  GL_FRAMEBUFFER_COMPLETE)
 *     // Error
 *
 * glBindFramebuffer(GL_FRAMEBUFFER, 0);
 * ```
 *
 * @example Create a texture object with linear mipmaps and edge clamping.
 * ```
 * let texture_id: GLuint;
 * glGenTextures(1, texture_id);
 * glBindTexture(GL_TEXTURE_2D, texture_id);
 *
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
 *
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
 *
 * // texture_data is the source data of your texture, in this case
 * // its size is sizeof(unsigned char) * texture_width * texture_height * 4
 * glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, texture_width, texture_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, texture_data);
 * glGenerateMipmap(GL_TEXTURE_2D); // Unavailable in OpenGL 2.1, use gluBuild2DMipmaps() instead
 *
 * glBindTexture(GL_TEXTURE_2D, 0);
 * ```
 *
 * @tutorial [Songho - OpenGL Frame Buffer Object (FBO)](https://www.songho.ca/opengl/gl_fbo.html)
 * @tutorial [open.gl - Framebuffers](https://open.gl/framebuffers)
 * @tutorial [open.gl - Textures Objects and Parameters](https://open.gl/textures)
 * @tutorial [opengl-tutorial.org - Tutorial 14 : Render To Texture](https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-14-render-to-texture/)
 * @tutorial [opengl-tutorial.org - Tutorial 16 : Shadow mapping](https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/)
 * @tutorial [opengl-tutorial.org - Tutorial 5 : A Textured Cube](https://www.opengl-tutorial.org/beginners-tutorials/tutorial-5-a-textured-cube/)
 * @see [glTexParameter](https://docs.gl/gl3/glTexParameter)
 */
export function glTexParameteri(
	target: GLenum,
	pname: GLenum,
	param: GLint
): void;

/**
 * `glTexParameter` assigns the value or values in **params** to the texture parameter specified as **pname**. **target** defines the target texture, either {@link GL_TEXTURE_1D}, {@link GL_TEXTURE_2D}, {@link GL_TEXTURE_1D_ARRAY}, {@link GL_TEXTURE_2D_ARRAY}, {@link GL_TEXTURE_RECTANGLE}, or {@link GL_TEXTURE_3D}. The following symbols are accepted in **pname**:
 *
 * - {@link GL_TEXTURE_BASE_LEVEL}
 * Specifies the index of the lowest defined mipmap level. This is an integer value. The initial value is 0.
 *
 * - {@link GL_TEXTURE_BORDER_COLOR}
 * The data in **params** specifies four values that define the border values that should be used for border texels. If a texel is sampled from the border of the texture, the values of {@link GL_TEXTURE_BORDER_COLOR} are interpreted as an RGBA color to match the texture's internal format and substituted for the non-existent texel data. If the texture contains depth components, the first component of {@link GL_TEXTURE_BORDER_COLOR} is interpreted as a depth value. The initial value is (0.0,0.0,0.0,0.0).
 *  If the values for {@link GL_TEXTURE_BORDER_COLOR} are specified with `glTexParameterIiv` or `glTexParameterIuiv`, the values are stored unmodified with an internal data type of integer. If specified with `glTexParameteriv`, they are converted to floating point with the following equation: 𝐟 = 2𝑐 + 1 / 2ᵇ − 1. If specified with `glTexParameterfv`, they are stored unmodified as floating-point values.
 *
 * - {@link GL_TEXTURE_COMPARE_FUNC}
 * Specifies the comparison operator used when {@link GL_TEXTURE_COMPARE_MODE} is set to {@link GL_COMPARE_REF_TO_TEXTURE}. Permissible values are:
 *
 * | **Texture Comparison Function** | **Computed result**   |
 * | :------------------------------ | :-------------------- |
 * |                                 |ㅤㅤㅤㅤ⎧ 1.0𝐫 <= 𝐃ₜ     |
 * | {@link GL_LEQUAL}               | result = ⎨            |
 * |                                 |ㅤㅤㅤㅤ⎩ 0.0𝐫 > 𝐃ₜ      |
 * |                                 |ㅤㅤㅤㅤ⎧ 1.0𝐫 >= 𝐃ₜ     |
 * | {@link GL_GEQUAL}               | result = ⎨            |
 * |                                 |ㅤㅤㅤㅤ⎩ 0.0𝐫 < 𝐃ₜ      |
 * |                                 |ㅤㅤㅤㅤ⎧ 1.0𝐫 < 𝐃ₜ      |
 * | {@link GL_LESS}                 | result = ⎨            |
 * |                                 |ㅤㅤㅤㅤ⎩ 0.0𝐫 >= 𝐃ₜ     |
 * |                                 |ㅤㅤㅤㅤ⎧ 1.0𝐫 > 𝐃ₜ      |
 * | {@link GL_GREATER}              | result = ⎨            |
 * |                                 |ㅤㅤㅤㅤ⎩ 0.0𝐫 <= 𝐃ₜ     |
 * |                                 |ㅤㅤㅤㅤ⎧ 1.0𝐫 = 𝐃ₜ      |
 * | {@link GL_EQUAL}                | result = ⎨            |
 * |                                 |ㅤㅤㅤㅤ⎩ 0.0𝐫 ≠ 𝐃ₜ     |
 * |                                 |ㅤㅤㅤㅤ⎧ 1.0𝐫 ≠ 𝐃ₜ     |
 * | {@link GL_NOTEQUAL}             | result = ⎨            |
 * |                                 |ㅤㅤㅤㅤ⎩ 0.0𝐫 = 𝐃ₜ      |
 * | {@link GL_ALWAYS}               | result = 1.0          |
 * | {@link GL_NEVER}                | result = 0.0          |
 *
 * where 𝐫 is the current interpolated texture coordinate, and 𝐃ₜ is the depth texture value sampled from the currently bound depth texture. *result* is assigned to the the red channel.
 *
 * - {@link GL_TEXTURE_COMPARE_MODE}
 * Specifies the texture comparison mode for currently bound depth textures. That is, a texture whose internal format is {@link GL_DEPTH_COMPONENT_*}; see {@link glTexImage2D}) Permissible values are:
 * - - {@link GL_COMPARE_REF_TO_TEXTURE} Specifies that the interpolated and clamped 𝐫 texture coordinate should be compared to the value in the currently bound depth texture. See the discussion of {@link GL_TEXTURE_COMPARE_FUNC} for details of how the comparison is evaluated. The result of the comparison is assigned to the red channel.
 * - - {@link GL_NONE} Specifies that the red channel should be assigned the appropriate value from the currently bound depth texture.
 *
 * - {@link GL_TEXTURE_LOD_BIAS}
 * **params** specifies a fixed bias value that is to be added to the level-of-detail parameter for the texture before texture sampling. The specified value is added to the shader-supplied bias value (if any) and subsequently clamped into the implementation-defined range [−biasₘₐₓ, biasₘₐₓ], where biasₘₐₓ is the value of the implementation defined constant {@link GL_MAX_TEXTURE_LOD_BIAS}. The initial value is 0.0.
 *
 * - {@link GL_TEXTURE_MIN_FILTER}
 *
 * The texture minifying function is used whenever the level-of-detail function used when sampling from the texture determines that the texture should be minified. There are six defined minifying functions. Two of them use either the nearest texture elements or a weighted average of multiple texture elements to compute the texture value. The other four use mipmaps.
 *
 * A mipmap is an ordered set of arrays representing the same image at progressively lower resolutions. If the texture has dimensions 2ⁿ × 2ᵐ, there are max(𝐧, 𝐦) + 1 mipmaps. The first mipmap is the original texture, with dimensions 2ⁿ × 2ᵐ. Each subsequent mipmap has dimensions 2ᵏ⁻¹ 2ᶩ⁻¹, where 2ᵏ × 2ᶩ are the dimensions of the previous mipmap, until either 𝐤 = 0 or 𝐥 = 0. At that point, subsequent mipmaps have dimension 1 × 2ᶩ⁻¹ or 2ᵏ⁻¹ × 1 until the final mipmap, which has dimension 1 × 1. To define the mipmaps, call {@link glTexImage1D}, {@link glTexImage2D}, {@link glTexImage3D}, {@link glCopyTexImage1D}, or {@link glCopyTexImage2D} with the **level** argument indicating the order of the mipmaps. Level 0 is the original texture; level max(𝐧, 𝐦) is the final 1 × 1 mipmap.
 *
 * **params** supplies a function for minifying the texture as one of the following:
 *
 * - - {@link GL_NEAREST}
 * Returns the value of the texture element that is nearest (in Manhattan distance) to the specified texture coordinates.
 *
 * - - {@link GL_LINEAR}
 * Returns the weighted average of the four texture elements that are closest to the specified texture coordinates. These can include items wrapped or repeated from other parts of a texture, depending on the values of {@link GL_TEXTURE_WRAP_S} and {@link GL_TEXTURE_WRAP_T}, and on the exact mapping.
 *
 * - - {@link GL_NEAREST_MIPMAP_NEAREST}
 * Chooses the mipmap that most closely matches the size of the pixel being textured and uses the {@link GL_NEAREST} criterion (the texture element closest to the specified texture coordinates) to produce a texture value.
 *
 * - - {@link GL_LINEAR_MIPMAP_NEAREST}
 * Chooses the mipmap that most closely matches the size of the pixel being textured and uses the {@link GL_LINEAR} criterion (a weighted average of the four texture elements that are closest to the specified texture coordinates) to produce a texture value.
 *
 * - - {@link GL_NEAREST_MIPMAP_LINEAR}
 * Chooses the two mipmaps that most closely match the size of the pixel being textured and uses the {@link GL_NEAREST} criterion (the texture element closest to the specified texture coordinates ) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values.
 *
 * - - {@link GL_LINEAR_MIPMAP_LINEAR}
 * Chooses the two mipmaps that most closely match the size of the pixel being textured and uses the {@link GL_LINEAR} criterion (a weighted average of the texture elements that are closest to the specified texture coordinates) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values.
 *
 * As more texture elements are sampled in the minification process, fewer aliasing artifacts will be apparent. While the {@link GL_NEAREST} and {@link GL_LINEAR} minification functions can be faster than the other four, they sample only one or multiple texture elements to determine the texture value of the pixel being rendered and can produce moire patterns or ragged transitions. The initial value of {@link GL_TEXTURE_MIN_FILTER} is {@link GL_NEAREST_MIPMAP_LINEAR}.
 *
 * - {@link GL_TEXTURE_MAG_FILTER}
 * The texture magnification function is used whenever the level-of-detail function used when sampling from the texture determines that the texture should be magified. It sets the texture magnification function to either {@link GL_NEAREST} or {@link GL_LINEAR} (see below). {@link GL_NEAREST} is generally faster than {@link GL_LINEAR}, but it can produce textured images with sharper edges because the transition between texture elements is not as smooth. The initial value of {@link GL_TEXTURE_MAG_FILTER} is {@link GL_LINEAR}.
 *
 * - - {@link GL_NEAREST}
 * Returns the value of the texture element that is nearest (in Manhattan distance) to the specified texture coordinates.
 *
 * - - {@link GL_LINEAR}
 * Returns the weighted average of the texture elements that are closest to the specified texture coordinates. These can include items wrapped or repeated from other parts of a texture, depending on the values of {@link GL_TEXTURE_WRAP_S} and {@link GL_TEXTURE_WRAP_T}, and on the exact mapping.
 *
 * - {@link GL_TEXTURE_MIN_LOD}
 * Sets the minimum level-of-detail parameter. This floating-point value limits the selection of highest resolution mipmap (lowest mipmap level). The initial value is -1000.
 *
 * - {@link GL_TEXTURE_MAX_LOD}
 * Sets the maximum level-of-detail parameter. This floating-point value limits the selection of the lowest resolution mipmap (highest mipmap level). The initial value is 1000.
 *
 * - {@link GL_TEXTURE_MAX_LEVEL}
 * Sets the index of the highest defined mipmap level. This is an integer value. The initial value is 1000.
 *
 * - {@link GL_TEXTURE_SWIZZLE_R}
 * Sets the swizzle that will be applied to the 𝐫 component of a texel before it is returned to the shader. Valid values for **param** are {@link GL_RED}, {@link GL_GREEN}, {@link GL_BLUE}, {@link GL_ALPHA}, {@link GL_ZERO} and {@link GL_ONE}. If {@link GL_TEXTURE_SWIZZLE_R} is {@link GL_RED}, the value for 𝐫 will be taken from the first channel of the fetched texel. If {@link GL_TEXTURE_SWIZZLE_R} is {@link GL_GREEN}, the value for 𝐫 will be taken from the second channel of the fetched texel. If {@link GL_TEXTURE_SWIZZLE_R} is {@link GL_BLUE}, the value for 𝐫 will be taken from the third channel of the fetched texel. If {@link GL_TEXTURE_SWIZZLE_R} is {@link GL_ALPHA}, the value for 𝐫 will be taken from the fourth channel of the fetched texel. If {@link GL_TEXTURE_SWIZZLE_R} is {@link GL_ZERO}, the value for 𝐫 will be subtituted with 0.0. If {@link GL_TEXTURE_SWIZZLE_R} is {@link GL_ONE}, the value for 𝐫 will be subtituted with 1.0. The initial value is {@link GL_RED}.
 *
 * - {@link GL_TEXTURE_SWIZZLE_G}
 * Sets the swizzle that will be applied to the 𝐠 component of a texel before it is returned to the shader. Valid values for **param** and their effects are similar to those of {@link GL_TEXTURE_SWIZZLE_R}. The initial value is {@link GL_GREEN}.
 *
 * - {@link GL_TEXTURE_SWIZZLE_B}
 * Sets the swizzle that will be applied to the 𝐛 component of a texel before it is returned to the shader. Valid values for **param** and their effects are similar to those of {@link GL_TEXTURE_SWIZZLE_R}. The initial value is {@link GL_BLUE}.
 *
 * - {@link GL_TEXTURE_SWIZZLE_A}
 * Sets the swizzle that will be applied to the 𝐚 component of a texel before it is returned to the shader. Valid values for **param** and their effects are similar to those of {@link GL_TEXTURE_SWIZZLE_R}. The initial value is {@link GL_ALPHA}.
 *
 * - {@link GL_TEXTURE_SWIZZLE_RGBA}
 * Sets the swizzles that will be applied to the 𝐫, 𝐠, 𝐛, and 𝐚 components of a texel before they are returned to the shader. Valid values for **params** and their effects are similar to those of {@link GL_TEXTURE_SWIZZLE_R}, except that all channels are specified simultaneously. Setting the value of {@link GL_TEXTURE_SWIZZLE_RGBA} is equivalent (assuming no errors are generated) to setting the parameters of each of {@link GL_TEXTURE_SWIZZLE_R}, {@link GL_TEXTURE_SWIZZLE_G}, {@link GL_TEXTURE_SWIZZLE_B}, and {@link GL_TEXTURE_SWIZZLE_A} successively.
 *
 * - {@link GL_TEXTURE_WRAP_S}
 * Sets the wrap parameter for texture coordinate 𝐬 to either {@link GL_CLAMP_TO_EDGE}, {@link GL_CLAMP_TO_BORDER}, {@link GL_MIRRORED_REPEAT}, or {@link GL_REPEAT}. {@link GL_CLAMP_TO_EDGE} causes 𝐬 coordinates to be clamped to the range [1/2𝐍, 1 − 1/2𝐍], where 𝐍 is the size of the texture in the direction of clamping. {@link GL_CLAMP_TO_BORDER} evaluates 𝐬 coordinates in a similar manner to {@link GL_CLAMP_TO_EDGE}. However, in cases where clamping would have occurred in {@link GL_CLAMP_TO_EDGE} mode, the fetched texel data is substituted with the values specified by {@link GL_TEXTURE_BORDER_COLOR}. {@link GL_REPEAT} causes the integer part of the 𝐬 coordinate to be ignored; the GL uses only the fractional part, thereby creating a repeating pattern. {@link GL_MIRRORED_REPEAT} causes the 𝐬 coordinate to be set to the fractional part of the texture coordinate if the integer part of 𝐬 is even; if the integer part of 𝐬 is odd, then the 𝐬 texture coordinate is set to 1 − frac(𝐬), where frac(𝐬) represents the fractional part of 𝐬. Initially, {@link GL_TEXTURE_WRAP_S} is set to {@link GL_REPEAT}.
 *
 * - {@link GL_TEXTURE_WRAP_T}
 * Sets the wrap parameter for texture coordinate 𝐭 to either {@link GL_CLAMP_TO_EDGE}, {@link GL_CLAMP_TO_BORDER}, {@link GL_MIRRORED_REPEAT}, or {@link GL_REPEAT}. See the discussion under {@link GL_TEXTURE_WRAP_S}. Initially, {@link GL_TEXTURE_WRAP_T} is set to {@link GL_REPEAT}.
 *
 * - {@link GL_TEXTURE_WRAP_R}
 *  Sets the wrap parameter for texture coordinate 𝐫 to either {@link GL_CLAMP_TO_EDGE}, {@link GL_CLAMP_TO_BORDER}, {@link GL_MIRRORED_REPEAT}, or {@link GL_REPEAT}. See the discussion under {@link GL_TEXTURE_WRAP_S}. Initially, {@link GL_TEXTURE_WRAP_R} is set to {@link GL_REPEAT}.
 *
 * @summary set texture parameters
 * @param target Specifies the target texture, which must be either {@link GL_TEXTURE_1D}, {@link GL_TEXTURE_2D}, {@link GL_TEXTURE_3D}, {@link GL_TEXTURE_1D_ARRAY}, {@link GL_TEXTURE_2D_ARRAY}, {@link GL_TEXTURE_RECTANGLE}, or {@link GL_TEXTURE_CUBE_MAP}.
 * @param pname Specifies the symbolic name of a texture parameter. **pname** can be one of the following: {@link GL_TEXTURE_BASE_LEVEL}, {@link GL_TEXTURE_BORDER_COLOR}, {@link GL_TEXTURE_COMPARE_FUNC}, {@link GL_TEXTURE_COMPARE_MODE}, {@link GL_TEXTURE_LOD_BIAS}, {@link GL_TEXTURE_MIN_FILTER}, {@link GL_TEXTURE_MAG_FILTER}, {@link GL_TEXTURE_MIN_LOD}, {@link GL_TEXTURE_MAX_LOD}, {@link GL_TEXTURE_MAX_LEVEL}, {@link GL_TEXTURE_SWIZZLE_R}, {@link GL_TEXTURE_SWIZZLE_G}, {@link GL_TEXTURE_SWIZZLE_B}, {@link GL_TEXTURE_SWIZZLE_A}, {@link GL_TEXTURE_SWIZZLE_RGBA}, {@link GL_TEXTURE_WRAP_S}, {@link GL_TEXTURE_WRAP_T}, or {@link GL_TEXTURE_WRAP_R}.
 * @param params Specifies a pointer to an array where the value or values of **pname** are stored.
 * @example Create a framebuffer object with a texture-based color attachment and a texture-based depth attachment. Using texture-based attachments allows sampling of those textures in shaders.
 * ```
 * // fbo_width and fbo_height are the desired width and height of the FBO.
 * // For Opengl <= 4.4 or if the  GL_ARB_texture_non_power_of_two extension
 * // is present, fbo_width and fbo_height can be values other than 2^n for
 * // some integer n.
 *
 * // Build the texture that will serve as the color attachment for the framebuffer.
 * let texture_map: GLuint;
 * glGenTextures(1, texture_map);
 * glBindTexture(GL_TEXTURE_2D, texture_map);
 *
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_MIN_FILTER,  GL_LINEAR);
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_MAG_FILTER,  GL_LINEAR);
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_WRAP_S,  GL_CLAMP_TO_BORDER);
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_WRAP_T,  GL_CLAMP_TO_BORDER);
 *
 * glTexImage2D(GL_TEXTURE_2D, 0,  GL_RGBA, fbo_width, fbo_height, 0,  GL_RGBA,  GL_UNSIGNED_BYTE, NULL);
 *
 * glBindTexture(GL_TEXTURE_2D, 0);
 *
 * // Build the texture that will serve as the depth attachment for the framebuffer.
 * let depth_texture: GLuint;
 * glGenTextures(1, depth_texture);
 * glBindTexture(GL_TEXTURE_2D, depth_texture);
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_MIN_FILTER,  GL_NEAREST);
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_MAG_FILTER,  GL_NEAREST);
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_WRAP_S,  GL_CLAMP_TO_EDGE);
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_WRAP_T,  GL_CLAMP_TO_EDGE);
 * glTexImage2D(GL_TEXTURE_2D, 0,  GL_DEPTH_COMPONENT, fbo_width, fbo_height, 0,  GL_DEPTH_COMPONENT,  GL_UNSIGNED_BYTE, NULL);
 * glBindTexture(GL_TEXTURE_2D, 0);
 *
 * // Build the framebuffer.
 * let framebuffer: GLuint;
 * glGenFramebuffers(1, framebuffer);
 * glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);
 * glFramebufferTexture2D(GL_FRAMEBUFFER,  GL_COLOR_ATTACHMENT0,  GL_TEXTURE_2D, texture_map, 0);
 * glFramebufferTexture2D(GL_FRAMEBUFFER,  GL_DEPTH_ATTACHMENT,  GL_TEXTURE_2D, depth_texture, 0);
 *
 * let status: GLenum = glCheckFramebufferStatus(GL_FRAMEBUFFER);
 * if (status !=  GL_FRAMEBUFFER_COMPLETE)
 *     // Error
 *
 * glBindFramebuffer(GL_FRAMEBUFFER, 0);
 * ```
 *
 * @example Create a texture object with linear mipmaps and edge clamping.
 * ```
 * let texture_id: GLuint;
 * glGenTextures(1, texture_id);
 * glBindTexture(GL_TEXTURE_2D, texture_id);
 *
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
 *
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
 *
 * // texture_data is the source data of your texture, in this case
 * // its size is sizeof(unsigned char) * texture_width * texture_height * 4
 * glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, texture_width, texture_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, texture_data);
 * glGenerateMipmap(GL_TEXTURE_2D); // Unavailable in OpenGL 2.1, use gluBuild2DMipmaps() instead
 *
 * glBindTexture(GL_TEXTURE_2D, 0);
 * ```
 *
 * @tutorial [Songho - OpenGL Frame Buffer Object (FBO)](https://www.songho.ca/opengl/gl_fbo.html)
 * @tutorial [open.gl - Framebuffers](https://open.gl/framebuffers)
 * @tutorial [open.gl - Textures Objects and Parameters](https://open.gl/textures)
 * @tutorial [opengl-tutorial.org - Tutorial 14 : Render To Texture](https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-14-render-to-texture/)
 * @tutorial [opengl-tutorial.org - Tutorial 16 : Shadow mapping](https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/)
 * @tutorial [opengl-tutorial.org - Tutorial 5 : A Textured Cube](https://www.opengl-tutorial.org/beginners-tutorials/tutorial-5-a-textured-cube/)
 * @see [glTexParameter](https://docs.gl/gl3/glTexParameter)
 */
export function glTexParameterfv(
	target: GLenum,
	pname: GLenum,
	params: GLfloat
): void;

/**
 * `glTexParameter` assigns the value or values in **params** to the texture parameter specified as **pname**. **target** defines the target texture, either {@link GL_TEXTURE_1D}, {@link GL_TEXTURE_2D}, {@link GL_TEXTURE_1D_ARRAY}, {@link GL_TEXTURE_2D_ARRAY}, {@link GL_TEXTURE_RECTANGLE}, or {@link GL_TEXTURE_3D}. The following symbols are accepted in **pname**:
 *
 * - {@link GL_TEXTURE_BASE_LEVEL}
 * Specifies the index of the lowest defined mipmap level. This is an integer value. The initial value is 0.
 *
 * - {@link GL_TEXTURE_BORDER_COLOR}
 * The data in **params** specifies four values that define the border values that should be used for border texels. If a texel is sampled from the border of the texture, the values of {@link GL_TEXTURE_BORDER_COLOR} are interpreted as an RGBA color to match the texture's internal format and substituted for the non-existent texel data. If the texture contains depth components, the first component of {@link GL_TEXTURE_BORDER_COLOR} is interpreted as a depth value. The initial value is (0.0,0.0,0.0,0.0).
 *  If the values for {@link GL_TEXTURE_BORDER_COLOR} are specified with `glTexParameterIiv` or `glTexParameterIuiv`, the values are stored unmodified with an internal data type of integer. If specified with `glTexParameteriv`, they are converted to floating point with the following equation: 𝐟 = 2𝑐 + 1 / 2ᵇ − 1. If specified with `glTexParameterfv`, they are stored unmodified as floating-point values.
 *
 * - {@link GL_TEXTURE_COMPARE_FUNC}
 * Specifies the comparison operator used when {@link GL_TEXTURE_COMPARE_MODE} is set to {@link GL_COMPARE_REF_TO_TEXTURE}. Permissible values are:
 *
 * | **Texture Comparison Function** | **Computed result**   |
 * | :------------------------------ | :-------------------- |
 * |                                 |ㅤㅤㅤㅤ⎧ 1.0𝐫 <= 𝐃ₜ     |
 * | {@link GL_LEQUAL}               | result = ⎨            |
 * |                                 |ㅤㅤㅤㅤ⎩ 0.0𝐫 > 𝐃ₜ      |
 * |                                 |ㅤㅤㅤㅤ⎧ 1.0𝐫 >= 𝐃ₜ     |
 * | {@link GL_GEQUAL}               | result = ⎨            |
 * |                                 |ㅤㅤㅤㅤ⎩ 0.0𝐫 < 𝐃ₜ      |
 * |                                 |ㅤㅤㅤㅤ⎧ 1.0𝐫 < 𝐃ₜ      |
 * | {@link GL_LESS}                 | result = ⎨            |
 * |                                 |ㅤㅤㅤㅤ⎩ 0.0𝐫 >= 𝐃ₜ     |
 * |                                 |ㅤㅤㅤㅤ⎧ 1.0𝐫 > 𝐃ₜ      |
 * | {@link GL_GREATER}              | result = ⎨            |
 * |                                 |ㅤㅤㅤㅤ⎩ 0.0𝐫 <= 𝐃ₜ     |
 * |                                 |ㅤㅤㅤㅤ⎧ 1.0𝐫 = 𝐃ₜ      |
 * | {@link GL_EQUAL}                | result = ⎨            |
 * |                                 |ㅤㅤㅤㅤ⎩ 0.0𝐫 ≠ 𝐃ₜ     |
 * |                                 |ㅤㅤㅤㅤ⎧ 1.0𝐫 ≠ 𝐃ₜ     |
 * | {@link GL_NOTEQUAL}             | result = ⎨            |
 * |                                 |ㅤㅤㅤㅤ⎩ 0.0𝐫 = 𝐃ₜ      |
 * | {@link GL_ALWAYS}               | result = 1.0          |
 * | {@link GL_NEVER}                | result = 0.0          |
 *
 * where 𝐫 is the current interpolated texture coordinate, and 𝐃ₜ is the depth texture value sampled from the currently bound depth texture. *result* is assigned to the the red channel.
 *
 * - {@link GL_TEXTURE_COMPARE_MODE}
 * Specifies the texture comparison mode for currently bound depth textures. That is, a texture whose internal format is {@link GL_DEPTH_COMPONENT_*}; see {@link glTexImage2D}) Permissible values are:
 * - - {@link GL_COMPARE_REF_TO_TEXTURE} Specifies that the interpolated and clamped 𝐫 texture coordinate should be compared to the value in the currently bound depth texture. See the discussion of {@link GL_TEXTURE_COMPARE_FUNC} for details of how the comparison is evaluated. The result of the comparison is assigned to the red channel.
 * - - {@link GL_NONE} Specifies that the red channel should be assigned the appropriate value from the currently bound depth texture.
 *
 * - {@link GL_TEXTURE_LOD_BIAS}
 * **params** specifies a fixed bias value that is to be added to the level-of-detail parameter for the texture before texture sampling. The specified value is added to the shader-supplied bias value (if any) and subsequently clamped into the implementation-defined range [−biasₘₐₓ, biasₘₐₓ], where biasₘₐₓ is the value of the implementation defined constant {@link GL_MAX_TEXTURE_LOD_BIAS}. The initial value is 0.0.
 *
 * - {@link GL_TEXTURE_MIN_FILTER}
 *
 * The texture minifying function is used whenever the level-of-detail function used when sampling from the texture determines that the texture should be minified. There are six defined minifying functions. Two of them use either the nearest texture elements or a weighted average of multiple texture elements to compute the texture value. The other four use mipmaps.
 *
 * A mipmap is an ordered set of arrays representing the same image at progressively lower resolutions. If the texture has dimensions 2ⁿ × 2ᵐ, there are max(𝐧, 𝐦) + 1 mipmaps. The first mipmap is the original texture, with dimensions 2ⁿ × 2ᵐ. Each subsequent mipmap has dimensions 2ᵏ⁻¹ 2ᶩ⁻¹, where 2ᵏ × 2ᶩ are the dimensions of the previous mipmap, until either 𝐤 = 0 or 𝐥 = 0. At that point, subsequent mipmaps have dimension 1 × 2ᶩ⁻¹ or 2ᵏ⁻¹ × 1 until the final mipmap, which has dimension 1 × 1. To define the mipmaps, call {@link glTexImage1D}, {@link glTexImage2D}, {@link glTexImage3D}, {@link glCopyTexImage1D}, or {@link glCopyTexImage2D} with the **level** argument indicating the order of the mipmaps. Level 0 is the original texture; level max(𝐧, 𝐦) is the final 1 × 1 mipmap.
 *
 * **params** supplies a function for minifying the texture as one of the following:
 *
 * - - {@link GL_NEAREST}
 * Returns the value of the texture element that is nearest (in Manhattan distance) to the specified texture coordinates.
 *
 * - - {@link GL_LINEAR}
 * Returns the weighted average of the four texture elements that are closest to the specified texture coordinates. These can include items wrapped or repeated from other parts of a texture, depending on the values of {@link GL_TEXTURE_WRAP_S} and {@link GL_TEXTURE_WRAP_T}, and on the exact mapping.
 *
 * - - {@link GL_NEAREST_MIPMAP_NEAREST}
 * Chooses the mipmap that most closely matches the size of the pixel being textured and uses the {@link GL_NEAREST} criterion (the texture element closest to the specified texture coordinates) to produce a texture value.
 *
 * - - {@link GL_LINEAR_MIPMAP_NEAREST}
 * Chooses the mipmap that most closely matches the size of the pixel being textured and uses the {@link GL_LINEAR} criterion (a weighted average of the four texture elements that are closest to the specified texture coordinates) to produce a texture value.
 *
 * - - {@link GL_NEAREST_MIPMAP_LINEAR}
 * Chooses the two mipmaps that most closely match the size of the pixel being textured and uses the {@link GL_NEAREST} criterion (the texture element closest to the specified texture coordinates ) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values.
 *
 * - - {@link GL_LINEAR_MIPMAP_LINEAR}
 * Chooses the two mipmaps that most closely match the size of the pixel being textured and uses the {@link GL_LINEAR} criterion (a weighted average of the texture elements that are closest to the specified texture coordinates) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values.
 *
 * As more texture elements are sampled in the minification process, fewer aliasing artifacts will be apparent. While the {@link GL_NEAREST} and {@link GL_LINEAR} minification functions can be faster than the other four, they sample only one or multiple texture elements to determine the texture value of the pixel being rendered and can produce moire patterns or ragged transitions. The initial value of {@link GL_TEXTURE_MIN_FILTER} is {@link GL_NEAREST_MIPMAP_LINEAR}.
 *
 * - {@link GL_TEXTURE_MAG_FILTER}
 * The texture magnification function is used whenever the level-of-detail function used when sampling from the texture determines that the texture should be magified. It sets the texture magnification function to either {@link GL_NEAREST} or {@link GL_LINEAR} (see below). {@link GL_NEAREST} is generally faster than {@link GL_LINEAR}, but it can produce textured images with sharper edges because the transition between texture elements is not as smooth. The initial value of {@link GL_TEXTURE_MAG_FILTER} is {@link GL_LINEAR}.
 *
 * - - {@link GL_NEAREST}
 * Returns the value of the texture element that is nearest (in Manhattan distance) to the specified texture coordinates.
 *
 * - - {@link GL_LINEAR}
 * Returns the weighted average of the texture elements that are closest to the specified texture coordinates. These can include items wrapped or repeated from other parts of a texture, depending on the values of {@link GL_TEXTURE_WRAP_S} and {@link GL_TEXTURE_WRAP_T}, and on the exact mapping.
 *
 * - {@link GL_TEXTURE_MIN_LOD}
 * Sets the minimum level-of-detail parameter. This floating-point value limits the selection of highest resolution mipmap (lowest mipmap level). The initial value is -1000.
 *
 * - {@link GL_TEXTURE_MAX_LOD}
 * Sets the maximum level-of-detail parameter. This floating-point value limits the selection of the lowest resolution mipmap (highest mipmap level). The initial value is 1000.
 *
 * - {@link GL_TEXTURE_MAX_LEVEL}
 * Sets the index of the highest defined mipmap level. This is an integer value. The initial value is 1000.
 *
 * - {@link GL_TEXTURE_SWIZZLE_R}
 * Sets the swizzle that will be applied to the 𝐫 component of a texel before it is returned to the shader. Valid values for **param** are {@link GL_RED}, {@link GL_GREEN}, {@link GL_BLUE}, {@link GL_ALPHA}, {@link GL_ZERO} and {@link GL_ONE}. If {@link GL_TEXTURE_SWIZZLE_R} is {@link GL_RED}, the value for 𝐫 will be taken from the first channel of the fetched texel. If {@link GL_TEXTURE_SWIZZLE_R} is {@link GL_GREEN}, the value for 𝐫 will be taken from the second channel of the fetched texel. If {@link GL_TEXTURE_SWIZZLE_R} is {@link GL_BLUE}, the value for 𝐫 will be taken from the third channel of the fetched texel. If {@link GL_TEXTURE_SWIZZLE_R} is {@link GL_ALPHA}, the value for 𝐫 will be taken from the fourth channel of the fetched texel. If {@link GL_TEXTURE_SWIZZLE_R} is {@link GL_ZERO}, the value for 𝐫 will be subtituted with 0.0. If {@link GL_TEXTURE_SWIZZLE_R} is {@link GL_ONE}, the value for 𝐫 will be subtituted with 1.0. The initial value is {@link GL_RED}.
 *
 * - {@link GL_TEXTURE_SWIZZLE_G}
 * Sets the swizzle that will be applied to the 𝐠 component of a texel before it is returned to the shader. Valid values for **param** and their effects are similar to those of {@link GL_TEXTURE_SWIZZLE_R}. The initial value is {@link GL_GREEN}.
 *
 * - {@link GL_TEXTURE_SWIZZLE_B}
 * Sets the swizzle that will be applied to the 𝐛 component of a texel before it is returned to the shader. Valid values for **param** and their effects are similar to those of {@link GL_TEXTURE_SWIZZLE_R}. The initial value is {@link GL_BLUE}.
 *
 * - {@link GL_TEXTURE_SWIZZLE_A}
 * Sets the swizzle that will be applied to the 𝐚 component of a texel before it is returned to the shader. Valid values for **param** and their effects are similar to those of {@link GL_TEXTURE_SWIZZLE_R}. The initial value is {@link GL_ALPHA}.
 *
 * - {@link GL_TEXTURE_SWIZZLE_RGBA}
 * Sets the swizzles that will be applied to the 𝐫, 𝐠, 𝐛, and 𝐚 components of a texel before they are returned to the shader. Valid values for **params** and their effects are similar to those of {@link GL_TEXTURE_SWIZZLE_R}, except that all channels are specified simultaneously. Setting the value of {@link GL_TEXTURE_SWIZZLE_RGBA} is equivalent (assuming no errors are generated) to setting the parameters of each of {@link GL_TEXTURE_SWIZZLE_R}, {@link GL_TEXTURE_SWIZZLE_G}, {@link GL_TEXTURE_SWIZZLE_B}, and {@link GL_TEXTURE_SWIZZLE_A} successively.
 *
 * - {@link GL_TEXTURE_WRAP_S}
 * Sets the wrap parameter for texture coordinate 𝐬 to either {@link GL_CLAMP_TO_EDGE}, {@link GL_CLAMP_TO_BORDER}, {@link GL_MIRRORED_REPEAT}, or {@link GL_REPEAT}. {@link GL_CLAMP_TO_EDGE} causes 𝐬 coordinates to be clamped to the range [1/2𝐍, 1 − 1/2𝐍], where 𝐍 is the size of the texture in the direction of clamping. {@link GL_CLAMP_TO_BORDER} evaluates 𝐬 coordinates in a similar manner to {@link GL_CLAMP_TO_EDGE}. However, in cases where clamping would have occurred in {@link GL_CLAMP_TO_EDGE} mode, the fetched texel data is substituted with the values specified by {@link GL_TEXTURE_BORDER_COLOR}. {@link GL_REPEAT} causes the integer part of the 𝐬 coordinate to be ignored; the GL uses only the fractional part, thereby creating a repeating pattern. {@link GL_MIRRORED_REPEAT} causes the 𝐬 coordinate to be set to the fractional part of the texture coordinate if the integer part of 𝐬 is even; if the integer part of 𝐬 is odd, then the 𝐬 texture coordinate is set to 1 − frac(𝐬), where frac(𝐬) represents the fractional part of 𝐬. Initially, {@link GL_TEXTURE_WRAP_S} is set to {@link GL_REPEAT}.
 *
 * - {@link GL_TEXTURE_WRAP_T}
 * Sets the wrap parameter for texture coordinate 𝐭 to either {@link GL_CLAMP_TO_EDGE}, {@link GL_CLAMP_TO_BORDER}, {@link GL_MIRRORED_REPEAT}, or {@link GL_REPEAT}. See the discussion under {@link GL_TEXTURE_WRAP_S}. Initially, {@link GL_TEXTURE_WRAP_T} is set to {@link GL_REPEAT}.
 *
 * - {@link GL_TEXTURE_WRAP_R}
 *  Sets the wrap parameter for texture coordinate 𝐫 to either {@link GL_CLAMP_TO_EDGE}, {@link GL_CLAMP_TO_BORDER}, {@link GL_MIRRORED_REPEAT}, or {@link GL_REPEAT}. See the discussion under {@link GL_TEXTURE_WRAP_S}. Initially, {@link GL_TEXTURE_WRAP_R} is set to {@link GL_REPEAT}.
 *
 * @summary set texture parameters
 * @param target Specifies the target texture, which must be either {@link GL_TEXTURE_1D}, {@link GL_TEXTURE_2D}, {@link GL_TEXTURE_3D}, {@link GL_TEXTURE_1D_ARRAY}, {@link GL_TEXTURE_2D_ARRAY}, {@link GL_TEXTURE_RECTANGLE}, or {@link GL_TEXTURE_CUBE_MAP}.
 * @param pname Specifies the symbolic name of a texture parameter. **pname** can be one of the following: {@link GL_TEXTURE_BASE_LEVEL}, {@link GL_TEXTURE_BORDER_COLOR}, {@link GL_TEXTURE_COMPARE_FUNC}, {@link GL_TEXTURE_COMPARE_MODE}, {@link GL_TEXTURE_LOD_BIAS}, {@link GL_TEXTURE_MIN_FILTER}, {@link GL_TEXTURE_MAG_FILTER}, {@link GL_TEXTURE_MIN_LOD}, {@link GL_TEXTURE_MAX_LOD}, {@link GL_TEXTURE_MAX_LEVEL}, {@link GL_TEXTURE_SWIZZLE_R}, {@link GL_TEXTURE_SWIZZLE_G}, {@link GL_TEXTURE_SWIZZLE_B}, {@link GL_TEXTURE_SWIZZLE_A}, {@link GL_TEXTURE_SWIZZLE_RGBA}, {@link GL_TEXTURE_WRAP_S}, {@link GL_TEXTURE_WRAP_T}, or {@link GL_TEXTURE_WRAP_R}.
 * @param params Specifies a pointer to an array where the value or values of **pname** are stored.
 * @example Create a framebuffer object with a texture-based color attachment and a texture-based depth attachment. Using texture-based attachments allows sampling of those textures in shaders.
 * ```
 * // fbo_width and fbo_height are the desired width and height of the FBO.
 * // For Opengl <= 4.4 or if the  GL_ARB_texture_non_power_of_two extension
 * // is present, fbo_width and fbo_height can be values other than 2^n for
 * // some integer n.
 *
 * // Build the texture that will serve as the color attachment for the framebuffer.
 * let texture_map: GLuint;
 * glGenTextures(1, texture_map);
 * glBindTexture(GL_TEXTURE_2D, texture_map);
 *
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_MIN_FILTER,  GL_LINEAR);
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_MAG_FILTER,  GL_LINEAR);
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_WRAP_S,  GL_CLAMP_TO_BORDER);
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_WRAP_T,  GL_CLAMP_TO_BORDER);
 *
 * glTexImage2D(GL_TEXTURE_2D, 0,  GL_RGBA, fbo_width, fbo_height, 0,  GL_RGBA,  GL_UNSIGNED_BYTE, NULL);
 *
 * glBindTexture(GL_TEXTURE_2D, 0);
 *
 * // Build the texture that will serve as the depth attachment for the framebuffer.
 * let depth_texture: GLuint;
 * glGenTextures(1, depth_texture);
 * glBindTexture(GL_TEXTURE_2D, depth_texture);
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_MIN_FILTER,  GL_NEAREST);
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_MAG_FILTER,  GL_NEAREST);
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_WRAP_S,  GL_CLAMP_TO_EDGE);
 * glTexParameteri(GL_TEXTURE_2D,  GL_TEXTURE_WRAP_T,  GL_CLAMP_TO_EDGE);
 * glTexImage2D(GL_TEXTURE_2D, 0,  GL_DEPTH_COMPONENT, fbo_width, fbo_height, 0,  GL_DEPTH_COMPONENT,  GL_UNSIGNED_BYTE, NULL);
 * glBindTexture(GL_TEXTURE_2D, 0);
 *
 * // Build the framebuffer.
 * let framebuffer: GLuint;
 * glGenFramebuffers(1, framebuffer);
 * glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);
 * glFramebufferTexture2D(GL_FRAMEBUFFER,  GL_COLOR_ATTACHMENT0,  GL_TEXTURE_2D, texture_map, 0);
 * glFramebufferTexture2D(GL_FRAMEBUFFER,  GL_DEPTH_ATTACHMENT,  GL_TEXTURE_2D, depth_texture, 0);
 *
 * let status: GLenum = glCheckFramebufferStatus(GL_FRAMEBUFFER);
 * if (status !=  GL_FRAMEBUFFER_COMPLETE)
 *     // Error
 *
 * glBindFramebuffer(GL_FRAMEBUFFER, 0);
 * ```
 *
 * @example Create a texture object with linear mipmaps and edge clamping.
 * ```
 * let texture_id: GLuint;
 * glGenTextures(1, texture_id);
 * glBindTexture(GL_TEXTURE_2D, texture_id);
 *
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
 *
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
 * glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
 *
 * // texture_data is the source data of your texture, in this case
 * // its size is sizeof(unsigned char) * texture_width * texture_height * 4
 * glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, texture_width, texture_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, texture_data);
 * glGenerateMipmap(GL_TEXTURE_2D); // Unavailable in OpenGL 2.1, use gluBuild2DMipmaps() instead
 *
 * glBindTexture(GL_TEXTURE_2D, 0);
 * ```
 *
 * @tutorial [Songho - OpenGL Frame Buffer Object (FBO)](https://www.songho.ca/opengl/gl_fbo.html)
 * @tutorial [open.gl - Framebuffers](https://open.gl/framebuffers)
 * @tutorial [open.gl - Textures Objects and Parameters](https://open.gl/textures)
 * @tutorial [opengl-tutorial.org - Tutorial 14 : Render To Texture](https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-14-render-to-texture/)
 * @tutorial [opengl-tutorial.org - Tutorial 16 : Shadow mapping](https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/)
 * @tutorial [opengl-tutorial.org - Tutorial 5 : A Textured Cube](https://www.opengl-tutorial.org/beginners-tutorials/tutorial-5-a-textured-cube/)
 * @see [glTexParameter](https://docs.gl/gl3/glTexParameter)
 */
export function glTexParameteriv(
	target: GLenum,
	pname: GLenum,
	params: GLint
): void;

/**
 * Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled. To enable or disable one-dimensional texturing, call {@link glEnable} and {@link glDisable} with argument {@link GL_TEXTURE_1D}.
 *
 * `glTexSubImage1D` redefines a contiguous subregion of an existing one-dimensional texture image. The texels referenced by **data** replace the portion of the existing texture array with x indices **xoffset** and *xoffset* + *width* − 1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with width of 0, but such a specification has no effect.
 *
 * If a non-zero named buffer object is bound to the {@link GL_PIXEL_UNPACK_BUFFER} target (see {@link glBindBuffer}) while a texture image is specified, **data** is treated as a byte offset into the buffer object's data store.
 *
 * @summary specify a one-dimensional texture subimage
 * @param target Specifies the target texture. Must be {@link GL_TEXTURE_1D}.
 * @param level Specifies the level-of-detail number. Level 0 is the base image level. Level **n** is the **n**ᵗʰ mipmap reduction image.
 * @param xoffset Specifies a texel offset in the x direction within the texture array.
 * @param width Specifies the width of the texture subimage.
 * @param format Specifies the format of the pixel data. The following symbolic values are accepted: {@link GL_RED}, {@link GL_RG}, {@link GL_RGB}, {@link GL_BGR}, {@link GL_RGBA}, and {@link GL_BGRA}.
 * @param type Specifies the data type of the pixel data. The following symbolic values are accepted: {@link GL_UNSIGNED_BYTE}, {@link GL_BYTE}, {@link GL_UNSIGNED_SHORT}, {@link GL_SHORT}, {@link GL_UNSIGNED_INT}, {@link GL_INT}, {@link GL_FLOAT}, {@link GL_UNSIGNED_BYTE_3_3_2}, {@link GL_UNSIGNED_BYTE_2_3_3_REV}, {@link GL_UNSIGNED_SHORT_5_6_5}, {@link GL_UNSIGNED_SHORT_5_6_5_REV}, {@link GL_UNSIGNED_SHORT_4_4_4_4}, {@link GL_UNSIGNED_SHORT_4_4_4_4_REV}, {@link GL_UNSIGNED_SHORT_5_5_5_1}, {@link GL_UNSIGNED_SHORT_1_5_5_5_REV}, {@link GL_UNSIGNED_INT_8_8_8_8}, {@link GL_UNSIGNED_INT_8_8_8_8_REV}, {@link GL_UNSIGNED_INT_10_10_10_2}, and {@link GL_UNSIGNED_INT_2_10_10_10_REV}.
 * @param data Specifies a pointer to the image data in memory.
 * @see [glTexSubImage1D](https://docs.gl/gl3/glTexSubImage1D)
 */
export function glTexSubImage1D(
	target: GLenum,
	level: GLint,
	xoffset: GLint,
	width: GLsizei,
	format: GLenum,
	type: GLenum,
	data: GLvoid
): void;

/**
 * Texturing maps a portion of a specified texture image onto each graphical primitive for which texturing is enabled.
 *
 * `glTexSubImage2D` redefines a contiguous subregion of an existing two-dimensional or one-dimensional array texture image. The texels referenced by **data** replace the portion of the existing texture array with x indices **xoffset** and *xoffset* + *width* − 1, inclusive, and y indices **yoffset** and *yoffset* + *height* − 1, inclusive. This region may not include any texels outside the range of the texture array as it was originally specified. It is not an error to specify a subtexture with zero width or height, but such a specification has no effect.
 *
 * If a non-zero named buffer object is bound to the {@link GL_PIXEL_UNPACK_BUFFER} target (see {@link glBindBuffer}) while a texture image is specified, **data** is treated as a byte offset into the buffer object's data store.
 *
 * @summary specify a two-dimensional texture subimage
 * @param target Specifies the target texture. Must be {@link GL_TEXTURE_2D}, {@link GL_TEXTURE_CUBE_MAP_POSITIVE_X}, {@link GL_TEXTURE_CUBE_MAP_NEGATIVE_X}, {@link GL_TEXTURE_CUBE_MAP_POSITIVE_Y}, {@link GL_TEXTURE_CUBE_MAP_NEGATIVE_Y}, {@link GL_TEXTURE_CUBE_MAP_POSITIVE_Z}, {@link GL_TEXTURE_CUBE_MAP_NEGATIVE_Z}, or {@link GL_TEXTURE_1D_ARRAY}.
 * @param level Specifies the level-of-detail number. Level 0 is the base image level. Level **n** is the **n**ᵗʰ mipmap reduction image.
 * @param xoffset Specifies a texel offset in the x direction within the texture array.
 * @param yoffset Specifies a texel offset in the y direction within the texture array.
 * @param width Specifies the width of the texture subimage.
 * @param height Specifies the height of the texture subimage.
 * @param format Specifies the format of the pixel data. The following symbolic values are accepted: {@link GL_RED}, {@link GL_RG}, {@link GL_RGB}, {@link GL_BGR}, {@link GL_RGBA}, and {@link GL_BGRA}.
 * @param type Specifies the data type of the pixel data. The following symbolic values are accepted: {@link GL_UNSIGNED_BYTE}, {@link GL_BYTE}, {@link GL_UNSIGNED_SHORT}, {@link GL_SHORT}, {@link GL_UNSIGNED_INT}, {@link GL_INT}, {@link GL_FLOAT}, {@link GL_UNSIGNED_BYTE_3_3_2}, {@link GL_UNSIGNED_BYTE_2_3_3_REV}, {@link GL_UNSIGNED_SHORT_5_6_5}, {@link GL_UNSIGNED_SHORT_5_6_5_REV}, {@link GL_UNSIGNED_SHORT_4_4_4_4}, {@link GL_UNSIGNED_SHORT_4_4_4_4_REV}, {@link GL_UNSIGNED_SHORT_5_5_5_1}, {@link GL_UNSIGNED_SHORT_1_5_5_5_REV}, {@link GL_UNSIGNED_INT_8_8_8_8}, {@link GL_UNSIGNED_INT_8_8_8_8_REV}, {@link GL_UNSIGNED_INT_10_10_10_2}, and {@link GL_UNSIGNED_INT_2_10_10_10_REV}.
 * @param data Specifies a pointer to the image data in memory.
 * @tutorial [Songho - OpenGL Pixel Buffer Object (PBO)](https://www.songho.ca/opengl/gl_pbo.html)
 * @see [glTexSubImage2D](https://docs.gl/gl3/glTexSubImage2D)
 */
export function glTexSubImage2D(
	target: GLenum,
	level: GLint,
	xoffset: GLint,
	yoffset: GLint,
	width: GLsizei,
	height: GLsizei,
	format: GLenum,
	type: GLenum,
	data: GLvoid
): void;

/**
 * `glTranslate` produces a translation by (𝐱, 𝐲, 𝐳). The current matrix (see {@link glMatrixMode}) is multiplied by this translation matrix, with the product replacing the current matrix, as if {@link glMultMatrix} were called with the following matrix for its argument:
 *
 * ⎛1ㅤ0ㅤ0ㅤ𝐱⎞
 *
 * ⎜0ㅤ1ㅤ0ㅤ𝐲 ⎜
 *
 * ⎜0ㅤ0ㅤ1ㅤ𝐳 ⎜
 *
 * ⎝0ㅤ0ㅤ0ㅤ1⎠
 *
 * If the matrix mode is either {@link GL_MODELVIEW} or {@link GL_PROJECTION}, all objects drawn after a call to `glTranslate` are translated.
 *
 * Use {@link glPushMatrix} and {@link glPopMatrix} to save and restore the untranslated coordinate system.
 *
 * @summary multiply the current matrix by a translation matrix
 * @param x Specifies the **x** coordinate of the translation vector.
 * @param y Specifies the **y** coordinate of the translation vector.
 * @param z Specifies the **z** coordinate of the translation vector.
 * @see [glTranslate](https://docs.gl/gl3/glTranslate)
 */
export function glTranslated(x: GLdouble, y: GLdouble, z: GLdouble): void;

/**
 * `glTranslate` produces a translation by (𝐱, 𝐲, 𝐳). The current matrix (see {@link glMatrixMode}) is multiplied by this translation matrix, with the product replacing the current matrix, as if {@link glMultMatrix} were called with the following matrix for its argument:
 *
 * ⎛1ㅤ0ㅤ0ㅤ𝐱⎞
 *
 * ⎜0ㅤ1ㅤ0ㅤ𝐲 ⎜
 *
 * ⎜0ㅤ0ㅤ1ㅤ𝐳 ⎜
 *
 * ⎝0ㅤ0ㅤ0ㅤ1⎠
 *
 * If the matrix mode is either {@link GL_MODELVIEW} or {@link GL_PROJECTION}, all objects drawn after a call to `glTranslate` are translated.
 *
 * Use {@link glPushMatrix} and {@link glPopMatrix} to save and restore the untranslated coordinate system.
 *
 * @summary multiply the current matrix by a translation matrix
 * @param x Specifies the **x** coordinate of the translation vector.
 * @param y Specifies the **y** coordinate of the translation vector.
 * @param z Specifies the **z** coordinate of the translation vector.
 * @see [glTranslate](https://docs.gl/gl3/glTranslate)
 */
export function glTranslatef(x: GLfloat, y: GLfloat, z: GLfloat): void;

/**
 * `glVertex` commands are used within {@link glBegin}/{@link glEnd} pairs to specify point, line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated with the vertex when `glVertex` is called.
 *
 *  When only 𝐱 and 𝐲 are specified, 𝐳 defaults to 0 and 𝐰 defaults to 1. When 𝐱, 𝐲, and 𝐳 are specified, 𝐰 defaults to 1.
 *
 * @summary specify a vertex
 * @param x Specify **x** coordinate of the vertex.
 * @param y Specify **y** coordinate of the vertex.
 * @see [glVertex](https://docs.gl/gl3/glVertex)
 */
export function glVertex2d(x: GLdouble, y: GLdouble): void;

/**
 * `glVertex` commands are used within {@link glBegin}/{@link glEnd} pairs to specify point, line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated with the vertex when `glVertex` is called.
 *
 *  When only 𝐱 and 𝐲 are specified, 𝐳 defaults to 0 and 𝐰 defaults to 1. When 𝐱, 𝐲, and 𝐳 are specified, 𝐰 defaults to 1.
 *
 * @summary specify a vertex
 * @param x Specify **x** coordinate of the vertex.
 * @param y Specify **y** coordinate of the vertex.
 * @see [glVertex](https://docs.gl/gl3/glVertex)
 */
export function glVertex2f(x: GLfloat, y: GLfloat): void;

/**
 * `glVertex` commands are used within {@link glBegin}/{@link glEnd} pairs to specify point, line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated with the vertex when `glVertex` is called.
 *
 *  When only 𝐱 and 𝐲 are specified, 𝐳 defaults to 0 and 𝐰 defaults to 1. When 𝐱, 𝐲, and 𝐳 are specified, 𝐰 defaults to 1.
 *
 * @summary specify a vertex
 * @param x Specify **x** coordinate of the vertex.
 * @param y Specify **y** coordinate of the vertex.
 * @see [glVertex](https://docs.gl/gl3/glVertex)
 */
export function glVertex2i(x: GLint, y: GLint): void;

/**
 * `glVertex` commands are used within {@link glBegin}/{@link glEnd} pairs to specify point, line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated with the vertex when `glVertex` is called.
 *
 *  When only 𝐱 and 𝐲 are specified, 𝐳 defaults to 0 and 𝐰 defaults to 1. When 𝐱, 𝐲, and 𝐳 are specified, 𝐰 defaults to 1.
 *
 * @summary specify a vertex
 * @param x Specify **x** coordinate of the vertex.
 * @param y Specify **y** coordinate of the vertex.
 * @see [glVertex](https://docs.gl/gl3/glVertex)
 */
export function glVertex2s(x: GLshort, y: GLshort): void;

/**
 * `glVertex` commands are used within {@link glBegin}/{@link glEnd} pairs to specify point, line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated with the vertex when `glVertex` is called.
 *
 *  When only 𝐱 and 𝐲 are specified, 𝐳 defaults to 0 and 𝐰 defaults to 1. When 𝐱, 𝐲, and 𝐳 are specified, 𝐰 defaults to 1.
 *
 * @summary specify a vertex
 * @param x Specify **x** coordinate of the vertex.
 * @param y Specify **y** coordinate of the vertex.
 * @param z Specify **z** coordinate of the vertex.
 * @see [glVertex](https://docs.gl/gl3/glVertex)
 */
export function glVertex3d(x: GLdouble, y: GLdouble, z: GLdouble): void;

/**
 * `glVertex` commands are used within {@link glBegin}/{@link glEnd} pairs to specify point, line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated with the vertex when `glVertex` is called.
 *
 *  When only 𝐱 and 𝐲 are specified, 𝐳 defaults to 0 and 𝐰 defaults to 1. When 𝐱, 𝐲, and 𝐳 are specified, 𝐰 defaults to 1.
 *
 * @summary specify a vertex
 * @param x Specify **x** coordinate of the vertex.
 * @param y Specify **y** coordinate of the vertex.
 * @param z Specify **z** coordinate of the vertex.
 * @see [glVertex](https://docs.gl/gl3/glVertex)
 */
export function glVertex3f(x: GLfloat, y: GLfloat, z: GLfloat): void;

/**
 * `glVertex` commands are used within {@link glBegin}/{@link glEnd} pairs to specify point, line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated with the vertex when `glVertex` is called.
 *
 *  When only 𝐱 and 𝐲 are specified, 𝐳 defaults to 0 and 𝐰 defaults to 1. When 𝐱, 𝐲, and 𝐳 are specified, 𝐰 defaults to 1.
 *
 * @summary specify a vertex
 * @param x Specify **x** coordinate of the vertex.
 * @param y Specify **y** coordinate of the vertex.
 * @param z Specify **z** coordinate of the vertex.
 * @see [glVertex](https://docs.gl/gl3/glVertex)
 */
export function glVertex3i(x: GLint, y: GLint, z: GLint): void;

/**
 * `glVertex` commands are used within {@link glBegin}/{@link glEnd} pairs to specify point, line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated with the vertex when `glVertex` is called.
 *
 *  When only 𝐱 and 𝐲 are specified, 𝐳 defaults to 0 and 𝐰 defaults to 1. When 𝐱, 𝐲, and 𝐳 are specified, 𝐰 defaults to 1.
 *
 * @summary specify a vertex
 * @param x Specify **x** coordinate of the vertex.
 * @param y Specify **y** coordinate of the vertex.
 * @param z Specify **z** coordinate of the vertex.
 * @see [glVertex](https://docs.gl/gl3/glVertex)
 */
export function glVertex3s(x: GLshort, y: GLshort, z: GLshort): void;

/**
 * `glVertex` commands are used within {@link glBegin}/{@link glEnd} pairs to specify point, line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated with the vertex when `glVertex` is called.
 *
 *  When only 𝐱 and 𝐲 are specified, 𝐳 defaults to 0 and 𝐰 defaults to 1. When 𝐱, 𝐲, and 𝐳 are specified, 𝐰 defaults to 1.
 *
 * @summary specify a vertex
 * @param x Specify **x** coordinate of the vertex.
 * @param y Specify **y** coordinate of the vertex.
 * @param z Specify **z** coordinate of the vertex.
 * @param w Specify **w** coordinate of the vertex.
 * @see [glVertex](https://docs.gl/gl3/glVertex)
 */
export function glVertex4d(
	x: GLdouble,
	y: GLdouble,
	z: GLdouble,
	w: GLdouble
): void;

/**
 * `glVertex` commands are used within {@link glBegin}/{@link glEnd} pairs to specify point, line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated with the vertex when `glVertex` is called.
 *
 *  When only 𝐱 and 𝐲 are specified, 𝐳 defaults to 0 and 𝐰 defaults to 1. When 𝐱, 𝐲, and 𝐳 are specified, 𝐰 defaults to 1.
 *
 * @summary specify a vertex
 * @param x Specify **x** coordinate of the vertex.
 * @param y Specify **y** coordinate of the vertex.
 * @param z Specify **z** coordinate of the vertex.
 * @param w Specify **w** coordinate of the vertex.
 * @see [glVertex](https://docs.gl/gl3/glVertex)
 */
export function glVertex4f(
	x: GLfloat,
	y: GLfloat,
	z: GLfloat,
	w: GLfloat
): void;

/**
 * `glVertex` commands are used within {@link glBegin}/{@link glEnd} pairs to specify point, line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated with the vertex when `glVertex` is called.
 *
 *  When only 𝐱 and 𝐲 are specified, 𝐳 defaults to 0 and 𝐰 defaults to 1. When 𝐱, 𝐲, and 𝐳 are specified, 𝐰 defaults to 1.
 *
 * @summary specify a vertex
 * @param x Specify **x** coordinate of the vertex.
 * @param y Specify **y** coordinate of the vertex.
 * @param z Specify **z** coordinate of the vertex.
 * @param w Specify **w** coordinate of the vertex.
 * @see [glVertex](https://docs.gl/gl3/glVertex)
 */
export function glVertex4i(x: GLint, y: GLint, z: GLint, w: GLint): void;

/**
 * `glVertex` commands are used within {@link glBegin}/{@link glEnd} pairs to specify point, line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated with the vertex when `glVertex` is called.
 *
 *  When only 𝐱 and 𝐲 are specified, 𝐳 defaults to 0 and 𝐰 defaults to 1. When 𝐱, 𝐲, and 𝐳 are specified, 𝐰 defaults to 1.
 *
 * @summary specify a vertex
 * @param x Specify **x** coordinate of the vertex.
 * @param y Specify **y** coordinate of the vertex.
 * @param z Specify **z** coordinate of the vertex.
 * @param w Specify **w** coordinate of the vertex.
 * @see [glVertex](https://docs.gl/gl3/glVertex)
 */
export function glVertex4s(
	x: GLshort,
	y: GLshort,
	z: GLshort,
	w: GLshort
): void;

/**
 * `glVertex` commands are used within {@link glBegin}/{@link glEnd} pairs to specify point, line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated with the vertex when `glVertex` is called.
 *
 *  When only 𝐱 and 𝐲 are specified, 𝐳 defaults to 0 and 𝐰 defaults to 1. When 𝐱, 𝐲, and 𝐳 are specified, 𝐰 defaults to 1.
 *
 * @summary specify a vertex
 * @param v Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array are 𝐱 and 𝐲; of a three-element array, 𝐱, 𝐲, and 𝐳; and of a four-element array, 𝐱, 𝐲, 𝐳, and 𝐰.
 * @see [glVertex](https://docs.gl/gl3/glVertex)
 */
export function glVertex2dv(v: GLdouble): void;

/**
 * `glVertex` commands are used within {@link glBegin}/{@link glEnd} pairs to specify point, line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated with the vertex when `glVertex` is called.
 *
 *  When only 𝐱 and 𝐲 are specified, 𝐳 defaults to 0 and 𝐰 defaults to 1. When 𝐱, 𝐲, and 𝐳 are specified, 𝐰 defaults to 1.
 *
 * @summary specify a vertex
 * @param v Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array are 𝐱 and 𝐲; of a three-element array, 𝐱, 𝐲, and 𝐳; and of a four-element array, 𝐱, 𝐲, 𝐳, and 𝐰.
 * @see [glVertex](https://docs.gl/gl3/glVertex)
 */
export function glVertex2fv(v: GLfloat): void;

/**
 * `glVertex` commands are used within {@link glBegin}/{@link glEnd} pairs to specify point, line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated with the vertex when `glVertex` is called.
 *
 *  When only 𝐱 and 𝐲 are specified, 𝐳 defaults to 0 and 𝐰 defaults to 1. When 𝐱, 𝐲, and 𝐳 are specified, 𝐰 defaults to 1.
 *
 * @summary specify a vertex
 * @param v Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array are 𝐱 and 𝐲; of a three-element array, 𝐱, 𝐲, and 𝐳; and of a four-element array, 𝐱, 𝐲, 𝐳, and 𝐰.
 * @see [glVertex](https://docs.gl/gl3/glVertex)
 */
export function glVertex2iv(v: GLint): void;

/**
 * `glVertex` commands are used within {@link glBegin}/{@link glEnd} pairs to specify point, line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated with the vertex when `glVertex` is called.
 *
 *  When only 𝐱 and 𝐲 are specified, 𝐳 defaults to 0 and 𝐰 defaults to 1. When 𝐱, 𝐲, and 𝐳 are specified, 𝐰 defaults to 1.
 *
 * @summary specify a vertex
 * @param v Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array are 𝐱 and 𝐲; of a three-element array, 𝐱, 𝐲, and 𝐳; and of a four-element array, 𝐱, 𝐲, 𝐳, and 𝐰.
 * @see [glVertex](https://docs.gl/gl3/glVertex)
 */
export function glVertex2sv(v: GLshort): void;

/**
 * `glVertex` commands are used within {@link glBegin}/{@link glEnd} pairs to specify point, line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated with the vertex when `glVertex` is called.
 *
 *  When only 𝐱 and 𝐲 are specified, 𝐳 defaults to 0 and 𝐰 defaults to 1. When 𝐱, 𝐲, and 𝐳 are specified, 𝐰 defaults to 1.
 *
 * @summary specify a vertex
 * @param v Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array are 𝐱 and 𝐲; of a three-element array, 𝐱, 𝐲, and 𝐳; and of a four-element array, 𝐱, 𝐲, 𝐳, and 𝐰.
 * @see [glVertex](https://docs.gl/gl3/glVertex)
 */
export function glVertex3dv(v: GLdouble): void;

/**
 * `glVertex` commands are used within {@link glBegin}/{@link glEnd} pairs to specify point, line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated with the vertex when `glVertex` is called.
 *
 *  When only 𝐱 and 𝐲 are specified, 𝐳 defaults to 0 and 𝐰 defaults to 1. When 𝐱, 𝐲, and 𝐳 are specified, 𝐰 defaults to 1.
 *
 * @summary specify a vertex
 * @param v Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array are 𝐱 and 𝐲; of a three-element array, 𝐱, 𝐲, and 𝐳; and of a four-element array, 𝐱, 𝐲, 𝐳, and 𝐰.
 * @see [glVertex](https://docs.gl/gl3/glVertex)
 */
export function glVertex3fv(v: GLfloat): void;

/**
 * `glVertex` commands are used within {@link glBegin}/{@link glEnd} pairs to specify point, line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated with the vertex when `glVertex` is called.
 *
 *  When only 𝐱 and 𝐲 are specified, 𝐳 defaults to 0 and 𝐰 defaults to 1. When 𝐱, 𝐲, and 𝐳 are specified, 𝐰 defaults to 1.
 *
 * @summary specify a vertex
 * @param v Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array are 𝐱 and 𝐲; of a three-element array, 𝐱, 𝐲, and 𝐳; and of a four-element array, 𝐱, 𝐲, 𝐳, and 𝐰.
 * @see [glVertex](https://docs.gl/gl3/glVertex)
 */
export function glVertex3iv(v: GLint): void;

/**
 * `glVertex` commands are used within {@link glBegin}/{@link glEnd} pairs to specify point, line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated with the vertex when `glVertex` is called.
 *
 *  When only 𝐱 and 𝐲 are specified, 𝐳 defaults to 0 and 𝐰 defaults to 1. When 𝐱, 𝐲, and 𝐳 are specified, 𝐰 defaults to 1.
 *
 * @summary specify a vertex
 * @param v Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array are 𝐱 and 𝐲; of a three-element array, 𝐱, 𝐲, and 𝐳; and of a four-element array, 𝐱, 𝐲, 𝐳, and 𝐰.
 * @see [glVertex](https://docs.gl/gl3/glVertex)
 */
export function glVertex3sv(v: GLshort): void;

/**
 * `glVertex` commands are used within {@link glBegin}/{@link glEnd} pairs to specify point, line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated with the vertex when `glVertex` is called.
 *
 *  When only 𝐱 and 𝐲 are specified, 𝐳 defaults to 0 and 𝐰 defaults to 1. When 𝐱, 𝐲, and 𝐳 are specified, 𝐰 defaults to 1.
 *
 * @summary specify a vertex
 * @param v Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array are 𝐱 and 𝐲; of a three-element array, 𝐱, 𝐲, and 𝐳; and of a four-element array, 𝐱, 𝐲, 𝐳, and 𝐰.
 * @see [glVertex](https://docs.gl/gl3/glVertex)
 */
export function glVertex4dv(v: GLdouble): void;

/**
 * `glVertex` commands are used within {@link glBegin}/{@link glEnd} pairs to specify point, line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated with the vertex when `glVertex` is called.
 *
 *  When only 𝐱 and 𝐲 are specified, 𝐳 defaults to 0 and 𝐰 defaults to 1. When 𝐱, 𝐲, and 𝐳 are specified, 𝐰 defaults to 1.
 *
 * @summary specify a vertex
 * @param v Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array are 𝐱 and 𝐲; of a three-element array, 𝐱, 𝐲, and 𝐳; and of a four-element array, 𝐱, 𝐲, 𝐳, and 𝐰.
 * @see [glVertex](https://docs.gl/gl3/glVertex)
 */
export function glVertex4fv(v: GLfloat): void;

/**
 * `glVertex` commands are used within {@link glBegin}/{@link glEnd} pairs to specify point, line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated with the vertex when `glVertex` is called.
 *
 *  When only 𝐱 and 𝐲 are specified, 𝐳 defaults to 0 and 𝐰 defaults to 1. When 𝐱, 𝐲, and 𝐳 are specified, 𝐰 defaults to 1.
 *
 * @summary specify a vertex
 * @param v Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array are 𝐱 and 𝐲; of a three-element array, 𝐱, 𝐲, and 𝐳; and of a four-element array, 𝐱, 𝐲, 𝐳, and 𝐰.
 * @see [glVertex](https://docs.gl/gl3/glVertex)
 */
export function glVertex4iv(v: GLint): void;

/**
 * `glVertex` commands are used within {@link glBegin}/{@link glEnd} pairs to specify point, line, and polygon vertices. The current color, normal, texture coordinates, and fog coordinate are associated with the vertex when `glVertex` is called.
 *
 *  When only 𝐱 and 𝐲 are specified, 𝐳 defaults to 0 and 𝐰 defaults to 1. When 𝐱, 𝐲, and 𝐳 are specified, 𝐰 defaults to 1.
 *
 * @summary specify a vertex
 * @param v Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array are 𝐱 and 𝐲; of a three-element array, 𝐱, 𝐲, and 𝐳; and of a four-element array, 𝐱, 𝐲, 𝐳, and 𝐰.
 * @see [glVertex](https://docs.gl/gl3/glVertex)
 */
export function glVertex4sv(v: GLshort): void;

/**
 * `glVertexPointer` specifies the location and data format of an array of vertex coordinates to use when rendering. **size** specifies the number of coordinates per vertex, and must be 2, 3, or 4. **type** specifies the data type of each coordinate, and **stride** specifies the byte stride from one vertex to the next, allowing vertices and attributes to be packed into a single array or stored in separate arrays. (Single-array storage may be more efficient on some implementations; see {@link glInterleavedArrays}.)
 *
 * If a non-zero named buffer object is bound to the {@link GL_ARRAY_BUFFER} target (see {@link glBindBuffer}) while a vertex array is specified, **pointer** is treated as a byte offset into the buffer object's data store. Also, the buffer object binding ({@link GL_ARRAY_BUFFER_BINDING}) is saved as vertex array client-side state ({@link GL_VERTEX_ARRAY_BUFFER_BINDING}).
 *
 * When a vertex array is specified, **size**, **type**, **stride**, and **pointer** are saved as client-side state, in addition to the current vertex array buffer object binding.
 *
 * To enable and disable the vertex array, call {@link glEnableClientState} and {@link glDisableClientState} with the argument {@link GL_VERTEX_ARRAY}. If enabled, the vertex array is used when {@link glArrayElement}, {@link glDrawArrays}, {@link glMultiDrawArrays}, {@link glDrawElements}, {@link glMultiDrawElements}, or {@link glDrawRangeElements} is called.
 *
 * @summary define an array of vertex data
 * @param size Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.
 * @param type Specifies the data type of each coordinate in the array. Symbolic constants {@link GL_SHORT}, {@link GL_INT}, {@link GL_FLOAT}, or {@link GL_DOUBLE} are accepted. The initial value is {@link GL_FLOAT}.
 * @param stride Specifies the byte offset between consecutive vertices. If **stride** is 0, the vertices are understood to be tightly packed in the array. The initial value is 0.
 * @param pointer Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.
 * @see [glVertexPointer](https://docs.gl/gl3/glVertexPointer)
 */
export function glVertexPointer(
	size: GLint,
	type: GLenum,
	stride: GLsizei,
	pointer: GLvoid
): void;

/**
 * `glViewport` specifies the affine transformation of 𝐱 and 𝐲 from normalized device coordinates to window coordinates. Let (𝐱ₙ𝑑, 𝐲ₙ𝑑) be normalized device coordinates. Then the window coordinates (𝐱𝑤, 𝐲𝑤) are computed as follows:
 *
 * 𝐱𝑤 = (𝐱ₙ𝑑 + 1)(*width* / 2) + 𝐱
 *
 * 𝐲𝑤 = (𝐲ₙ𝑑 + 1)(*height* / 2) + 𝐲
 *
 * Viewport width and height are silently clamped to a range that depends on the implementation. To query this range, call {@link glGet} with argument {@link GL_MAX_VIEWPORT_DIMS}.
 *
 * @summary set the viewport
 * @param x Specifies x coordinate of the lower left corner of the viewport rectangle. The initial value is 0.
 * @param y Specifies y coordinate of the lower left corner of the viewport rectangle. The initial value is 0.
 * @param width Specifies the width of the viewport. When a GL context is first attached to a window, **width** is set to the width of that window.
 * @param height Specifies the height of the viewport. When a GL context is first attached to a window, **height** is set to the height of that window.
 * @see [glViewport](https://docs.gl/gl3/glViewport)
 */
export function glViewport(
	x: GLint,
	y: GLint,
	width: GLsizei,
	height: GLsizei
): void;

export let GL_FALSE: number;
export let GL_TRUE: number;
export let GL_BYTE: number;
export let GL_UNSIGNED_BYTE: number;
export let GL_SHORT: number;
export let GL_UNSIGNED_SHORT: number;
export let GL_INT: number;
export let GL_UNSIGNED_INT: number;
export let GL_FLOAT: number;
export let GL_2_BYTES: number;
export let GL_3_BYTES: number;
export let GL_4_BYTES: number;
export let GL_DOUBLE: number;
export let GL_POINTS: number;
export let GL_LINES: number;
export let GL_LINE_LOOP: number;
export let GL_LINE_STRIP: number;
export let GL_TRIANGLES: number;
export let GL_TRIANGLE_STRIP: number;
export let GL_TRIANGLE_FAN: number;
export let GL_QUADS: number;
export let GL_QUAD_STRIP: number;
export let GL_POLYGON: number;
export let GL_VERTEX_ARRAY: number;
export let GL_NORMAL_ARRAY: number;
export let GL_COLOR_ARRAY: number;
export let GL_INDEX_ARRAY: number;
export let GL_TEXTURE_COORD_ARRAY: number;
export let GL_EDGE_FLAG_ARRAY: number;
export let GL_VERTEX_ARRAY_SIZE: number;
export let GL_VERTEX_ARRAY_TYPE: number;
export let GL_VERTEX_ARRAY_STRIDE: number;
export let GL_NORMAL_ARRAY_TYPE: number;
export let GL_NORMAL_ARRAY_STRIDE: number;
export let GL_COLOR_ARRAY_SIZE: number;
export let GL_COLOR_ARRAY_TYPE: number;
export let GL_COLOR_ARRAY_STRIDE: number;
export let GL_INDEX_ARRAY_TYPE: number;
export let GL_INDEX_ARRAY_STRIDE: number;
export let GL_TEXTURE_COORD_ARRAY_SIZE: number;
export let GL_TEXTURE_COORD_ARRAY_TYPE: number;
export let GL_TEXTURE_COORD_ARRAY_STRIDE: number;
export let GL_EDGE_FLAG_ARRAY_STRIDE: number;
export let GL_VERTEX_ARRAY_POINTER: number;
export let GL_NORMAL_ARRAY_POINTER: number;
export let GL_COLOR_ARRAY_POINTER: number;
export let GL_INDEX_ARRAY_POINTER: number;
export let GL_TEXTURE_COORD_ARRAY_POINTER: number;
export let GL_EDGE_FLAG_ARRAY_POINTER: number;
export let GL_V2F: number;
export let GL_V3F: number;
export let GL_C4UB_V2F: number;
export let GL_C4UB_V3F: number;
export let GL_C3F_V3F: number;
export let GL_N3F_V3F: number;
export let GL_C4F_N3F_V3F: number;
export let GL_T2F_V3F: number;
export let GL_T4F_V4F: number;
export let GL_T2F_C4UB_V3F: number;
export let GL_T2F_C3F_V3F: number;
export let GL_T2F_N3F_V3F: number;
export let GL_T2F_C4F_N3F_V3F: number;
export let GL_T4F_C4F_N3F_V4F: number;
export let GL_MATRIX_MODE: number;
export let GL_MODELVIEW: number;
export let GL_PROJECTION: number;
export let GL_TEXTURE: number;
export let GL_POINT_SMOOTH: number;
export let GL_POINT_SIZE: number;
export let GL_POINT_SIZE_GRANULARITY: number;
export let GL_POINT_SIZE_RANGE: number;
export let GL_LINE_SMOOTH: number;
export let GL_LINE_STIPPLE: number;
export let GL_LINE_STIPPLE_PATTERN: number;
export let GL_LINE_STIPPLE_REPEAT: number;
export let GL_LINE_WIDTH: number;
export let GL_LINE_WIDTH_GRANULARITY: number;
export let GL_LINE_WIDTH_RANGE: number;
export let GL_POINT: number;
export let GL_LINE: number;
export let GL_FILL: number;
export let GL_CW: number;
export let GL_CCW: number;
export let GL_FRONT: number;
export let GL_BACK: number;
export let GL_POLYGON_MODE: number;
export let GL_POLYGON_SMOOTH: number;
export let GL_POLYGON_STIPPLE: number;
export let GL_EDGE_FLAG: number;
export let GL_CULL_FACE: number;
export let GL_CULL_FACE_MODE: number;
export let GL_FRONT_FACE: number;
export let GL_POLYGON_OFFSET_FACTOR: number;
export let GL_POLYGON_OFFSET_UNITS: number;
export let GL_POLYGON_OFFSET_POINT: number;
export let GL_POLYGON_OFFSET_LINE: number;
export let GL_POLYGON_OFFSET_FILL: number;
export let GL_COMPILE: number;
export let GL_COMPILE_AND_EXECUTE: number;
export let GL_LIST_BASE: number;
export let GL_LIST_INDEX: number;
export let GL_LIST_MODE: number;
export let GL_NEVER: number;
export let GL_LESS: number;
export let GL_EQUAL: number;
export let GL_LEQUAL: number;
export let GL_GREATER: number;
export let GL_NOTEQUAL: number;
export let GL_GEQUAL: number;
export let GL_ALWAYS: number;
export let GL_DEPTH_TEST: number;
export let GL_DEPTH_BITS: number;
export let GL_DEPTH_CLEAR_VALUE: number;
export let GL_DEPTH_FUNC: number;
export let GL_DEPTH_RANGE: number;
export let GL_DEPTH_WRITEMASK: number;
export let GL_DEPTH_COMPONENT: number;
export let GL_LIGHTING: number;
export let GL_LIGHT0: number;
export let GL_LIGHT1: number;
export let GL_LIGHT2: number;
export let GL_LIGHT3: number;
export let GL_LIGHT4: number;
export let GL_LIGHT5: number;
export let GL_LIGHT6: number;
export let GL_LIGHT7: number;
export let GL_SPOT_EXPONENT: number;
export let GL_SPOT_CUTOFF: number;
export let GL_CONSTANT_ATTENUATION: number;
export let GL_LINEAR_ATTENUATION: number;
export let GL_QUADRATIC_ATTENUATION: number;
export let GL_AMBIENT: number;
export let GL_DIFFUSE: number;
export let GL_SPECULAR: number;
export let GL_SHININESS: number;
export let GL_EMISSION: number;
export let GL_POSITION: number;
export let GL_SPOT_DIRECTION: number;
export let GL_AMBIENT_AND_DIFFUSE: number;
export let GL_COLOR_INDEXES: number;
export let GL_LIGHT_MODEL_TWO_SIDE: number;
export let GL_LIGHT_MODEL_LOCAL_VIEWER: number;
export let GL_LIGHT_MODEL_AMBIENT: number;
export let GL_FRONT_AND_BACK: number;
export let GL_SHADE_MODEL: number;
export let GL_FLAT: number;
export let GL_SMOOTH: number;
export let GL_COLOR_MATERIAL: number;
export let GL_COLOR_MATERIAL_FACE: number;
export let GL_COLOR_MATERIAL_PARAMETER: number;
export let GL_NORMALIZE: number;
export let GL_CLIP_PLANE0: number;
export let GL_CLIP_PLANE1: number;
export let GL_CLIP_PLANE2: number;
export let GL_CLIP_PLANE3: number;
export let GL_CLIP_PLANE4: number;
export let GL_CLIP_PLANE5: number;
export let GL_ACCUM_RED_BITS: number;
export let GL_ACCUM_GREEN_BITS: number;
export let GL_ACCUM_BLUE_BITS: number;
export let GL_ACCUM_ALPHA_BITS: number;
export let GL_ACCUM_CLEAR_VALUE: number;
export let GL_ACCUM: number;
export let GL_ADD: number;
export let GL_LOAD: number;
export let GL_MULT: number;
export let GL_RETURN: number;
export let GL_ALPHA_TEST: number;
export let GL_ALPHA_TEST_REF: number;
export let GL_ALPHA_TEST_FUNC: number;
export let GL_BLEND: number;
export let GL_BLEND_SRC: number;
export let GL_BLEND_DST: number;
export let GL_ZERO: number;
export let GL_ONE: number;
export let GL_SRC_COLOR: number;
export let GL_ONE_MINUS_SRC_COLOR: number;
export let GL_SRC_ALPHA: number;
export let GL_ONE_MINUS_SRC_ALPHA: number;
export let GL_DST_ALPHA: number;
export let GL_ONE_MINUS_DST_ALPHA: number;
export let GL_DST_COLOR: number;
export let GL_ONE_MINUS_DST_COLOR: number;
export let GL_SRC_ALPHA_SATURATE: number;
export let GL_FEEDBACK: number;
export let GL_RENDER: number;
export let GL_SELECT: number;
export let GL_2D: number;
export let GL_3D: number;
export let GL_3D_COLOR: number;
export let GL_3D_COLOR_TEXTURE: number;
export let GL_4D_COLOR_TEXTURE: number;
export let GL_POINT_TOKEN: number;
export let GL_LINE_TOKEN: number;
export let GL_LINE_RESET_TOKEN: number;
export let GL_POLYGON_TOKEN: number;
export let GL_BITMAP_TOKEN: number;
export let GL_DRAW_PIXEL_TOKEN: number;
export let GL_COPY_PIXEL_TOKEN: number;
export let GL_PASS_THROUGH_TOKEN: number;
export let GL_FEEDBACK_BUFFER_POINTER: number;
export let GL_FEEDBACK_BUFFER_SIZE: number;
export let GL_FEEDBACK_BUFFER_TYPE: number;
export let GL_SELECTION_BUFFER_POINTER: number;
export let GL_SELECTION_BUFFER_SIZE: number;
export let GL_FOG: number;
export let GL_FOG_MODE: number;
export let GL_FOG_DENSITY: number;
export let GL_FOG_COLOR: number;
export let GL_FOG_INDEX: number;
export let GL_FOG_START: number;
export let GL_FOG_END: number;
export let GL_LINEAR: number;
export let GL_EXP: number;
export let GL_EXP2: number;
export let GL_LOGIC_OP: number;
export let GL_INDEX_LOGIC_OP: number;
export let GL_COLOR_LOGIC_OP: number;
export let GL_LOGIC_OP_MODE: number;
export let GL_CLEAR: number;
export let GL_SET: number;
export let GL_COPY: number;
export let GL_COPY_INVERTED: number;
export let GL_NOOP: number;
export let GL_INVERT: number;
export let GL_AND: number;
export let GL_NAND: number;
export let GL_OR: number;
export let GL_NOR: number;
export let GL_XOR: number;
export let GL_EQUIV: number;
export let GL_AND_REVERSE: number;
export let GL_AND_INVERTED: number;
export let GL_OR_REVERSE: number;
export let GL_OR_INVERTED: number;
export let GL_STENCIL_BITS: number;
export let GL_STENCIL_TEST: number;
export let GL_STENCIL_CLEAR_VALUE: number;
export let GL_STENCIL_FUNC: number;
export let GL_STENCIL_VALUE_MASK: number;
export let GL_STENCIL_FAIL: number;
export let GL_STENCIL_PASS_DEPTH_FAIL: number;
export let GL_STENCIL_PASS_DEPTH_PASS: number;
export let GL_STENCIL_REF: number;
export let GL_STENCIL_WRITEMASK: number;
export let GL_STENCIL_INDEX: number;
export let GL_KEEP: number;
export let GL_REPLACE: number;
export let GL_INCR: number;
export let GL_DECR: number;
export let GL_NONE: number;
export let GL_LEFT: number;
export let GL_RIGHT: number;
export let GL_FRONT_LEFT: number;
export let GL_FRONT_RIGHT: number;
export let GL_BACK_LEFT: number;
export let GL_BACK_RIGHT: number;
export let GL_AUX0: number;
export let GL_AUX1: number;
export let GL_AUX2: number;
export let GL_AUX3: number;
export let GL_COLOR_INDEX: number;
export let GL_RED: number;
export let GL_GREEN: number;
export let GL_BLUE: number;
export let GL_ALPHA: number;
export let GL_LUMINANCE: number;
export let GL_LUMINANCE_ALPHA: number;
export let GL_ALPHA_BITS: number;
export let GL_RED_BITS: number;
export let GL_GREEN_BITS: number;
export let GL_BLUE_BITS: number;
export let GL_INDEX_BITS: number;
export let GL_SUBPIXEL_BITS: number;
export let GL_AUX_BUFFERS: number;
export let GL_READ_BUFFER: number;
export let GL_DRAW_BUFFER: number;
export let GL_DOUBLEBUFFER: number;
export let GL_STEREO: number;
export let GL_BITMAP: number;
export let GL_COLOR: number;
export let GL_DEPTH: number;
export let GL_STENCIL: number;
export let GL_DITHER: number;
export let GL_RGB: number;
export let GL_RGBA: number;
export let GL_MAX_LIST_NESTING: number;
export let GL_MAX_EVAL_ORDER: number;
export let GL_MAX_LIGHTS: number;
export let GL_MAX_CLIP_PLANES: number;
export let GL_MAX_TEXTURE_SIZE: number;
export let GL_MAX_PIXEL_MAP_TABLE: number;
export let GL_MAX_ATTRIB_STACK_DEPTH: number;
export let GL_MAX_MODELVIEW_STACK_DEPTH: number;
export let GL_MAX_NAME_STACK_DEPTH: number;
export let GL_MAX_PROJECTION_STACK_DEPTH: number;
export let GL_MAX_TEXTURE_STACK_DEPTH: number;
export let GL_MAX_VIEWPORT_DIMS: number;
export let GL_MAX_CLIENT_ATTRIB_STACK_DEPTH: number;
export let GL_ATTRIB_STACK_DEPTH: number;
export let GL_CLIENT_ATTRIB_STACK_DEPTH: number;
export let GL_COLOR_CLEAR_VALUE: number;
export let GL_COLOR_WRITEMASK: number;
export let GL_CURRENT_INDEX: number;
export let GL_CURRENT_COLOR: number;
export let GL_CURRENT_NORMAL: number;
export let GL_CURRENT_RASTER_COLOR: number;
export let GL_CURRENT_RASTER_DISTANCE: number;
export let GL_CURRENT_RASTER_INDEX: number;
export let GL_CURRENT_RASTER_POSITION: number;
export let GL_CURRENT_RASTER_TEXTURE_COORDS: number;
export let GL_CURRENT_RASTER_POSITION_VALID: number;
export let GL_CURRENT_TEXTURE_COORDS: number;
export let GL_INDEX_CLEAR_VALUE: number;
export let GL_INDEX_MODE: number;
export let GL_INDEX_WRITEMASK: number;
export let GL_MODELVIEW_MATRIX: number;
export let GL_MODELVIEW_STACK_DEPTH: number;
export let GL_NAME_STACK_DEPTH: number;
export let GL_PROJECTION_MATRIX: number;
export let GL_PROJECTION_STACK_DEPTH: number;
export let GL_RENDER_MODE: number;
export let GL_RGBA_MODE: number;
export let GL_TEXTURE_MATRIX: number;
export let GL_TEXTURE_STACK_DEPTH: number;
export let GL_VIEWPORT: number;
export let GL_AUTO_NORMAL: number;
export let GL_MAP1_COLOR_4: number;
export let GL_MAP1_INDEX: number;
export let GL_MAP1_NORMAL: number;
export let GL_MAP1_TEXTURE_COORD_1: number;
export let GL_MAP1_TEXTURE_COORD_2: number;
export let GL_MAP1_TEXTURE_COORD_3: number;
export let GL_MAP1_TEXTURE_COORD_4: number;
export let GL_MAP1_VERTEX_3: number;
export let GL_MAP1_VERTEX_4: number;
export let GL_MAP2_COLOR_4: number;
export let GL_MAP2_INDEX: number;
export let GL_MAP2_NORMAL: number;
export let GL_MAP2_TEXTURE_COORD_1: number;
export let GL_MAP2_TEXTURE_COORD_2: number;
export let GL_MAP2_TEXTURE_COORD_3: number;
export let GL_MAP2_TEXTURE_COORD_4: number;
export let GL_MAP2_VERTEX_3: number;
export let GL_MAP2_VERTEX_4: number;
export let GL_MAP1_GRID_DOMAIN: number;
export let GL_MAP1_GRID_SEGMENTS: number;
export let GL_MAP2_GRID_DOMAIN: number;
export let GL_MAP2_GRID_SEGMENTS: number;
export let GL_COEFF: number;
export let GL_ORDER: number;
export let GL_DOMAIN: number;
export let GL_PERSPECTIVE_CORRECTION_HINT: number;
export let GL_POINT_SMOOTH_HINT: number;
export let GL_LINE_SMOOTH_HINT: number;
export let GL_POLYGON_SMOOTH_HINT: number;
export let GL_FOG_HINT: number;
export let GL_DONT_CARE: number;
export let GL_FASTEST: number;
export let GL_NICEST: number;
export let GL_SCISSOR_BOX: number;
export let GL_SCISSOR_TEST: number;
export let GL_MAP_COLOR: number;
export let GL_MAP_STENCIL: number;
export let GL_INDEX_SHIFT: number;
export let GL_INDEX_OFFSET: number;
export let GL_RED_SCALE: number;
export let GL_RED_BIAS: number;
export let GL_GREEN_SCALE: number;
export let GL_GREEN_BIAS: number;
export let GL_BLUE_SCALE: number;
export let GL_BLUE_BIAS: number;
export let GL_ALPHA_SCALE: number;
export let GL_ALPHA_BIAS: number;
export let GL_DEPTH_SCALE: number;
export let GL_DEPTH_BIAS: number;
export let GL_PIXEL_MAP_S_TO_S_SIZE: number;
export let GL_PIXEL_MAP_I_TO_I_SIZE: number;
export let GL_PIXEL_MAP_I_TO_R_SIZE: number;
export let GL_PIXEL_MAP_I_TO_G_SIZE: number;
export let GL_PIXEL_MAP_I_TO_B_SIZE: number;
export let GL_PIXEL_MAP_I_TO_A_SIZE: number;
export let GL_PIXEL_MAP_R_TO_R_SIZE: number;
export let GL_PIXEL_MAP_G_TO_G_SIZE: number;
export let GL_PIXEL_MAP_B_TO_B_SIZE: number;
export let GL_PIXEL_MAP_A_TO_A_SIZE: number;
export let GL_PIXEL_MAP_S_TO_S: number;
export let GL_PIXEL_MAP_I_TO_I: number;
export let GL_PIXEL_MAP_I_TO_R: number;
export let GL_PIXEL_MAP_I_TO_G: number;
export let GL_PIXEL_MAP_I_TO_B: number;
export let GL_PIXEL_MAP_I_TO_A: number;
export let GL_PIXEL_MAP_R_TO_R: number;
export let GL_PIXEL_MAP_G_TO_G: number;
export let GL_PIXEL_MAP_B_TO_B: number;
export let GL_PIXEL_MAP_A_TO_A: number;
export let GL_PACK_ALIGNMENT: number;
export let GL_PACK_LSB_FIRST: number;
export let GL_PACK_ROW_LENGTH: number;
export let GL_PACK_SKIP_PIXELS: number;
export let GL_PACK_SKIP_ROWS: number;
export let GL_PACK_SWAP_BYTES: number;
export let GL_UNPACK_ALIGNMENT: number;
export let GL_UNPACK_LSB_FIRST: number;
export let GL_UNPACK_ROW_LENGTH: number;
export let GL_UNPACK_SKIP_PIXELS: number;
export let GL_UNPACK_SKIP_ROWS: number;
export let GL_UNPACK_SWAP_BYTES: number;
export let GL_ZOOM_X: number;
export let GL_ZOOM_Y: number;
export let GL_TEXTURE_ENV: number;
export let GL_TEXTURE_ENV_MODE: number;
export let GL_TEXTURE_1D: number;
export let GL_TEXTURE_2D: number;
export let GL_TEXTURE_WRAP_S: number;
export let GL_TEXTURE_WRAP_T: number;
export let GL_TEXTURE_MAG_FILTER: number;
export let GL_TEXTURE_MIN_FILTER: number;
export let GL_TEXTURE_ENV_COLOR: number;
export let GL_TEXTURE_GEN_S: number;
export let GL_TEXTURE_GEN_T: number;
export let GL_TEXTURE_GEN_R: number;
export let GL_TEXTURE_GEN_Q: number;
export let GL_TEXTURE_GEN_MODE: number;
export let GL_TEXTURE_BORDER_COLOR: number;
export let GL_TEXTURE_WIDTH: number;
export let GL_TEXTURE_HEIGHT: number;
export let GL_TEXTURE_BORDER: number;
export let GL_TEXTURE_COMPONENTS: number;
export let GL_TEXTURE_RED_SIZE: number;
export let GL_TEXTURE_GREEN_SIZE: number;
export let GL_TEXTURE_BLUE_SIZE: number;
export let GL_TEXTURE_ALPHA_SIZE: number;
export let GL_TEXTURE_LUMINANCE_SIZE: number;
export let GL_TEXTURE_INTENSITY_SIZE: number;
export let GL_NEAREST_MIPMAP_NEAREST: number;
export let GL_NEAREST_MIPMAP_LINEAR: number;
export let GL_LINEAR_MIPMAP_NEAREST: number;
export let GL_LINEAR_MIPMAP_LINEAR: number;
export let GL_OBJECT_LINEAR: number;
export let GL_OBJECT_PLANE: number;
export let GL_EYE_LINEAR: number;
export let GL_EYE_PLANE: number;
export let GL_SPHERE_MAP: number;
export let GL_DECAL: number;
export let GL_MODULATE: number;
export let GL_NEAREST: number;
export let GL_REPEAT: number;
export let GL_CLAMP: number;
export let GL_S: number;
export let GL_T: number;
export let GL_R: number;
export let GL_Q: number;
export let GL_VENDOR: number;
export let GL_RENDERER: number;
export let GL_VERSION: number;
export let GL_EXTENSIONS: number;
export let GL_NO_ERROR: number;
export let GL_INVALID_ENUM: number;
export let GL_INVALID_VALUE: number;
export let GL_INVALID_OPERATION: number;
export let GL_STACK_OVERFLOW: number;
export let GL_STACK_UNDERFLOW: number;
export let GL_OUT_OF_MEMORY: number;
export let GL_CURRENT_BIT: number;
export let GL_POINT_BIT: number;
export let GL_LINE_BIT: number;
export let GL_POLYGON_BIT: number;
export let GL_POLYGON_STIPPLE_BIT: number;
export let GL_PIXEL_MODE_BIT: number;
export let GL_LIGHTING_BIT: number;
export let GL_FOG_BIT: number;
export let GL_DEPTH_BUFFER_BIT: number;
export let GL_ACCUM_BUFFER_BIT: number;
export let GL_STENCIL_BUFFER_BIT: number;
export let GL_VIEWPORT_BIT: number;
export let GL_TRANSFORM_BIT: number;
export let GL_ENABLE_BIT: number;
export let GL_COLOR_BUFFER_BIT: number;
export let GL_HINT_BIT: number;
export let GL_EVAL_BIT: number;
export let GL_LIST_BIT: number;
export let GL_TEXTURE_BIT: number;
export let GL_SCISSOR_BIT: number;
export let GL_ALL_ATTRIB_BITS: number;
export let GL_PROXY_TEXTURE_1D: number;
export let GL_PROXY_TEXTURE_2D: number;
export let GL_TEXTURE_PRIORITY: number;
export let GL_TEXTURE_RESIDENT: number;
export let GL_TEXTURE_BINDING_1D: number;
export let GL_TEXTURE_BINDING_2D: number;
export let GL_TEXTURE_INTERNAL_FORMAT: number;
export let GL_ALPHA4: number;
export let GL_ALPHA8: number;
export let GL_ALPHA12: number;
export let GL_ALPHA16: number;
export let GL_LUMINANCE4: number;
export let GL_LUMINANCE8: number;
export let GL_LUMINANCE12: number;
export let GL_LUMINANCE16: number;
export let GL_LUMINANCE4_ALPHA4: number;
export let GL_LUMINANCE6_ALPHA2: number;
export let GL_LUMINANCE8_ALPHA8: number;
export let GL_LUMINANCE12_ALPHA4: number;
export let GL_LUMINANCE12_ALPHA12: number;
export let GL_LUMINANCE16_ALPHA16: number;
export let GL_INTENSITY: number;
export let GL_INTENSITY4: number;
export let GL_INTENSITY8: number;
export let GL_INTENSITY12: number;
export let GL_INTENSITY16: number;
export let GL_R3_G3_B2: number;
export let GL_RGB4: number;
export let GL_RGB5: number;
export let GL_RGB8: number;
export let GL_RGB10: number;
export let GL_RGB12: number;
export let GL_RGB16: number;
export let GL_RGBA2: number;
export let GL_RGBA4: number;
export let GL_RGB5_A1: number;
export let GL_RGBA8: number;
export let GL_RGB10_A2: number;
export let GL_RGBA12: number;
export let GL_RGBA16: number;
export let GL_CLIENT_PIXEL_STORE_BIT: number;
export let GL_CLIENT_VERTEX_ARRAY_BIT: number;
export let GL_ALL_CLIENT_ATTRIB_BITS: number;
export let GL_CLIENT_ALL_ATTRIB_BITS: number;
